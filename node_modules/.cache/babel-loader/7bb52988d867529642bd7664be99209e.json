{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\khouloud\\\\Documents\\\\PI\\\\MERN_Stack_PI\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\khouloud\\\\Documents\\\\PI\\\\MERN_Stack_PI\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst sanitize_1 = require(\"./utils/sanitize\");\n\nconst uri_1 = require(\"./utils/uri\");\n\nconst syncerror_1 = require(\"./utils/syncerror\");\n\nconst logger_1 = require(\"./utils/logger\");\n\nconst entity_1 = require(\"./entity\");\n\nconst listitem_1 = require(\"./listitem\");\n\nconst paginator_1 = require(\"./paginator\");\n\nconst cache_1 = require(\"./cache\");\n\nconst mergingqueue_1 = require(\"./mergingqueue\");\n\nconst closeable_1 = require(\"./closeable\");\n\nclass SyncListImpl extends entity_1.SyncEntity {\n  /**\n   * @private\n   */\n  constructor(services, descriptor, removalHandler) {\n    super(services, removalHandler);\n\n    const updateRequestReducer = (acc, input) => typeof input.ttl === 'number' ? {\n      ttl: input.ttl\n    } : acc;\n\n    this.updateMergingQueue = new mergingqueue_1.NamespacedMergingQueue(updateRequestReducer);\n    this.cache = new cache_1.Cache();\n    this.descriptor = descriptor;\n    this.descriptor.date_updated = new Date(this.descriptor.date_updated);\n  } // private props\n\n\n  get uri() {\n    return this.descriptor.url;\n  }\n\n  get revision() {\n    return this.descriptor.revision;\n  }\n\n  get lastEventId() {\n    return this.descriptor.last_event_id;\n  }\n\n  get links() {\n    return this.descriptor.links;\n  }\n\n  get dateExpires() {\n    return this.descriptor.date_expires;\n  }\n\n  static get type() {\n    return 'list';\n  }\n\n  get type() {\n    return 'list';\n  } // below properties are specific to Insights only\n\n\n  get indexName() {\n    return undefined;\n  }\n\n  get queryString() {\n    return undefined;\n  } // public props, documented along with class description\n\n\n  get sid() {\n    return this.descriptor.sid;\n  }\n\n  get uniqueName() {\n    return this.descriptor.unique_name || null;\n  }\n\n  get dateUpdated() {\n    return this.descriptor.date_updated;\n  }\n\n  _addOrUpdateItemOnServer(url, data, ifMatch, ttl) {\n    var _this = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var requestBody, response;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            requestBody = {\n              data\n            };\n\n            if (ttl !== undefined) {\n              requestBody.ttl = ttl;\n            }\n\n            _context.next = 4;\n            return _this.services.network.post(url, requestBody, ifMatch);\n\n          case 4:\n            response = _context.sent;\n            response.body.data = data;\n            response.body.date_updated = new Date(response.body.date_updated);\n            return _context.abrupt(\"return\", response.body);\n\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }))();\n  }\n\n  push(value, itemMetadata) {\n    var _this2 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      var ttl, item, index;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            ttl = (itemMetadata || {}).ttl;\n            sanitize_1.validateOptionalTtl(ttl);\n            _context2.next = 4;\n            return _this2._addOrUpdateItemOnServer(_this2.links.items, value, undefined, ttl);\n\n          case 4:\n            item = _context2.sent;\n            index = Number(item.index);\n\n            _this2._handleItemMutated(index, item.url, item.last_event_id, item.revision, value, item.date_updated, item.date_expires, true, false);\n\n            return _context2.abrupt(\"return\", _this2.cache.get(index));\n\n          case 8:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }))();\n  }\n\n  set(index, value, itemMetadataUpdates) {\n    var _this3 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n      var input;\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            input = itemMetadataUpdates || {};\n            sanitize_1.validateOptionalTtl(input.ttl);\n            return _context3.abrupt(\"return\", _this3.updateMergingQueue.squashAndAdd(index, input, input => _this3._updateItemUnconditionally(index, value, input.ttl)));\n\n          case 3:\n          case \"end\":\n            return _context3.stop();\n        }\n      }, _callee3);\n    }))();\n  }\n\n  _updateItemUnconditionally(index, data, ttl) {\n    var _this4 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n      var existingItem, itemDescriptor;\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return _this4.get(index);\n\n          case 2:\n            existingItem = _context4.sent;\n            _context4.next = 5;\n            return _this4._addOrUpdateItemOnServer(existingItem.uri, data, undefined, ttl);\n\n          case 5:\n            itemDescriptor = _context4.sent;\n\n            _this4._handleItemMutated(index, itemDescriptor.url, itemDescriptor.last_event_id, itemDescriptor.revision, itemDescriptor.data, itemDescriptor.date_updated, itemDescriptor.date_expires, false, false);\n\n            return _context4.abrupt(\"return\", _this4.cache.get(index));\n\n          case 8:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee4);\n    }))();\n  }\n\n  _updateItemWithIfMatch(index, mutatorFunction, ttl) {\n    var _this5 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n      var existingItem, data, ifMatch, itemDescriptor;\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.next = 2;\n            return _this5.get(index);\n\n          case 2:\n            existingItem = _context5.sent;\n            data = mutatorFunction(sanitize_1.deepClone(existingItem.value));\n\n            if (!data) {\n              _context5.next = 25;\n              break;\n            }\n\n            ifMatch = existingItem.revision;\n            _context5.prev = 6;\n            _context5.next = 9;\n            return _this5._addOrUpdateItemOnServer(existingItem.uri, data, ifMatch, ttl);\n\n          case 9:\n            itemDescriptor = _context5.sent;\n\n            _this5._handleItemMutated(index, itemDescriptor.url, itemDescriptor.last_event_id, itemDescriptor.revision, itemDescriptor.data, itemDescriptor.date_updated, itemDescriptor.date_expires, false, false);\n\n            return _context5.abrupt(\"return\", _this5.cache.get(index));\n\n          case 14:\n            _context5.prev = 14;\n            _context5.t0 = _context5[\"catch\"](6);\n\n            if (!(_context5.t0.status === 412)) {\n              _context5.next = 22;\n              break;\n            }\n\n            _context5.next = 19;\n            return _this5._getItemFromServer(index);\n\n          case 19:\n            return _context5.abrupt(\"return\", _this5._updateItemWithIfMatch(index, mutatorFunction, ttl));\n\n          case 22:\n            throw _context5.t0;\n\n          case 23:\n            _context5.next = 26;\n            break;\n\n          case 25:\n            return _context5.abrupt(\"return\", existingItem);\n\n          case 26:\n          case \"end\":\n            return _context5.stop();\n        }\n      }, _callee5, null, [[6, 14]]);\n    }))();\n  }\n\n  mutate(index, mutator, itemMetadataUpdates) {\n    var _this6 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n      var input;\n      return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n        while (1) switch (_context6.prev = _context6.next) {\n          case 0:\n            input = itemMetadataUpdates || {};\n            sanitize_1.validateOptionalTtl(input.ttl);\n            return _context6.abrupt(\"return\", _this6.updateMergingQueue.add(index, input, input => _this6._updateItemWithIfMatch(index, mutator, input.ttl)));\n\n          case 3:\n          case \"end\":\n            return _context6.stop();\n        }\n      }, _callee6);\n    }))();\n  }\n\n  update(index, obj, itemMetadataUpdates) {\n    var _this7 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n      return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n        while (1) switch (_context7.prev = _context7.next) {\n          case 0:\n            return _context7.abrupt(\"return\", _this7.mutate(index, remote => Object.assign(remote, obj), itemMetadataUpdates));\n\n          case 1:\n          case \"end\":\n            return _context7.stop();\n        }\n      }, _callee7);\n    }))();\n  }\n\n  remove(index) {\n    var _this8 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n      var item, response;\n      return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n        while (1) switch (_context8.prev = _context8.next) {\n          case 0:\n            _context8.next = 2;\n            return _this8.get(index);\n\n          case 2:\n            item = _context8.sent;\n            _context8.next = 5;\n            return _this8.services.network.delete(item.uri);\n\n          case 5:\n            response = _context8.sent;\n\n            _this8._handleItemRemoved(index, response.body.last_event_id, undefined, new Date(response.body.date_updated), false);\n\n          case 7:\n          case \"end\":\n            return _context8.stop();\n        }\n      }, _callee8);\n    }))();\n  }\n\n  get(index) {\n    var _this9 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n      var cachedItem;\n      return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n        while (1) switch (_context9.prev = _context9.next) {\n          case 0:\n            cachedItem = _this9.cache.get(index);\n\n            if (!cachedItem) {\n              _context9.next = 5;\n              break;\n            }\n\n            return _context9.abrupt(\"return\", cachedItem);\n\n          case 5:\n            return _context9.abrupt(\"return\", _this9._getItemFromServer(index));\n\n          case 6:\n          case \"end\":\n            return _context9.stop();\n        }\n      }, _callee9);\n    }))();\n  }\n\n  _getItemFromServer(index) {\n    var _this10 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n      var result;\n      return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n        while (1) switch (_context10.prev = _context10.next) {\n          case 0:\n            _context10.next = 2;\n            return _this10.queryItems({\n              index\n            });\n\n          case 2:\n            result = _context10.sent;\n\n            if (!(result.items.length < 1)) {\n              _context10.next = 7;\n              break;\n            }\n\n            throw new syncerror_1.SyncError(\"No item with index \".concat(index, \" found\"), 404, 54151);\n\n          case 7:\n            return _context10.abrupt(\"return\", result.items[0]);\n\n          case 8:\n          case \"end\":\n            return _context10.stop();\n        }\n      }, _callee10);\n    }))();\n  }\n  /**\n   * Query items from the List\n   * @private\n   */\n\n\n  queryItems(arg) {\n    var _this11 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {\n      var url, response, items, meta;\n      return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n        while (1) switch (_context11.prev = _context11.next) {\n          case 0:\n            arg = arg || {};\n            url = new uri_1.UriBuilder(_this11.links.items).queryParam('From', arg.from).queryParam('PageSize', arg.limit).queryParam('Index', arg.index).queryParam('PageToken', arg.pageToken).queryParam('Order', arg.order).build();\n            _context11.next = 4;\n            return _this11.services.network.get(url);\n\n          case 4:\n            response = _context11.sent;\n            items = response.body.items.map(el => {\n              el.date_updated = new Date(el.date_updated);\n\n              let itemInCache = _this11.cache.get(el.index);\n\n              if (itemInCache) {\n                _this11._handleItemMutated(el.index, el.url, el.last_event_id, el.revision, el.data, el.date_updated, el.date_expires, false, true);\n              } else {\n                _this11.cache.store(Number(el.index), new listitem_1.ListItem({\n                  index: Number(el.index),\n                  uri: el.url,\n                  revision: el.revision,\n                  lastEventId: el.last_event_id,\n                  dateUpdated: el.date_updated,\n                  dateExpires: el.date_expires,\n                  value: el.data\n                }), el.last_event_id);\n              }\n\n              return _this11.cache.get(el.index);\n            });\n            meta = response.body.meta;\n            return _context11.abrupt(\"return\", new paginator_1.Paginator(items, pageToken => _this11.queryItems({\n              pageToken\n            }), meta.previous_token, meta.next_token));\n\n          case 8:\n          case \"end\":\n            return _context11.stop();\n        }\n      }, _callee11);\n    }))();\n  }\n\n  getItems(args) {\n    var _this12 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {\n      return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n        while (1) switch (_context12.prev = _context12.next) {\n          case 0:\n            args = args || {};\n            sanitize_1.validatePageSize(args.pageSize);\n            args.limit = args.pageSize || args.limit || 50;\n            args.order = args.order || 'asc';\n            return _context12.abrupt(\"return\", _this12.queryItems(args));\n\n          case 5:\n          case \"end\":\n            return _context12.stop();\n        }\n      }, _callee12);\n    }))();\n  }\n  /**\n   * @return {Promise<Object>} Context of List\n   * @private\n   */\n\n\n  getContext() {\n    var _this13 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {\n      var response;\n      return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n        while (1) switch (_context13.prev = _context13.next) {\n          case 0:\n            if (_this13.context) {\n              _context13.next = 5;\n              break;\n            }\n\n            _context13.next = 3;\n            return _this13.services.network.get(_this13.links.context);\n\n          case 3:\n            response = _context13.sent;\n\n            // store fetched context if we have't received any newer update\n            _this13._updateContextIfRequired(response.body.data, response.body.last_event_id);\n\n          case 5:\n            return _context13.abrupt(\"return\", _this13.context);\n\n          case 6:\n          case \"end\":\n            return _context13.stop();\n        }\n      }, _callee13);\n    }))();\n  }\n\n  setTtl(ttl) {\n    var _this14 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14() {\n      var requestBody, response;\n      return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n        while (1) switch (_context14.prev = _context14.next) {\n          case 0:\n            sanitize_1.validateMandatoryTtl(ttl);\n            _context14.prev = 1;\n            requestBody = {\n              ttl\n            };\n            _context14.next = 5;\n            return _this14.services.network.post(_this14.uri, requestBody);\n\n          case 5:\n            response = _context14.sent;\n            _this14.descriptor.date_expires = response.body.date_expires;\n            _context14.next = 13;\n            break;\n\n          case 9:\n            _context14.prev = 9;\n            _context14.t0 = _context14[\"catch\"](1);\n\n            if (_context14.t0.status === 404) {\n              _this14.onRemoved(false);\n            }\n\n            throw _context14.t0;\n\n          case 13:\n          case \"end\":\n            return _context14.stop();\n        }\n      }, _callee14, null, [[1, 9]]);\n    }))();\n  }\n\n  setItemTtl(index, ttl) {\n    var _this15 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15() {\n      var existingItem, requestBody, response;\n      return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n        while (1) switch (_context15.prev = _context15.next) {\n          case 0:\n            sanitize_1.validateMandatoryTtl(ttl);\n            _context15.next = 3;\n            return _this15.get(index);\n\n          case 3:\n            existingItem = _context15.sent;\n            requestBody = {\n              ttl\n            };\n            _context15.next = 7;\n            return _this15.services.network.post(existingItem.uri, requestBody);\n\n          case 7:\n            response = _context15.sent;\n            existingItem.updateDateExpires(response.body.date_expires);\n\n          case 9:\n          case \"end\":\n            return _context15.stop();\n        }\n      }, _callee15);\n    }))();\n  }\n\n  removeList() {\n    var _this16 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16() {\n      return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n        while (1) switch (_context16.prev = _context16.next) {\n          case 0:\n            _context16.next = 2;\n            return _this16.services.network.delete(_this16.uri);\n\n          case 2:\n            _this16.onRemoved(true);\n\n          case 3:\n          case \"end\":\n            return _context16.stop();\n        }\n      }, _callee16);\n    }))();\n  }\n\n  onRemoved(locally) {\n    this._unsubscribe();\n\n    this.removalHandler(this.type, this.sid, this.uniqueName);\n    this.broadcastEventToListeners('removed', {\n      isLocal: locally\n    });\n  }\n\n  shouldIgnoreEvent(key, eventId) {\n    return this.cache.isKnown(key, eventId);\n  }\n  /**\n   * Handle update, which came from the server.\n   * @private\n   */\n\n\n  _update(update, isStrictlyOrdered) {\n    const itemIndex = Number(update.item_index);\n    update.date_created = new Date(update.date_created);\n\n    switch (update.type) {\n      case 'list_item_added':\n      case 'list_item_updated':\n        {\n          this._handleItemMutated(itemIndex, update.item_url, update.id, update.item_revision, update.item_data, update.date_created, undefined, // orchestration does not include date_expires\n          update.type === 'list_item_added', true);\n        }\n        break;\n\n      case 'list_item_removed':\n        {\n          this._handleItemRemoved(itemIndex, update.id, update.item_data, update.date_created, true);\n        }\n        break;\n\n      case 'list_context_updated':\n        {\n          this._handleContextUpdate(update.context_data, update.id, update.date_created);\n        }\n        break;\n\n      case 'list_removed':\n        {\n          this.onRemoved(false);\n        }\n        break;\n    }\n\n    if (isStrictlyOrdered) {\n      this._advanceLastEventId(update.id, update.list_revision);\n    }\n  }\n\n  _advanceLastEventId(eventId, revision) {\n    if (this.lastEventId < eventId) {\n      this.descriptor.last_event_id = eventId;\n\n      if (revision) {\n        this.descriptor.revision = revision;\n      }\n    }\n  }\n\n  _updateRootDateUpdated(dateUpdated) {\n    if (!this.descriptor.date_updated || dateUpdated.getTime() > this.descriptor.date_updated.getTime()) {\n      this.descriptor.date_updated = dateUpdated;\n      this.services.storage.update(this.type, this.sid, this.uniqueName, {\n        date_updated: dateUpdated\n      });\n    }\n  }\n\n  _handleItemMutated(index, uri, lastEventId, revision, value, dateUpdated, dateExpires, added, remote) {\n    if (this.shouldIgnoreEvent(index, lastEventId)) {\n      logger_1.default.trace('Item ', index, ' update skipped, current:', this.lastEventId, ', remote:', lastEventId);\n      return;\n    } else {\n      this._updateRootDateUpdated(dateUpdated);\n\n      let item = this.cache.get(index);\n\n      if (!item) {\n        let item = new listitem_1.ListItem({\n          index,\n          uri,\n          lastEventId,\n          revision,\n          value,\n          dateUpdated,\n          dateExpires\n        });\n        this.cache.store(index, item, lastEventId);\n        this.emitItemMutationEvent(item, remote, added);\n      } else {\n        item.update(lastEventId, revision, value, dateUpdated);\n        this.cache.store(index, item, lastEventId);\n\n        if (dateExpires !== undefined) {\n          item.updateDateExpires(dateExpires);\n        }\n\n        this.emitItemMutationEvent(item, remote, false);\n      }\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  emitItemMutationEvent(item, remote, added) {\n    let eventName = added ? 'itemAdded' : 'itemUpdated';\n    this.broadcastEventToListeners(eventName, {\n      item: item,\n      isLocal: !remote\n    });\n  }\n  /**\n   * @private\n   */\n\n\n  _handleItemRemoved(index, eventId, oldData, dateUpdated, remote) {\n    this._updateRootDateUpdated(dateUpdated);\n\n    this.cache.delete(index, eventId);\n    this.broadcastEventToListeners('itemRemoved', {\n      index: index,\n      isLocal: !remote,\n      value: oldData\n    });\n  }\n  /**\n   * @private\n   */\n\n\n  _handleContextUpdate(data, eventId, dateUpdated) {\n    this._updateRootDateUpdated(dateUpdated);\n\n    if (this._updateContextIfRequired(data, eventId)) {\n      this.broadcastEventToListeners('contextUpdated', {\n        context: data,\n        isLocal: false\n      });\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  _updateContextIfRequired(data, eventId) {\n    if (!this.contextEventId || eventId > this.contextEventId) {\n      this.context = data;\n      this.contextEventId = eventId;\n      return true;\n    } else {\n      logger_1.default.trace('Context update skipped, current:', this.lastEventId, ', remote:', eventId);\n      return false;\n    }\n  }\n\n}\n\nexports.SyncListImpl = SyncListImpl;\n/**\n * @class\n * @alias List\n * @classdesc Represents a Sync List, which stores an ordered list of values.\n * Use the {@link Client#list} method to obtain a reference to a Sync List.\n * @property {String} sid - List unique id, immutable identifier assigned by the system.\n * @property {String} [uniqueName=null] - List unique name, immutable identifier that can be assigned to list during creation.\n * @property {Date} dateUpdated Date when the List was last updated.\n *\n * @fires List#removed\n * @fires List#itemAdded\n * @fires List#itemRemoved\n * @fires List#itemUpdated\n */\n\nclass SyncList extends closeable_1.default {\n  constructor(syncListImpl) {\n    super();\n    this.syncListImpl = syncListImpl;\n    this.syncListImpl.attach(this);\n  } // private props\n\n\n  get uri() {\n    return this.syncListImpl.uri;\n  }\n\n  get revision() {\n    return this.syncListImpl.revision;\n  }\n\n  get lastEventId() {\n    return this.syncListImpl.lastEventId;\n  }\n\n  get links() {\n    return this.syncListImpl.links;\n  }\n\n  get dateExpires() {\n    return this.syncListImpl.dateExpires;\n  }\n\n  static get type() {\n    return SyncListImpl.type;\n  }\n\n  get type() {\n    return SyncListImpl.type;\n  } // public props, documented along with class description\n\n\n  get sid() {\n    return this.syncListImpl.sid;\n  }\n\n  get uniqueName() {\n    return this.syncListImpl.uniqueName;\n  }\n\n  get dateUpdated() {\n    return this.syncListImpl.dateUpdated;\n  }\n  /**\n   * Add a new item to the list.\n   * @param {Object} value Value to be added.\n   * @param {List#ItemMetadata} [itemMetadata] Item metadata.\n   * @returns {Promise<ListItem>} A newly added item.\n   * @public\n   * @example\n   * list.push({ name: 'John Smith' }, { ttl: 86400 })\n   *   .then(function(item) {\n   *     console.log('List Item push() successful, item index:' + item.index + ', value: ', item.value)\n   *   })\n   *   .catch(function(error) {\n   *     console.error('List Item push() failed', error);\n   *   });\n   */\n\n\n  push(value, itemMetadata) {\n    var _this17 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17() {\n      return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n        while (1) switch (_context17.prev = _context17.next) {\n          case 0:\n            _this17.ensureNotClosed();\n\n            return _context17.abrupt(\"return\", _this17.syncListImpl.push(value, itemMetadata));\n\n          case 2:\n          case \"end\":\n            return _context17.stop();\n        }\n      }, _callee17);\n    }))();\n  }\n  /**\n   * Assign new value to an existing item, given its index.\n   * @param {Number} index Index of the item to be updated.\n   * @param {Object} value New value to be assigned to an item.\n   * @param {List#ItemMetadata} [itemMetadataUpdates] New item metadata.\n   * @returns {Promise<ListItem>} A promise with updated item containing latest known value.\n   * The promise will be rejected if the item does not exist.\n   * @public\n   * @example\n   * list.set(42, { name: 'John Smith' }, { ttl: 86400 })\n   *   .then(function(item) {\n   *     console.log('List Item set() successful, item value:', item.value)\n   *   })\n   *   .catch(function(error) {\n   *     console.error('List Item set() failed', error);\n   *   });\n   */\n\n\n  set(index, value, itemMetadataUpdates) {\n    var _this18 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee18() {\n      return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n        while (1) switch (_context18.prev = _context18.next) {\n          case 0:\n            _this18.ensureNotClosed();\n\n            return _context18.abrupt(\"return\", _this18.syncListImpl.set(index, value, itemMetadataUpdates));\n\n          case 2:\n          case \"end\":\n            return _context18.stop();\n        }\n      }, _callee18);\n    }))();\n  }\n  /**\n   * Modify an existing item by applying a mutation function to it.\n   * @param {Number} index Index of an item to be changed.\n   * @param {List~Mutator} mutator A function that outputs a new value based on the existing value.\n   * @param {List#ItemMetadata} [itemMetadataUpdates] New item metadata.\n   * @returns {Promise<ListItem>} Resolves with the most recent item state, the output of a successful\n   *    mutation or a state that prompted graceful cancellation (mutator returned <code>null</code>). This promise\n   *    will be rejected if the indicated item does not already exist.\n   * @public\n   * @example\n   * var mutatorFunction = function(currentValue) {\n   *     currentValue.viewCount = (currentValue.viewCount || 0) + 1;\n   *     return currentValue;\n   * };\n   * list.mutate(42, mutatorFunction, { ttl: 86400 })\n   *   .then(function(item) {\n   *     console.log('List Item mutate() successful, new value:', item.value)\n   *   })\n   *   .catch(function(error) {\n   *     console.error('List Item mutate() failed', error);\n   *   });\n   */\n\n\n  mutate(index, mutator, itemMetadataUpdates) {\n    var _this19 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee19() {\n      return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n        while (1) switch (_context19.prev = _context19.next) {\n          case 0:\n            _this19.ensureNotClosed();\n\n            return _context19.abrupt(\"return\", _this19.syncListImpl.mutate(index, mutator, itemMetadataUpdates));\n\n          case 2:\n          case \"end\":\n            return _context19.stop();\n        }\n      }, _callee19);\n    }))();\n  }\n  /**\n   * Modify an existing item by appending new fields (or overwriting existing ones) with the values from Object.\n   * This is equivalent to\n   * <pre>\n   * list.mutate(42, function(currentValue) {\n   *   return Object.assign(currentValue, obj));\n   * });\n   * </pre>\n   * @param {Number} index Index of an item to be changed.\n   * @param {Object} obj Set of fields to update.\n   * @param {List#ItemMetadata} [itemMetadataUpdates] New item metadata.\n   * @returns {Promise<ListItem>} A promise with a modified item containing latest known value.\n   * The promise will be rejected if an item was not found.\n   * @public\n   * @example\n   * // Say, the List Item (index: 42) value is { name: 'John Smith' }\n   * list.update(42, { age: 34 }, { ttl: 86400 })\n   *   .then(function(item) {\n   *     // Now the List Item value is { name: 'John Smith', age: 34 }\n   *     console.log('List Item update() successful, new value:', item.value);\n   *   })\n   *   .catch(function(error) {\n   *     console.error('List Item update() failed', error);\n   *   });\n   */\n\n\n  update(index, obj, itemMetadataUpdates) {\n    var _this20 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee20() {\n      return _regeneratorRuntime.wrap(function _callee20$(_context20) {\n        while (1) switch (_context20.prev = _context20.next) {\n          case 0:\n            _this20.ensureNotClosed();\n\n            return _context20.abrupt(\"return\", _this20.syncListImpl.update(index, obj, itemMetadataUpdates));\n\n          case 2:\n          case \"end\":\n            return _context20.stop();\n        }\n      }, _callee20);\n    }))();\n  }\n  /**\n   * Delete an item, given its index.\n   * @param {Number} index Index of an item to be removed.\n   * @returns {Promise<void>} A promise to remove an item.\n   * A promise will be rejected if an item was not found.\n   * @public\n   * @example\n   * list.remove(42)\n   *   .then(function() {\n   *     console.log('List Item remove() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('List Item remove() failed', error);\n   *   });\n   */\n\n\n  remove(index) {\n    var _this21 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee21() {\n      return _regeneratorRuntime.wrap(function _callee21$(_context21) {\n        while (1) switch (_context21.prev = _context21.next) {\n          case 0:\n            _this21.ensureNotClosed();\n\n            return _context21.abrupt(\"return\", _this21.syncListImpl.remove(index));\n\n          case 2:\n          case \"end\":\n            return _context21.stop();\n        }\n      }, _callee21);\n    }))();\n  }\n  /**\n   * Retrieve an item by List index.\n   * @param {Number} index Item index in a List.\n   * @returns {Promise<ListItem>} A promise with an item containing latest known value.\n   * A promise will be rejected if an item was not found.\n   * @public\n   * @example\n   * list.get(42)\n   *   .then(function(item) {\n   *     console.log('List Item get() successful, item value:', item.value)\n   *   })\n   *   .catch(function(error) {\n   *     console.error('List Item get() failed', error);\n   *   });\n   */\n\n\n  get(index) {\n    var _this22 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee22() {\n      return _regeneratorRuntime.wrap(function _callee22$(_context22) {\n        while (1) switch (_context22.prev = _context22.next) {\n          case 0:\n            _this22.ensureNotClosed();\n\n            return _context22.abrupt(\"return\", _this22.syncListImpl.get(index));\n\n          case 2:\n          case \"end\":\n            return _context22.stop();\n        }\n      }, _callee22);\n    }))();\n  }\n  /**\n   * Retrieve a List context\n   * @returns {Promise<Object>} A promise with a List's context\n   * @ignore\n   */\n\n\n  getContext() {\n    var _this23 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee23() {\n      return _regeneratorRuntime.wrap(function _callee23$(_context23) {\n        while (1) switch (_context23.prev = _context23.next) {\n          case 0:\n            _this23.ensureNotClosed();\n\n            return _context23.abrupt(\"return\", _this23.syncListImpl.getContext());\n\n          case 2:\n          case \"end\":\n            return _context23.stop();\n        }\n      }, _callee23);\n    }))();\n  }\n  /**\n   * Query a list of items from collection.\n   * @param {Object} [args] Arguments for query\n   * @param {Number} [args.from] Item index, which should be used as the offset.\n   * If undefined, starts from the beginning or end depending on args.order.\n   * @param {Number} [args.pageSize=50] Results page size.\n   * @param {'asc'|'desc'} [args.order='asc'] Numeric order of results.\n   * @returns {Promise<Paginator<ListItem>>}\n   * @public\n   * @example\n   * var pageHandler = function(paginator) {\n   *   paginator.items.forEach(function(item) {\n   *     console.log('Item ' + item.index + ': ', item.value);\n   *   });\n   *   return paginator.hasNextPage ? paginator.nextPage().then(pageHandler)\n   *                                : null;\n   * };\n   * list.getItems({ from: 0, order: 'asc' })\n   *   .then(pageHandler)\n   *   .catch(function(error) {\n   *     console.error('List getItems() failed', error);\n   *   });\n   */\n\n\n  getItems(args) {\n    var _this24 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee24() {\n      return _regeneratorRuntime.wrap(function _callee24$(_context24) {\n        while (1) switch (_context24.prev = _context24.next) {\n          case 0:\n            _this24.ensureNotClosed();\n\n            return _context24.abrupt(\"return\", _this24.syncListImpl.getItems(args));\n\n          case 2:\n          case \"end\":\n            return _context24.stop();\n        }\n      }, _callee24);\n    }))();\n  }\n  /**\n   * Update the time-to-live of the list.\n   * @param {Number} ttl Specifies the TTL in seconds after which the list is subject to automatic deletion. The value 0 means infinity.\n   * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n   * @public\n   * @example\n   * list.setTtl(3600)\n   *   .then(function() {\n   *     console.log('List setTtl() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('List setTtl() failed', error);\n   *   });\n   */\n\n\n  setTtl(ttl) {\n    var _this25 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee25() {\n      return _regeneratorRuntime.wrap(function _callee25$(_context25) {\n        while (1) switch (_context25.prev = _context25.next) {\n          case 0:\n            _this25.ensureNotClosed();\n\n            return _context25.abrupt(\"return\", _this25.syncListImpl.setTtl(ttl));\n\n          case 2:\n          case \"end\":\n            return _context25.stop();\n        }\n      }, _callee25);\n    }))();\n  }\n  /**\n   * Update the time-to-live of a list item.\n   * @param {Number} index Item index.\n   * @param {Number} ttl Specifies the TTL in seconds after which the list item is subject to automatic deletion. The value 0 means infinity.\n   * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n   * @public\n   * @example\n   * list.setItemTtl(42, 86400)\n   *   .then(function() {\n   *     console.log('List setItemTtl() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('List setItemTtl() failed', error);\n   *   });\n   */\n\n\n  setItemTtl(index, ttl) {\n    var _this26 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee26() {\n      return _regeneratorRuntime.wrap(function _callee26$(_context26) {\n        while (1) switch (_context26.prev = _context26.next) {\n          case 0:\n            _this26.ensureNotClosed();\n\n            return _context26.abrupt(\"return\", _this26.syncListImpl.setItemTtl(index, ttl));\n\n          case 2:\n          case \"end\":\n            return _context26.stop();\n        }\n      }, _callee26);\n    }))();\n  }\n  /**\n   * Delete this list. It will be impossible to restore it.\n   * @return {Promise<void>} A promise that resolves when the list has been deleted.\n   * @public\n   * @example\n   * list.removeList()\n   *   .then(function() {\n   *     console.log('List removeList() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('List removeList() failed', error);\n   *   });\n   */\n\n\n  removeList() {\n    var _this27 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee27() {\n      return _regeneratorRuntime.wrap(function _callee27$(_context27) {\n        while (1) switch (_context27.prev = _context27.next) {\n          case 0:\n            _this27.ensureNotClosed();\n\n            return _context27.abrupt(\"return\", _this27.syncListImpl.removeList());\n\n          case 2:\n          case \"end\":\n            return _context27.stop();\n        }\n      }, _callee27);\n    }))();\n  }\n  /**\n   * Conclude work with the list instance and remove all event listeners attached to it.\n   * Any subsequent operation on this object will be rejected with error.\n   * Other local copies of this list will continue operating and receiving events normally.\n   * @public\n   * @example\n   * list.close();\n   */\n\n\n  close() {\n    super.close();\n    this.syncListImpl.detach(this.listenerUuid);\n  }\n\n}\n\nexports.SyncList = SyncList;\nexports.default = SyncList;\n/**\n * Contains List Item metadata.\n * @typedef {Object} List#ItemMetadata\n * @property {Number} [ttl] Specifies the time-to-live in seconds after which the list item is subject to automatic deletion.\n * The value 0 means infinity.\n */\n\n/**\n * Applies a transformation to the item value. May be called multiple times on the\n * same datum in case of collisions with remote code.\n * @callback List~Mutator\n * @param {Object} currentValue The current value of the item in the cloud.\n * @return {Object} The desired new value for the item or <code>null</code> to gracefully cancel the mutation.\n */\n\n/**\n * Fired when a new item appears in the list, whether its creator was local or remote.\n * @event List#itemAdded\n * @param {Object} args Arguments provided with the event.\n * @param {ListItem} args.item Added item.\n * @param {Boolean} args.isLocal Equals 'true' if item was added by local actor, 'false' otherwise.\n * @example\n * list.on('itemAdded', function(args) {\n *   console.log('List item ' + args.item.index + ' was added');\n *   console.log('args.item.value:', args.item.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n\n/**\n * Fired when a list item is updated (not added or removed, but changed), whether the updater was local or remote.\n * @event List#itemUpdated\n * @param {Object} args Arguments provided with the event.\n * @param {ListItem} args.item Updated item.\n * @param {Boolean} args.isLocal Equals 'true' if item was updated by local actor, 'false' otherwise.\n * @example\n * list.on('itemUpdated', function(args) {\n *   console.log('List item ' + args.item.index + ' was updated');\n *   console.log('args.item.value:', args.item.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n\n/**\n * Fired when a list item is removed, whether the remover was local or remote.\n * @event List#itemRemoved\n * @param {Object} args Arguments provided with the event.\n * @param {Number} args.index The index of the removed item.\n * @param {Boolean} args.isLocal Equals 'true' if item was removed by local actor, 'false' otherwise.\n * @param {Object} args.value In case item was removed by a remote actor, contains a snapshot of item data before removal.\n * @example\n * list.on('itemRemoved', function(args) {\n *   console.log('List item ' + args.index + ' was removed');\n *   console.log('args.value:', args.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n\n/**\n * Fired when a list is deleted entirely, by any actor local or remote.\n * @event List#removed\n * @param {Object} args Arguments provided with the event.\n * @param {Boolean} args.isLocal Equals 'true' if list was removed by local actor, 'false' otherwise.\n * @example\n * list.on('removed', function(args) {\n *   console.log('List ' + list.sid + ' was removed');\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */","map":{"version":3,"sources":["C:/Users/khouloud/Documents/PI/MERN_Stack_PI/node_modules/twilio-sync/lib/synclist.js"],"names":["Object","defineProperty","exports","value","sanitize_1","require","uri_1","syncerror_1","logger_1","entity_1","listitem_1","paginator_1","cache_1","mergingqueue_1","closeable_1","SyncListImpl","SyncEntity","constructor","services","descriptor","removalHandler","updateRequestReducer","acc","input","ttl","updateMergingQueue","NamespacedMergingQueue","cache","Cache","date_updated","Date","uri","url","revision","lastEventId","last_event_id","links","dateExpires","date_expires","type","indexName","undefined","queryString","sid","uniqueName","unique_name","dateUpdated","_addOrUpdateItemOnServer","data","ifMatch","requestBody","network","post","response","body","push","itemMetadata","validateOptionalTtl","items","item","index","Number","_handleItemMutated","get","set","itemMetadataUpdates","squashAndAdd","_updateItemUnconditionally","existingItem","itemDescriptor","_updateItemWithIfMatch","mutatorFunction","deepClone","status","_getItemFromServer","mutate","mutator","add","update","obj","remote","assign","remove","delete","_handleItemRemoved","cachedItem","queryItems","result","length","SyncError","arg","UriBuilder","queryParam","from","limit","pageToken","order","build","map","el","itemInCache","store","ListItem","meta","Paginator","previous_token","next_token","getItems","args","validatePageSize","pageSize","getContext","context","_updateContextIfRequired","setTtl","validateMandatoryTtl","onRemoved","setItemTtl","updateDateExpires","removeList","locally","_unsubscribe","broadcastEventToListeners","isLocal","shouldIgnoreEvent","key","eventId","isKnown","_update","isStrictlyOrdered","itemIndex","item_index","date_created","item_url","id","item_revision","item_data","_handleContextUpdate","context_data","_advanceLastEventId","list_revision","_updateRootDateUpdated","getTime","storage","added","default","trace","emitItemMutationEvent","eventName","oldData","contextEventId","SyncList","syncListImpl","attach","ensureNotClosed","close","detach","listenerUuid"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst sanitize_1 = require(\"./utils/sanitize\");\nconst uri_1 = require(\"./utils/uri\");\nconst syncerror_1 = require(\"./utils/syncerror\");\nconst logger_1 = require(\"./utils/logger\");\nconst entity_1 = require(\"./entity\");\nconst listitem_1 = require(\"./listitem\");\nconst paginator_1 = require(\"./paginator\");\nconst cache_1 = require(\"./cache\");\nconst mergingqueue_1 = require(\"./mergingqueue\");\nconst closeable_1 = require(\"./closeable\");\nclass SyncListImpl extends entity_1.SyncEntity {\n    /**\n     * @private\n     */\n    constructor(services, descriptor, removalHandler) {\n        super(services, removalHandler);\n        const updateRequestReducer = (acc, input) => (typeof input.ttl === 'number') ? { ttl: input.ttl }\n            : acc;\n        this.updateMergingQueue = new mergingqueue_1.NamespacedMergingQueue(updateRequestReducer);\n        this.cache = new cache_1.Cache();\n        this.descriptor = descriptor;\n        this.descriptor.date_updated = new Date(this.descriptor.date_updated);\n    }\n    // private props\n    get uri() {\n        return this.descriptor.url;\n    }\n    get revision() {\n        return this.descriptor.revision;\n    }\n    get lastEventId() {\n        return this.descriptor.last_event_id;\n    }\n    get links() {\n        return this.descriptor.links;\n    }\n    get dateExpires() {\n        return this.descriptor.date_expires;\n    }\n    static get type() {\n        return 'list';\n    }\n    get type() {\n        return 'list';\n    }\n    // below properties are specific to Insights only\n    get indexName() {\n        return undefined;\n    }\n    get queryString() {\n        return undefined;\n    }\n    // public props, documented along with class description\n    get sid() {\n        return this.descriptor.sid;\n    }\n    get uniqueName() {\n        return this.descriptor.unique_name || null;\n    }\n    get dateUpdated() {\n        return this.descriptor.date_updated;\n    }\n    async _addOrUpdateItemOnServer(url, data, ifMatch, ttl) {\n        const requestBody = { data };\n        if (ttl !== undefined) {\n            requestBody.ttl = ttl;\n        }\n        const response = await this.services.network.post(url, requestBody, ifMatch);\n        response.body.data = data;\n        response.body.date_updated = new Date(response.body.date_updated);\n        return response.body;\n    }\n    async push(value, itemMetadata) {\n        let ttl = (itemMetadata || {}).ttl;\n        sanitize_1.validateOptionalTtl(ttl);\n        let item = await this._addOrUpdateItemOnServer(this.links.items, value, undefined, ttl);\n        let index = Number(item.index);\n        this._handleItemMutated(index, item.url, item.last_event_id, item.revision, value, item.date_updated, item.date_expires, true, false);\n        return this.cache.get(index);\n    }\n    async set(index, value, itemMetadataUpdates) {\n        const input = itemMetadataUpdates || {};\n        sanitize_1.validateOptionalTtl(input.ttl);\n        return this.updateMergingQueue.squashAndAdd(index, input, (input) => this._updateItemUnconditionally(index, value, input.ttl));\n    }\n    async _updateItemUnconditionally(index, data, ttl) {\n        let existingItem = await this.get(index);\n        const itemDescriptor = await this._addOrUpdateItemOnServer(existingItem.uri, data, undefined, ttl);\n        this._handleItemMutated(index, itemDescriptor.url, itemDescriptor.last_event_id, itemDescriptor.revision, itemDescriptor.data, itemDescriptor.date_updated, itemDescriptor.date_expires, false, false);\n        return this.cache.get(index);\n    }\n    async _updateItemWithIfMatch(index, mutatorFunction, ttl) {\n        const existingItem = await this.get(index);\n        const data = mutatorFunction(sanitize_1.deepClone(existingItem.value));\n        if (data) {\n            const ifMatch = existingItem.revision;\n            try {\n                const itemDescriptor = await this._addOrUpdateItemOnServer(existingItem.uri, data, ifMatch, ttl);\n                this._handleItemMutated(index, itemDescriptor.url, itemDescriptor.last_event_id, itemDescriptor.revision, itemDescriptor.data, itemDescriptor.date_updated, itemDescriptor.date_expires, false, false);\n                return this.cache.get(index);\n            }\n            catch (error) {\n                if (error.status === 412) {\n                    await this._getItemFromServer(index);\n                    return this._updateItemWithIfMatch(index, mutatorFunction, ttl);\n                }\n                else {\n                    throw error;\n                }\n            }\n        }\n        else {\n            return existingItem;\n        }\n    }\n    async mutate(index, mutator, itemMetadataUpdates) {\n        const input = itemMetadataUpdates || {};\n        sanitize_1.validateOptionalTtl(input.ttl);\n        return this.updateMergingQueue.add(index, input, (input) => this._updateItemWithIfMatch(index, mutator, input.ttl));\n    }\n    async update(index, obj, itemMetadataUpdates) {\n        return this.mutate(index, remote => Object.assign(remote, obj), itemMetadataUpdates);\n    }\n    async remove(index) {\n        let item = await this.get(index);\n        let response = await this.services.network.delete(item.uri);\n        this._handleItemRemoved(index, response.body.last_event_id, undefined, new Date(response.body.date_updated), false);\n    }\n    async get(index) {\n        let cachedItem = this.cache.get(index);\n        if (cachedItem) {\n            return cachedItem;\n        }\n        else {\n            return this._getItemFromServer(index);\n        }\n    }\n    async _getItemFromServer(index) {\n        let result = await this.queryItems({ index });\n        if (result.items.length < 1) {\n            throw new syncerror_1.SyncError(`No item with index ${index} found`, 404, 54151);\n        }\n        else {\n            return result.items[0];\n        }\n    }\n    /**\n     * Query items from the List\n     * @private\n     */\n    async queryItems(arg) {\n        arg = arg || {};\n        const url = new uri_1.UriBuilder(this.links.items)\n            .queryParam('From', arg.from)\n            .queryParam('PageSize', arg.limit)\n            .queryParam('Index', arg.index)\n            .queryParam('PageToken', arg.pageToken)\n            .queryParam('Order', arg.order)\n            .build();\n        let response = await this.services.network.get(url);\n        let items = response.body.items.map(el => {\n            el.date_updated = new Date(el.date_updated);\n            let itemInCache = this.cache.get(el.index);\n            if (itemInCache) {\n                this._handleItemMutated(el.index, el.url, el.last_event_id, el.revision, el.data, el.date_updated, el.date_expires, false, true);\n            }\n            else {\n                this.cache.store(Number(el.index), new listitem_1.ListItem({\n                    index: Number(el.index),\n                    uri: el.url,\n                    revision: el.revision,\n                    lastEventId: el.last_event_id,\n                    dateUpdated: el.date_updated,\n                    dateExpires: el.date_expires,\n                    value: el.data\n                }), el.last_event_id);\n            }\n            return this.cache.get(el.index);\n        });\n        let meta = response.body.meta;\n        return new paginator_1.Paginator(items, pageToken => this.queryItems({ pageToken }), meta.previous_token, meta.next_token);\n    }\n    async getItems(args) {\n        args = args || {};\n        sanitize_1.validatePageSize(args.pageSize);\n        args.limit = args.pageSize || args.limit || 50;\n        args.order = args.order || 'asc';\n        return this.queryItems(args);\n    }\n    /**\n     * @return {Promise<Object>} Context of List\n     * @private\n     */\n    async getContext() {\n        if (!this.context) {\n            let response = await this.services.network.get(this.links.context);\n            // store fetched context if we have't received any newer update\n            this._updateContextIfRequired(response.body.data, response.body.last_event_id);\n        }\n        return this.context;\n    }\n    async setTtl(ttl) {\n        sanitize_1.validateMandatoryTtl(ttl);\n        try {\n            const requestBody = { ttl };\n            const response = await this.services.network.post(this.uri, requestBody);\n            this.descriptor.date_expires = response.body.date_expires;\n        }\n        catch (error) {\n            if (error.status === 404) {\n                this.onRemoved(false);\n            }\n            throw error;\n        }\n    }\n    async setItemTtl(index, ttl) {\n        sanitize_1.validateMandatoryTtl(ttl);\n        let existingItem = await this.get(index);\n        const requestBody = { ttl };\n        const response = await this.services.network.post(existingItem.uri, requestBody);\n        existingItem.updateDateExpires(response.body.date_expires);\n    }\n    async removeList() {\n        await this.services.network.delete(this.uri);\n        this.onRemoved(true);\n    }\n    onRemoved(locally) {\n        this._unsubscribe();\n        this.removalHandler(this.type, this.sid, this.uniqueName);\n        this.broadcastEventToListeners('removed', { isLocal: locally });\n    }\n    shouldIgnoreEvent(key, eventId) {\n        return this.cache.isKnown(key, eventId);\n    }\n    /**\n     * Handle update, which came from the server.\n     * @private\n     */\n    _update(update, isStrictlyOrdered) {\n        const itemIndex = Number(update.item_index);\n        update.date_created = new Date(update.date_created);\n        switch (update.type) {\n            case 'list_item_added':\n            case 'list_item_updated':\n                {\n                    this._handleItemMutated(itemIndex, update.item_url, update.id, update.item_revision, update.item_data, update.date_created, undefined, // orchestration does not include date_expires\n                    update.type === 'list_item_added', true);\n                }\n                break;\n            case 'list_item_removed':\n                {\n                    this._handleItemRemoved(itemIndex, update.id, update.item_data, update.date_created, true);\n                }\n                break;\n            case 'list_context_updated':\n                {\n                    this._handleContextUpdate(update.context_data, update.id, update.date_created);\n                }\n                break;\n            case 'list_removed':\n                {\n                    this.onRemoved(false);\n                }\n                break;\n        }\n        if (isStrictlyOrdered) {\n            this._advanceLastEventId(update.id, update.list_revision);\n        }\n    }\n    _advanceLastEventId(eventId, revision) {\n        if (this.lastEventId < eventId) {\n            this.descriptor.last_event_id = eventId;\n            if (revision) {\n                this.descriptor.revision = revision;\n            }\n        }\n    }\n    _updateRootDateUpdated(dateUpdated) {\n        if (!this.descriptor.date_updated || dateUpdated.getTime() > this.descriptor.date_updated.getTime()) {\n            this.descriptor.date_updated = dateUpdated;\n            this.services.storage.update(this.type, this.sid, this.uniqueName, { date_updated: dateUpdated });\n        }\n    }\n    _handleItemMutated(index, uri, lastEventId, revision, value, dateUpdated, dateExpires, added, remote) {\n        if (this.shouldIgnoreEvent(index, lastEventId)) {\n            logger_1.default.trace('Item ', index, ' update skipped, current:', this.lastEventId, ', remote:', lastEventId);\n            return;\n        }\n        else {\n            this._updateRootDateUpdated(dateUpdated);\n            let item = this.cache.get(index);\n            if (!item) {\n                let item = new listitem_1.ListItem({ index, uri, lastEventId, revision, value, dateUpdated, dateExpires });\n                this.cache.store(index, item, lastEventId);\n                this.emitItemMutationEvent(item, remote, added);\n            }\n            else {\n                item.update(lastEventId, revision, value, dateUpdated);\n                this.cache.store(index, item, lastEventId);\n                if (dateExpires !== undefined) {\n                    item.updateDateExpires(dateExpires);\n                }\n                this.emitItemMutationEvent(item, remote, false);\n            }\n        }\n    }\n    /**\n     * @private\n     */\n    emitItemMutationEvent(item, remote, added) {\n        let eventName = added ? 'itemAdded' : 'itemUpdated';\n        this.broadcastEventToListeners(eventName, { item: item, isLocal: !remote });\n    }\n    /**\n     * @private\n     */\n    _handleItemRemoved(index, eventId, oldData, dateUpdated, remote) {\n        this._updateRootDateUpdated(dateUpdated);\n        this.cache.delete(index, eventId);\n        this.broadcastEventToListeners('itemRemoved', { index: index, isLocal: !remote, value: oldData });\n    }\n    /**\n     * @private\n     */\n    _handleContextUpdate(data, eventId, dateUpdated) {\n        this._updateRootDateUpdated(dateUpdated);\n        if (this._updateContextIfRequired(data, eventId)) {\n            this.broadcastEventToListeners('contextUpdated', { context: data, isLocal: false });\n        }\n    }\n    /**\n     * @private\n     */\n    _updateContextIfRequired(data, eventId) {\n        if (!this.contextEventId || eventId > this.contextEventId) {\n            this.context = data;\n            this.contextEventId = eventId;\n            return true;\n        }\n        else {\n            logger_1.default.trace('Context update skipped, current:', this.lastEventId, ', remote:', eventId);\n            return false;\n        }\n    }\n}\nexports.SyncListImpl = SyncListImpl;\n/**\n * @class\n * @alias List\n * @classdesc Represents a Sync List, which stores an ordered list of values.\n * Use the {@link Client#list} method to obtain a reference to a Sync List.\n * @property {String} sid - List unique id, immutable identifier assigned by the system.\n * @property {String} [uniqueName=null] - List unique name, immutable identifier that can be assigned to list during creation.\n * @property {Date} dateUpdated Date when the List was last updated.\n *\n * @fires List#removed\n * @fires List#itemAdded\n * @fires List#itemRemoved\n * @fires List#itemUpdated\n */\nclass SyncList extends closeable_1.default {\n    constructor(syncListImpl) {\n        super();\n        this.syncListImpl = syncListImpl;\n        this.syncListImpl.attach(this);\n    }\n    // private props\n    get uri() {\n        return this.syncListImpl.uri;\n    }\n    get revision() {\n        return this.syncListImpl.revision;\n    }\n    get lastEventId() {\n        return this.syncListImpl.lastEventId;\n    }\n    get links() {\n        return this.syncListImpl.links;\n    }\n    get dateExpires() {\n        return this.syncListImpl.dateExpires;\n    }\n    static get type() {\n        return SyncListImpl.type;\n    }\n    get type() {\n        return SyncListImpl.type;\n    }\n    // public props, documented along with class description\n    get sid() {\n        return this.syncListImpl.sid;\n    }\n    get uniqueName() {\n        return this.syncListImpl.uniqueName;\n    }\n    get dateUpdated() {\n        return this.syncListImpl.dateUpdated;\n    }\n    /**\n     * Add a new item to the list.\n     * @param {Object} value Value to be added.\n     * @param {List#ItemMetadata} [itemMetadata] Item metadata.\n     * @returns {Promise<ListItem>} A newly added item.\n     * @public\n     * @example\n     * list.push({ name: 'John Smith' }, { ttl: 86400 })\n     *   .then(function(item) {\n     *     console.log('List Item push() successful, item index:' + item.index + ', value: ', item.value)\n     *   })\n     *   .catch(function(error) {\n     *     console.error('List Item push() failed', error);\n     *   });\n     */\n    async push(value, itemMetadata) {\n        this.ensureNotClosed();\n        return this.syncListImpl.push(value, itemMetadata);\n    }\n    /**\n     * Assign new value to an existing item, given its index.\n     * @param {Number} index Index of the item to be updated.\n     * @param {Object} value New value to be assigned to an item.\n     * @param {List#ItemMetadata} [itemMetadataUpdates] New item metadata.\n     * @returns {Promise<ListItem>} A promise with updated item containing latest known value.\n     * The promise will be rejected if the item does not exist.\n     * @public\n     * @example\n     * list.set(42, { name: 'John Smith' }, { ttl: 86400 })\n     *   .then(function(item) {\n     *     console.log('List Item set() successful, item value:', item.value)\n     *   })\n     *   .catch(function(error) {\n     *     console.error('List Item set() failed', error);\n     *   });\n     */\n    async set(index, value, itemMetadataUpdates) {\n        this.ensureNotClosed();\n        return this.syncListImpl.set(index, value, itemMetadataUpdates);\n    }\n    /**\n     * Modify an existing item by applying a mutation function to it.\n     * @param {Number} index Index of an item to be changed.\n     * @param {List~Mutator} mutator A function that outputs a new value based on the existing value.\n     * @param {List#ItemMetadata} [itemMetadataUpdates] New item metadata.\n     * @returns {Promise<ListItem>} Resolves with the most recent item state, the output of a successful\n     *    mutation or a state that prompted graceful cancellation (mutator returned <code>null</code>). This promise\n     *    will be rejected if the indicated item does not already exist.\n     * @public\n     * @example\n     * var mutatorFunction = function(currentValue) {\n     *     currentValue.viewCount = (currentValue.viewCount || 0) + 1;\n     *     return currentValue;\n     * };\n     * list.mutate(42, mutatorFunction, { ttl: 86400 })\n     *   .then(function(item) {\n     *     console.log('List Item mutate() successful, new value:', item.value)\n     *   })\n     *   .catch(function(error) {\n     *     console.error('List Item mutate() failed', error);\n     *   });\n     */\n    async mutate(index, mutator, itemMetadataUpdates) {\n        this.ensureNotClosed();\n        return this.syncListImpl.mutate(index, mutator, itemMetadataUpdates);\n    }\n    /**\n     * Modify an existing item by appending new fields (or overwriting existing ones) with the values from Object.\n     * This is equivalent to\n     * <pre>\n     * list.mutate(42, function(currentValue) {\n     *   return Object.assign(currentValue, obj));\n     * });\n     * </pre>\n     * @param {Number} index Index of an item to be changed.\n     * @param {Object} obj Set of fields to update.\n     * @param {List#ItemMetadata} [itemMetadataUpdates] New item metadata.\n     * @returns {Promise<ListItem>} A promise with a modified item containing latest known value.\n     * The promise will be rejected if an item was not found.\n     * @public\n     * @example\n     * // Say, the List Item (index: 42) value is { name: 'John Smith' }\n     * list.update(42, { age: 34 }, { ttl: 86400 })\n     *   .then(function(item) {\n     *     // Now the List Item value is { name: 'John Smith', age: 34 }\n     *     console.log('List Item update() successful, new value:', item.value);\n     *   })\n     *   .catch(function(error) {\n     *     console.error('List Item update() failed', error);\n     *   });\n     */\n    async update(index, obj, itemMetadataUpdates) {\n        this.ensureNotClosed();\n        return this.syncListImpl.update(index, obj, itemMetadataUpdates);\n    }\n    /**\n     * Delete an item, given its index.\n     * @param {Number} index Index of an item to be removed.\n     * @returns {Promise<void>} A promise to remove an item.\n     * A promise will be rejected if an item was not found.\n     * @public\n     * @example\n     * list.remove(42)\n     *   .then(function() {\n     *     console.log('List Item remove() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('List Item remove() failed', error);\n     *   });\n     */\n    async remove(index) {\n        this.ensureNotClosed();\n        return this.syncListImpl.remove(index);\n    }\n    /**\n     * Retrieve an item by List index.\n     * @param {Number} index Item index in a List.\n     * @returns {Promise<ListItem>} A promise with an item containing latest known value.\n     * A promise will be rejected if an item was not found.\n     * @public\n     * @example\n     * list.get(42)\n     *   .then(function(item) {\n     *     console.log('List Item get() successful, item value:', item.value)\n     *   })\n     *   .catch(function(error) {\n     *     console.error('List Item get() failed', error);\n     *   });\n     */\n    async get(index) {\n        this.ensureNotClosed();\n        return this.syncListImpl.get(index);\n    }\n    /**\n     * Retrieve a List context\n     * @returns {Promise<Object>} A promise with a List's context\n     * @ignore\n     */\n    async getContext() {\n        this.ensureNotClosed();\n        return this.syncListImpl.getContext();\n    }\n    /**\n     * Query a list of items from collection.\n     * @param {Object} [args] Arguments for query\n     * @param {Number} [args.from] Item index, which should be used as the offset.\n     * If undefined, starts from the beginning or end depending on args.order.\n     * @param {Number} [args.pageSize=50] Results page size.\n     * @param {'asc'|'desc'} [args.order='asc'] Numeric order of results.\n     * @returns {Promise<Paginator<ListItem>>}\n     * @public\n     * @example\n     * var pageHandler = function(paginator) {\n     *   paginator.items.forEach(function(item) {\n     *     console.log('Item ' + item.index + ': ', item.value);\n     *   });\n     *   return paginator.hasNextPage ? paginator.nextPage().then(pageHandler)\n     *                                : null;\n     * };\n     * list.getItems({ from: 0, order: 'asc' })\n     *   .then(pageHandler)\n     *   .catch(function(error) {\n     *     console.error('List getItems() failed', error);\n     *   });\n     */\n    async getItems(args) {\n        this.ensureNotClosed();\n        return this.syncListImpl.getItems(args);\n    }\n    /**\n     * Update the time-to-live of the list.\n     * @param {Number} ttl Specifies the TTL in seconds after which the list is subject to automatic deletion. The value 0 means infinity.\n     * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n     * @public\n     * @example\n     * list.setTtl(3600)\n     *   .then(function() {\n     *     console.log('List setTtl() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('List setTtl() failed', error);\n     *   });\n     */\n    async setTtl(ttl) {\n        this.ensureNotClosed();\n        return this.syncListImpl.setTtl(ttl);\n    }\n    /**\n     * Update the time-to-live of a list item.\n     * @param {Number} index Item index.\n     * @param {Number} ttl Specifies the TTL in seconds after which the list item is subject to automatic deletion. The value 0 means infinity.\n     * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n     * @public\n     * @example\n     * list.setItemTtl(42, 86400)\n     *   .then(function() {\n     *     console.log('List setItemTtl() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('List setItemTtl() failed', error);\n     *   });\n     */\n    async setItemTtl(index, ttl) {\n        this.ensureNotClosed();\n        return this.syncListImpl.setItemTtl(index, ttl);\n    }\n    /**\n     * Delete this list. It will be impossible to restore it.\n     * @return {Promise<void>} A promise that resolves when the list has been deleted.\n     * @public\n     * @example\n     * list.removeList()\n     *   .then(function() {\n     *     console.log('List removeList() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('List removeList() failed', error);\n     *   });\n     */\n    async removeList() {\n        this.ensureNotClosed();\n        return this.syncListImpl.removeList();\n    }\n    /**\n     * Conclude work with the list instance and remove all event listeners attached to it.\n     * Any subsequent operation on this object will be rejected with error.\n     * Other local copies of this list will continue operating and receiving events normally.\n     * @public\n     * @example\n     * list.close();\n     */\n    close() {\n        super.close();\n        this.syncListImpl.detach(this.listenerUuid);\n    }\n}\nexports.SyncList = SyncList;\nexports.default = SyncList;\n/**\n * Contains List Item metadata.\n * @typedef {Object} List#ItemMetadata\n * @property {Number} [ttl] Specifies the time-to-live in seconds after which the list item is subject to automatic deletion.\n * The value 0 means infinity.\n */\n/**\n * Applies a transformation to the item value. May be called multiple times on the\n * same datum in case of collisions with remote code.\n * @callback List~Mutator\n * @param {Object} currentValue The current value of the item in the cloud.\n * @return {Object} The desired new value for the item or <code>null</code> to gracefully cancel the mutation.\n */\n/**\n * Fired when a new item appears in the list, whether its creator was local or remote.\n * @event List#itemAdded\n * @param {Object} args Arguments provided with the event.\n * @param {ListItem} args.item Added item.\n * @param {Boolean} args.isLocal Equals 'true' if item was added by local actor, 'false' otherwise.\n * @example\n * list.on('itemAdded', function(args) {\n *   console.log('List item ' + args.item.index + ' was added');\n *   console.log('args.item.value:', args.item.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n/**\n * Fired when a list item is updated (not added or removed, but changed), whether the updater was local or remote.\n * @event List#itemUpdated\n * @param {Object} args Arguments provided with the event.\n * @param {ListItem} args.item Updated item.\n * @param {Boolean} args.isLocal Equals 'true' if item was updated by local actor, 'false' otherwise.\n * @example\n * list.on('itemUpdated', function(args) {\n *   console.log('List item ' + args.item.index + ' was updated');\n *   console.log('args.item.value:', args.item.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n/**\n * Fired when a list item is removed, whether the remover was local or remote.\n * @event List#itemRemoved\n * @param {Object} args Arguments provided with the event.\n * @param {Number} args.index The index of the removed item.\n * @param {Boolean} args.isLocal Equals 'true' if item was removed by local actor, 'false' otherwise.\n * @param {Object} args.value In case item was removed by a remote actor, contains a snapshot of item data before removal.\n * @example\n * list.on('itemRemoved', function(args) {\n *   console.log('List item ' + args.index + ' was removed');\n *   console.log('args.value:', args.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n/**\n * Fired when a list is deleted entirely, by any actor local or remote.\n * @event List#removed\n * @param {Object} args Arguments provided with the event.\n * @param {Boolean} args.isLocal Equals 'true' if list was removed by local actor, 'false' otherwise.\n * @example\n * list.on('removed', function(args) {\n *   console.log('List ' + list.sid + ' was removed');\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n"]},"metadata":{},"sourceType":"script"}