{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\khouloud\\\\Documents\\\\PI\\\\MERN_Stack_PI\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\khouloud\\\\Documents\\\\PI\\\\MERN_Stack_PI\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nvar _jsxFileName = \"C:\\\\Users\\\\khouloud\\\\Documents\\\\PI\\\\MERN_Stack_PI\\\\src\\\\views\\\\driver\\\\DirectionRenderComponent.js\";\nimport React, { Component } from \"react\";\nimport { convertLatLngToObj } from \"../../utility/helper\";\n\nconst _require = require(\"react-google-maps\"),\n      Marker = _require.Marker,\n      DirectionsRenderer = _require.DirectionsRenderer;\n\nclass DirectionRenderComponent extends Component {\n  constructor(...args) {\n    super(...args);\n    this.state = {\n      directions: null,\n      wayPoints: null,\n      currentLocation: null\n    };\n    this.delayFactor = 0;\n\n    this.setCurrentLocation = () => {\n      let count = 0;\n      let refreshIntervalId = setInterval(() => {\n        const locations = this.state.wayPoints;\n\n        if (locations) {\n          if (count <= locations.length - 1) {\n            const currentLocation = convertLatLngToObj(locations[count].lat(), locations[count].lng());\n            this.setState({\n              currentLocation\n            });\n            const wayPts = [];\n            wayPts.push(currentLocation);\n            const startLoc = this.props.from.lat + \", \" + this.props.from.lng;\n            const destinationLoc = this.props.to.lat + \", \" + this.props.to.lng;\n            this.delayFactor = 0;\n            this.getDirections(startLoc, destinationLoc, wayPts);\n            count++;\n          } else {\n            clearInterval(refreshIntervalId);\n          }\n        }\n      }, 1000);\n    };\n  }\n\n  componentDidMount() {\n    const startLoc = this.props.from.lat + \", \" + this.props.from.lng;\n    const destinationLoc = this.props.to.lat + \", \" + this.props.to.lng;\n    this.getDirections(startLoc, destinationLoc);\n    this.setCurrentLocation();\n  }\n\n  getDirections(startLoc, destinationLoc, wayPoints = []) {\n    var _this = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var waypts, directionService;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            waypts = [];\n\n            if (wayPoints.length > 0) {\n              waypts.push({\n                location: new window.google.maps.LatLng(wayPoints[0].lat, wayPoints[0].lng),\n                stopover: true\n              });\n            }\n\n            directionService = new window.google.maps.DirectionsService();\n            directionService.route({\n              origin: startLoc,\n              destination: destinationLoc,\n              waypoints: waypts,\n              optimizeWaypoints: true,\n              travelMode: window.google.maps.TravelMode.DRIVING\n            }, (result, status) => {\n              // console.log(\"status\", status);\n              if (status === window.google.maps.DirectionsStatus.OK) {\n                _this.setState({\n                  directions: result,\n                  wayPoints: result.routes[0].overview_path.filter((elem, index) => {\n                    return index % 30 === 0;\n                  })\n                });\n              } else if (status === window.google.maps.DirectionsStatus.OVER_QUERY_LIMIT) {\n                _this.delayFactor += 0.2; // if (this.delayFactor <= 10) this.delayFactor = 0.2;\n\n                setTimeout(() => {\n                  _this.getDirections(startLoc, destinationLoc, wayPoints);\n                }, _this.delayFactor * 200);\n              } else {\n                console.error(\"error fetching directions \".concat(result));\n              }\n            });\n\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }))();\n  }\n\n  render() {\n    let originMarker = null;\n    let destinationMarker = null;\n\n    if (this.state.directions && this.props.index) {\n      originMarker = React.createElement(Marker, {\n        defaultLabel: this.props.index.toString(),\n        defaultIcon: null,\n        position: {\n          lat: parseFloat(this.props.from.lat),\n          lng: parseFloat(this.props.from.lng)\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 94\n        },\n        __self: this\n      });\n      destinationMarker = React.createElement(Marker, {\n        label: this.props.index.toString(),\n        defaultIcon: null,\n        position: {\n          lat: parseFloat(this.props.to.lat),\n          lng: parseFloat(this.props.to.lng)\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 104\n        },\n        __self: this\n      });\n    }\n\n    return React.createElement(\"div\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 115\n      },\n      __self: this\n    }, originMarker, destinationMarker, this.state.currentLocation && React.createElement(Marker, {\n      label: this.props.index.toString(),\n      position: {\n        lat: this.state.currentLocation.lat,\n        lng: this.state.currentLocation.lng\n      },\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 119\n      },\n      __self: this\n    }), this.state.directions && React.createElement(DirectionsRenderer, {\n      directions: this.state.directions,\n      options: {\n        polylineOptions: {\n          storkeColor: this.props.storkeColor,\n          strokeOpacity: 0.4,\n          strokeWeight: 4\n        },\n        preserveViewport: true,\n        suppressMarkers: true,\n        icon: {\n          scale: 3\n        }\n      },\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 128\n      },\n      __self: this\n    }));\n  }\n\n}\n\nexport default DirectionRenderComponent;","map":{"version":3,"sources":["C:/Users/khouloud/Documents/PI/MERN_Stack_PI/src/views/driver/DirectionRenderComponent.js"],"names":["React","Component","convertLatLngToObj","require","Marker","DirectionsRenderer","DirectionRenderComponent","state","directions","wayPoints","currentLocation","delayFactor","setCurrentLocation","count","refreshIntervalId","setInterval","locations","length","lat","lng","setState","wayPts","push","startLoc","props","from","destinationLoc","to","getDirections","clearInterval","componentDidMount","waypts","location","window","google","maps","LatLng","stopover","directionService","DirectionsService","route","origin","destination","waypoints","optimizeWaypoints","travelMode","TravelMode","DRIVING","result","status","DirectionsStatus","OK","routes","overview_path","filter","elem","index","OVER_QUERY_LIMIT","setTimeout","console","error","render","originMarker","destinationMarker","toString","parseFloat","polylineOptions","storkeColor","strokeOpacity","strokeWeight","preserveViewport","suppressMarkers","icon","scale"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\r\nimport { convertLatLngToObj } from \"../../utility/helper\";\r\nconst { Marker, DirectionsRenderer } = require(\"react-google-maps\");\r\n\r\nclass DirectionRenderComponent extends Component {\r\n    state = {\r\n        directions: null,\r\n        wayPoints: null,\r\n        currentLocation: null\r\n    };\r\n    delayFactor = 0;\r\n\r\n    componentDidMount() {\r\n        const startLoc = this.props.from.lat + \", \" + this.props.from.lng;\r\n        const destinationLoc = this.props.to.lat + \", \" + this.props.to.lng;\r\n        this.getDirections(startLoc, destinationLoc);\r\n        this.setCurrentLocation();\r\n    }\r\n\r\n    async getDirections(startLoc, destinationLoc, wayPoints = []) {\r\n        const waypts = [];\r\n        if (wayPoints.length > 0) {\r\n            waypts.push({\r\n                location: new window.google.maps.LatLng(\r\n                    wayPoints[0].lat,\r\n                    wayPoints[0].lng\r\n                ),\r\n                stopover: true\r\n            });\r\n        }\r\n        const directionService = new window.google.maps.DirectionsService();\r\n        directionService.route(\r\n            {\r\n                origin: startLoc,\r\n                destination: destinationLoc,\r\n                waypoints: waypts,\r\n                optimizeWaypoints: true,\r\n                travelMode: window.google.maps.TravelMode.DRIVING\r\n            },\r\n            (result, status) => {\r\n                // console.log(\"status\", status);\r\n                if (status === window.google.maps.DirectionsStatus.OK) {\r\n                    this.setState({\r\n                        directions: result,\r\n                        wayPoints: result.routes[0].overview_path.filter((elem, index) => {\r\n                            return index % 30 === 0;\r\n                        })\r\n                    });\r\n                } else if (\r\n                    status === window.google.maps.DirectionsStatus.OVER_QUERY_LIMIT\r\n                ) {\r\n                    this.delayFactor += 0.2;\r\n                    // if (this.delayFactor <= 10) this.delayFactor = 0.2;\r\n                    setTimeout(() => {\r\n                        this.getDirections(startLoc, destinationLoc, wayPoints);\r\n                    }, this.delayFactor * 200);\r\n                } else {\r\n                    console.error(`error fetching directions ${result}`);\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    setCurrentLocation = () => {\r\n        let count = 0;\r\n        let refreshIntervalId = setInterval(() => {\r\n            const locations = this.state.wayPoints;\r\n            if (locations) {\r\n                if (count <= locations.length - 1) {\r\n                    const currentLocation = convertLatLngToObj(\r\n                        locations[count].lat(),\r\n                        locations[count].lng()\r\n                    );\r\n                    this.setState({ currentLocation });\r\n\r\n                    const wayPts = [];\r\n                    wayPts.push(currentLocation);\r\n                    const startLoc = this.props.from.lat + \", \" + this.props.from.lng;\r\n                    const destinationLoc = this.props.to.lat + \", \" + this.props.to.lng;\r\n                    this.delayFactor = 0;\r\n                    this.getDirections(startLoc, destinationLoc, wayPts);\r\n                    count++;\r\n                } else {\r\n                    clearInterval(refreshIntervalId);\r\n                }\r\n            }\r\n        }, 1000);\r\n    };\r\n    render() {\r\n        let originMarker = null;\r\n        let destinationMarker = null;\r\n        if (this.state.directions && this.props.index) {\r\n            originMarker = (\r\n                <Marker\r\n                    defaultLabel={this.props.index.toString()}\r\n                    defaultIcon={null}\r\n                    position={{\r\n                        lat: parseFloat(this.props.from.lat),\r\n                        lng: parseFloat(this.props.from.lng)\r\n                    }}\r\n                />\r\n            );\r\n            destinationMarker = (\r\n                <Marker\r\n                    label={this.props.index.toString()}\r\n                    defaultIcon={null}\r\n                    position={{\r\n                        lat: parseFloat(this.props.to.lat),\r\n                        lng: parseFloat(this.props.to.lng)\r\n                    }}\r\n                />\r\n            );\r\n        }\r\n        return (\r\n            <div>\r\n                {originMarker}\r\n                {destinationMarker}\r\n                {this.state.currentLocation && (\r\n                    <Marker\r\n                        label={this.props.index.toString()}\r\n                        position={{\r\n                            lat: this.state.currentLocation.lat,\r\n                            lng: this.state.currentLocation.lng\r\n                        }}\r\n                    />\r\n                )}\r\n                {this.state.directions && (\r\n                    <DirectionsRenderer\r\n                        directions={this.state.directions}\r\n                        options={{\r\n                            polylineOptions: {\r\n                                storkeColor: this.props.storkeColor,\r\n                                strokeOpacity: 0.4,\r\n                                strokeWeight: 4\r\n                            },\r\n                            preserveViewport: true,\r\n                            suppressMarkers: true,\r\n                            icon: { scale: 3 }\r\n                        }}\r\n                    />\r\n                )}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default DirectionRenderComponent;\r\n"]},"metadata":{},"sourceType":"module"}