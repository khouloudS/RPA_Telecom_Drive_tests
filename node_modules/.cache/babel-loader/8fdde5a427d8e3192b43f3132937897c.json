{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\khouloud\\\\Documents\\\\PI\\\\MERN_Stack_PI\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\khouloud\\\\Documents\\\\PI\\\\MERN_Stack_PI\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst logger_1 = require(\"./logger\");\n\nconst uuid_1 = require(\"uuid\");\n\nconst twilsockerror_1 = require(\"./error/twilsockerror\");\n\nconst twilsockreplyerror_1 = require(\"./error/twilsockreplyerror\");\n\nconst parser_1 = require(\"./parser\");\n\nconst Messages = require(\"./protocol/messages\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst REQUEST_TIMEOUT = 30000;\n\nfunction isHttpSuccess(code) {\n  return code >= 200 && code < 300;\n}\n/**\n * Makes sure that body is properly stringified\n */\n\n\nfunction preparePayload(payload) {\n  switch (typeof payload) {\n    case 'undefined':\n      return '';\n\n    case 'object':\n      return JSON.stringify(payload);\n\n    default:\n      return payload;\n  }\n}\n\nclass PacketRequest {}\n\nclass PacketResponse {}\n\nexports.PacketResponse = PacketResponse;\n\nclass PacketInterface {\n  constructor(channel, config) {\n    this.config = config;\n    this.activeRequests = new Map();\n    this.channel = channel;\n    this.channel.on('reply', reply => this.processReply(reply));\n    this.channel.on('disconnected', () => {\n      this.activeRequests.forEach(descriptor => {\n        clearTimeout(descriptor.timeout);\n        descriptor.reject(new twilsockerror_1.TwilsockError('disconnected'));\n      });\n      this.activeRequests.clear();\n    });\n  }\n\n  get isConnected() {\n    return this.channel.isConnected;\n  }\n\n  processReply(reply) {\n    const request = this.activeRequests.get(reply.id);\n\n    if (request) {\n      clearTimeout(request.timeout);\n      this.activeRequests.delete(reply.id);\n\n      if (!isHttpSuccess(reply.status.code)) {\n        request.reject(new twilsockreplyerror_1.TwilsockReplyError('Transport failure: ' + reply.status.status, reply));\n        logger_1.log.trace('message rejected');\n      } else {\n        request.resolve(reply);\n      }\n    }\n  }\n\n  storeRequest(id, resolve, reject) {\n    let requestDescriptor = {\n      resolve: resolve,\n      reject: reject,\n      timeout: setTimeout(() => {\n        logger_1.log.trace('request', id, 'is timed out');\n        reject(new twilsockerror_1.TwilsockError('Twilsock: request timeout: ' + id));\n      }, REQUEST_TIMEOUT)\n    };\n    this.activeRequests.set(id, requestDescriptor);\n  }\n\n  shutdown() {\n    this.activeRequests.forEach(descriptor => {\n      clearTimeout(descriptor.timeout);\n      descriptor.reject(new twilsockerror_1.TwilsockError('Twilsock: request cancelled by user'));\n    });\n    this.activeRequests.clear();\n  }\n\n  sendInit() {\n    var _this = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var metadata, message, response;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            logger_1.log.trace('sendInit');\n            metadata = metadata_1.Metadata.getMetadata(_this.config);\n            message = new Messages.Init(_this.config.token, _this.config.continuationToken, metadata, _this.config.initRegistrations, _this.config.tweaks);\n            _context.next = 5;\n            return _this.sendWithReply(message);\n\n          case 5:\n            response = _context.sent;\n            return _context.abrupt(\"return\", new Messages.InitReply(response.id, response.header.continuation_token, response.header.continuation_token_status, response.header.offline_storage, response.header.init_registrations, response.header.debug_info));\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }))();\n  }\n\n  sendClose() {\n    let message = new Messages.Close();\n    this.send(message);\n  }\n\n  sendWithReply(header, payload) {\n    return new Promise((resolve, reject) => {\n      let id = this.send(header, payload);\n      this.storeRequest(id, resolve, reject);\n    });\n  }\n\n  send(header, payload) {\n    header.id = header.id || \"TM\".concat(uuid_1.v4());\n    let message = parser_1.Parser.createPacket(header, preparePayload(payload));\n\n    try {\n      this.channel.send(message);\n      return header.id;\n    } catch (e) {\n      logger_1.log.debug('failed to send ', header, e);\n      logger_1.log.trace(e.stack);\n      throw e;\n    }\n  }\n\n}\n\nexports.PacketInterface = PacketInterface;","map":{"version":3,"sources":["C:/Users/khouloud/Documents/PI/MERN_Stack_PI/node_modules/twilsock/lib/packetinterface.js"],"names":["Object","defineProperty","exports","value","logger_1","require","uuid_1","twilsockerror_1","twilsockreplyerror_1","parser_1","Messages","metadata_1","REQUEST_TIMEOUT","isHttpSuccess","code","preparePayload","payload","JSON","stringify","PacketRequest","PacketResponse","PacketInterface","constructor","channel","config","activeRequests","Map","on","reply","processReply","forEach","descriptor","clearTimeout","timeout","reject","TwilsockError","clear","isConnected","request","get","id","delete","status","TwilsockReplyError","log","trace","resolve","storeRequest","requestDescriptor","setTimeout","set","shutdown","sendInit","metadata","Metadata","getMetadata","message","Init","token","continuationToken","initRegistrations","tweaks","sendWithReply","response","InitReply","header","continuation_token","continuation_token_status","offline_storage","init_registrations","debug_info","sendClose","Close","send","Promise","v4","Parser","createPacket","e","debug","stack"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst logger_1 = require(\"./logger\");\nconst uuid_1 = require(\"uuid\");\nconst twilsockerror_1 = require(\"./error/twilsockerror\");\nconst twilsockreplyerror_1 = require(\"./error/twilsockreplyerror\");\nconst parser_1 = require(\"./parser\");\nconst Messages = require(\"./protocol/messages\");\nconst metadata_1 = require(\"./metadata\");\nconst REQUEST_TIMEOUT = 30000;\nfunction isHttpSuccess(code) {\n    return (code >= 200 && code < 300);\n}\n/**\n * Makes sure that body is properly stringified\n */\nfunction preparePayload(payload) {\n    switch (typeof payload) {\n        case 'undefined':\n            return '';\n        case 'object':\n            return JSON.stringify(payload);\n        default:\n            return payload;\n    }\n}\nclass PacketRequest {\n}\nclass PacketResponse {\n}\nexports.PacketResponse = PacketResponse;\nclass PacketInterface {\n    constructor(channel, config) {\n        this.config = config;\n        this.activeRequests = new Map();\n        this.channel = channel;\n        this.channel.on('reply', reply => this.processReply(reply));\n        this.channel.on('disconnected', () => {\n            this.activeRequests.forEach(descriptor => {\n                clearTimeout(descriptor.timeout);\n                descriptor.reject(new twilsockerror_1.TwilsockError('disconnected'));\n            });\n            this.activeRequests.clear();\n        });\n    }\n    get isConnected() { return this.channel.isConnected; }\n    processReply(reply) {\n        const request = this.activeRequests.get(reply.id);\n        if (request) {\n            clearTimeout(request.timeout);\n            this.activeRequests.delete(reply.id);\n            if (!isHttpSuccess(reply.status.code)) {\n                request.reject(new twilsockreplyerror_1.TwilsockReplyError('Transport failure: ' + reply.status.status, reply));\n                logger_1.log.trace('message rejected');\n            }\n            else {\n                request.resolve(reply);\n            }\n        }\n    }\n    storeRequest(id, resolve, reject) {\n        let requestDescriptor = {\n            resolve: resolve,\n            reject: reject,\n            timeout: setTimeout(() => {\n                logger_1.log.trace('request', id, 'is timed out');\n                reject(new twilsockerror_1.TwilsockError('Twilsock: request timeout: ' + id));\n            }, REQUEST_TIMEOUT)\n        };\n        this.activeRequests.set(id, requestDescriptor);\n    }\n    shutdown() {\n        this.activeRequests.forEach((descriptor) => {\n            clearTimeout(descriptor.timeout);\n            descriptor.reject(new twilsockerror_1.TwilsockError('Twilsock: request cancelled by user'));\n        });\n        this.activeRequests.clear();\n    }\n    async sendInit() {\n        logger_1.log.trace('sendInit');\n        let metadata = metadata_1.Metadata.getMetadata(this.config);\n        let message = new Messages.Init(this.config.token, this.config.continuationToken, metadata, this.config.initRegistrations, this.config.tweaks);\n        let response = await this.sendWithReply(message);\n        return new Messages.InitReply(response.id, response.header.continuation_token, response.header.continuation_token_status, response.header.offline_storage, response.header.init_registrations, response.header.debug_info);\n    }\n    sendClose() {\n        let message = new Messages.Close();\n        this.send(message);\n    }\n    sendWithReply(header, payload) {\n        return new Promise((resolve, reject) => {\n            let id = this.send(header, payload);\n            this.storeRequest(id, resolve, reject);\n        });\n    }\n    send(header, payload) {\n        header.id = header.id || `TM${uuid_1.v4()}`;\n        let message = parser_1.Parser.createPacket(header, preparePayload(payload));\n        try {\n            this.channel.send(message);\n            return header.id;\n        }\n        catch (e) {\n            logger_1.log.debug('failed to send ', header, e);\n            logger_1.log.trace(e.stack);\n            throw e;\n        }\n    }\n}\nexports.PacketInterface = PacketInterface;\n"]},"metadata":{},"sourceType":"script"}