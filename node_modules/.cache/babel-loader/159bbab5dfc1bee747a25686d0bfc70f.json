{"ast":null,"code":"const config = require('./config');\n\nif (config.SockJS) {\n  // dont use configurify for exporting sockjs\n  config.SockJS = require('sockjs-client');\n}\n\nif (config.WS) {\n  // dont use configurify for exporting ws\n  config.WS = require('ws');\n}\n\nconst Promise = require('lie');\n\nconst Events = require('backbone-events-standalone');\n\nconst Room = require('./room.js');\n\nconst assign = require('lodash.assign');\n\nconst get = require('lodash.get');\n\nconst omit = require('lodash.omit');\n\nconst sockEvents = require('./sock_events.js');\n\nconst _require = require('./utils'),\n      isString = _require.isString,\n      isFunction = _require.isFunction,\n      wrapError = _require.wrapError,\n      hasListeners = _require.hasListeners,\n      warn = _require.warn;\n\nconst States = {\n  CLOSED: 0,\n  OPEN: 1,\n  HANDSHAKEN: 2,\n  AUTHENTICATED: 3\n};\nconst ABNORMAL_CLOSURE = 1006;\nconst isNode = config.isNode,\n      isBrowser = config.isBrowser,\n      isBrowserLite = config.isBrowserLite,\n      isReactNative = config.isReactNative;\nlet reconnectAttempt = 0;\n\nfunction Scaledrone(channel, options) {\n  if (!channel) {\n    throw new Error('No Channel ID is defined');\n  }\n\n  if (!isString(channel)) {\n    throw new Error('Channel ID must be of type string');\n  }\n\n  options = assign({}, {\n    autoReconnect: true,\n    url: null,\n    originalInstance: this,\n    data: null,\n    debug: false\n  }, options);\n  this.args = arguments;\n  this.args[1] = options;\n  this.originalInstance = options.originalInstance;\n  this.readyState = States.CLOSED;\n  this.callbackId = 0;\n  this.callbacks = {};\n  this.rooms = {};\n  this.disconnected = false;\n  this.connection = getConnection(options);\n  this.emitter = Events.mixin({});\n  sockEvents(this.connection, this.emitter, {\n    debug: options.debug\n  });\n  this.autoReconnect = options.autoReconnect;\n  this.innerEmitter = Events.mixin({});\n  this.eventPromises = this.createEventPromises();\n  this.emitter.on('open', () => {\n    this.readyState = States.OPEN;\n\n    this._sendMessage('handshake', {\n      channel,\n      version: 2,\n      client_data: options.data\n    }, {}, (error, data) => {\n      if (!error) {\n        this.clientId = data.client_id;\n        this.readyState = States.HANDSHAKEN;\n        this.requireAuth = data.require_auth;\n      }\n\n      this._trigger('open', error);\n    });\n  });\n  this.emitter.on('message', event => {\n    const data = JSON.parse(event.data);\n    const safeData = omit(data, ['callback', 'error']);\n    const observableMessageTypes = ['observable_members', 'observable_member_join', 'observable_member_leave']; // observable event\n\n    if (observableMessageTypes.indexOf(data.type) !== -1) {\n      const room = this.rooms[data.room];\n\n      if (!room) {\n        return;\n      }\n\n      const eventName = data.type.slice('observable_'.length);\n      room.trigger(eventName, data.data);\n      return;\n    } // callback\n\n\n    if (data.callback != null) {\n      const cid = data.callback,\n            callback = this.callbacks[cid];\n\n      if (isFunction(callback)) {\n        callback(wrapError(data.error), safeData);\n        delete this.callbacks[cid];\n        return;\n      }\n    } // error\n\n\n    if (data.error) {\n      this.trigger('error', wrapError(data.error));\n      return;\n    } // message / publish\n\n\n    if (data.type === 'publish') {\n      const room = this.rooms[data.room];\n\n      if (!room) {\n        return;\n      }\n\n      const message = {\n        data: data.message,\n        id: data.id,\n        timestamp: data.timestamp\n      };\n      const client_id = data.client_id;\n\n      if (data.client_id) {\n        message.clientId = client_id;\n      }\n\n      let member;\n\n      if (room._observable && client_id) {\n        member = room._getCacheMember(client_id);\n        message.member = member;\n      }\n\n      room.trigger('message', message);\n      room.trigger('data', data.message, member); // deprecated 'data' event\n\n      return;\n    } // history message\n\n\n    if (data.type === 'history_message') {\n      const room = this.rooms[data.room];\n\n      if (!room) {\n        return;\n      }\n\n      room._handleHistoryMessage(data);\n\n      return;\n    }\n  });\n  this.emitter.on('close', event => {\n    if (this.autoReconnect && get(event, 'code') === ABNORMAL_CLOSURE && get(event, 'reason', '').indexOf('exceeded') === -1) {\n      // check if client has already disconnected\n      // has already tired to reconnect\n      if (!this.disconnected) {\n        this.trigger('disconnect');\n      }\n\n      reconnect(this, options, event);\n    } else {\n      this.trigger('close', event);\n    }\n  });\n  this.emitter.on('error', error => this.trigger('error', error));\n  this.emitter.on('disconnect', () => this.disconnected = true);\n  this.emitter.on('reconnect', () => this.disconnected = false);\n  this.emitter.on('authenticate', error => this._trigger('authenticate', error));\n}\n\nEvents.mixin(Scaledrone.prototype);\n\nScaledrone.prototype._trigger = function (type, error) {\n  if (hasListeners(this, type)) {\n    this.trigger(type, error);\n  } else if (error) {\n    this.trigger('error', error);\n  }\n\n  this.innerEmitter.trigger(type, error);\n};\n\nScaledrone.prototype._sendMessage = function (type, data, options = {}, callback) {\n  const message = assign({\n    type\n  }, data);\n\n  if (callback) {\n    const callbackID = this.callbackId++;\n    message.callback = callbackID;\n    this.callbacks[callbackID] = callback;\n  }\n\n  const promise = options.waitForPromise || Promise.resolve();\n  promise.then(() => this.connection.send(JSON.stringify(message)));\n};\n\nScaledrone.prototype.subscribe = function (roomName, {\n  historyCount\n} = {}) {\n  if (!roomName) {\n    throw new Error('Room name is not defined');\n  }\n\n  if (!isString(roomName)) {\n    throw new Error('Room name must be of type string');\n  }\n\n  const room = new Room(roomName, {\n    historyCount\n  }, this);\n  this.rooms[roomName] = room;\n\n  this._sendMessage('subscribe', {\n    room: roomName,\n    history: historyCount,\n    //TODO: remove once all servers have depracated this param\n    history_count: historyCount\n  }, {\n    waitForPromise: this.eventPromises.fullyConnected\n  }, error => room._trigger('open', error));\n\n  return room;\n};\n\nScaledrone.prototype.unsubscribe = function (roomName) {\n  if (!roomName) {\n    throw new Error('Room name is not defined');\n  }\n\n  if (!isString(roomName)) {\n    throw new Error('Room name must be of type string');\n  }\n\n  this._sendMessage('unsubscribe', {\n    room: roomName\n  }, {\n    waitForPromise: this.eventPromises.fullyConnected\n  });\n};\n\nScaledrone.prototype.publish = function (options) {\n  if (!options) {\n    throw new Error('No options defined');\n  }\n\n  if (!options.room) {\n    throw new Error('No room defined');\n  }\n\n  if (!options.message) {\n    throw new Error('No message defined');\n  }\n\n  if (this.readyState === States.CLOSED) {\n    throw new Error('Connection is closed');\n  }\n\n  let sendOptions = {\n    waitForPromise: this.eventPromises.fullyConnected\n  };\n\n  if (this.requireAuth && this.readyState !== States.AUTHENTICATED) {\n    warn('Messages can be sent after authenticating');\n    sendOptions = {};\n  }\n\n  this._sendMessage('publish', {\n    room: options.room,\n    message: options.message\n  }, sendOptions);\n};\n\nScaledrone.prototype.authenticate = function (token) {\n  if (!token) {\n    throw new Error('No token defined');\n  }\n\n  this._sendMessage('authenticate', {\n    token\n  }, {\n    waitForPromise: this.eventPromises.open\n  }, error => {\n    this.readyState = States.AUTHENTICATED;\n    this.token = token;\n    this.emitter.trigger('authenticate', error);\n  });\n};\n\nScaledrone.prototype.close = function () {\n  this.connection.close();\n};\n\nScaledrone.prototype.createEventPromises = function () {\n  return {\n    fullyConnected: new Promise((resolve, reject) => {\n      const listenToAuthenticate = () => {\n        this.innerEmitter.once('authenticate', error => {\n          if (error) {\n            reject(error);\n          } else {\n            resolve();\n          }\n        });\n      };\n\n      this.innerEmitter.once('open', error => {\n        if (error) {\n          reject(error);\n        } else {\n          if (this.requireAuth) {\n            listenToAuthenticate();\n          } else {\n            resolve();\n          }\n        }\n      });\n    }),\n    open: new Promise((resolve, reject) => {\n      this.innerEmitter.once('open', error => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      });\n    })\n  };\n};\n\nfunction reconnect(old, options, cause) {\n  const originalInstance = old.originalInstance;\n\n  if (reconnectAttempt > 25) {\n    originalInstance.trigger('close', cause);\n  } else {\n    const timeout = reconnectAttempt++ * 1000 * (Math.random() + 0.5);\n    setTimeout(function () {\n      const args = originalInstance.args;\n      const drone = new Scaledrone(args[0], args[1]);\n      drone.innerEmitter.on('open', function () {\n        reconnectAttempt = 0;\n        drone.emitter = originalInstance.emitter; // Just in case give the old flag to the connection\n\n        old.connection.old = true; // Replace the old connection so that\n        // publish would be made to the new one\n\n        originalInstance.connection = drone.connection; // Delegate new connection events to originalInstance emitter\n        // that the client is listening to\n\n        sockEvents(drone.connection, originalInstance.emitter); // Subscribe to originalInstance rooms\n\n        for (const roomName in originalInstance.rooms) {\n          drone.subscribe(roomName);\n        }\n\n        originalInstance.trigger('reconnect');\n      });\n    }, timeout);\n  }\n}\n\nfunction getConnection(options) {\n  if (options.type !== 'sockjs' && supportsWebsockets()) {\n    if (isNode) {\n      return new config.WS(options.url || config.websocketUrl, config.websocketOptions);\n    } else {\n      return new WebSocket(options.url || config.websocketUrl);\n    }\n  } else {\n    return new config.SockJS(options.url || config.sockjsUrl, null, {\n      transports: ['xdr', 'websocket-streaming', 'xhr-streaming', 'iframe-eventsource', 'iframe-htmlfile', 'xdr-polling', 'xhr-polling', 'iframe-xhr-polling', 'jsonp-polling']\n    });\n  }\n}\n\nfunction supportsWebsockets() {\n  if (isBrowserLite) {\n    // lite version only supports WS\n    return true;\n  }\n\n  if (isNode && config.type !== 'sockjs') {\n    return true;\n  }\n\n  if (isBrowser && 'WebSocket' in window && window.WebSocket.CLOSING === 2) {\n    return true;\n  }\n\n  if (isReactNative) {\n    return true;\n  }\n\n  return false;\n}\n\nif (isBrowser) {\n  window.ScaleDrone = window.Scaledrone = Scaledrone;\n} else {\n  module.exports = Scaledrone;\n}","map":{"version":3,"sources":["C:/Users/khouloud/Documents/PI/MERN_Stack_PI/node_modules/scaledrone-react-native/index.js"],"names":["config","require","SockJS","WS","Promise","Events","Room","assign","get","omit","sockEvents","isString","isFunction","wrapError","hasListeners","warn","States","CLOSED","OPEN","HANDSHAKEN","AUTHENTICATED","ABNORMAL_CLOSURE","isNode","isBrowser","isBrowserLite","isReactNative","reconnectAttempt","Scaledrone","channel","options","Error","autoReconnect","url","originalInstance","data","debug","args","arguments","readyState","callbackId","callbacks","rooms","disconnected","connection","getConnection","emitter","mixin","innerEmitter","eventPromises","createEventPromises","on","_sendMessage","version","client_data","error","clientId","client_id","requireAuth","require_auth","_trigger","event","JSON","parse","safeData","observableMessageTypes","indexOf","type","room","eventName","slice","length","trigger","callback","cid","message","id","timestamp","member","_observable","_getCacheMember","_handleHistoryMessage","reconnect","prototype","callbackID","promise","waitForPromise","resolve","then","send","stringify","subscribe","roomName","historyCount","history","history_count","fullyConnected","unsubscribe","publish","sendOptions","authenticate","token","open","close","reject","listenToAuthenticate","once","old","cause","timeout","Math","random","setTimeout","drone","supportsWebsockets","websocketUrl","websocketOptions","WebSocket","sockjsUrl","transports","window","CLOSING","ScaleDrone","module","exports"],"mappings":"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","sourcesContent":["const config = require('./config');\r\nif (config.SockJS) {\r\n  // dont use configurify for exporting sockjs\r\n  config.SockJS = require('sockjs-client');\r\n}\r\nif (config.WS) {\r\n  // dont use configurify for exporting ws\r\n  config.WS = require('ws');\r\n}\r\nconst Promise = require('lie');\r\nconst Events = require('backbone-events-standalone');\r\nconst Room = require('./room.js');\r\nconst assign = require('lodash.assign');\r\nconst get = require('lodash.get');\r\nconst omit = require('lodash.omit');\r\nconst sockEvents = require('./sock_events.js');\r\nconst {\r\n  isString, isFunction, wrapError, hasListeners, warn\r\n} = require('./utils');\r\nconst States = {\r\n  CLOSED: 0,\r\n  OPEN: 1,\r\n  HANDSHAKEN: 2,\r\n  AUTHENTICATED: 3\r\n};\r\nconst ABNORMAL_CLOSURE = 1006;\r\nconst {isNode, isBrowser, isBrowserLite, isReactNative} = config;\r\nlet reconnectAttempt = 0;\r\n\r\nfunction Scaledrone(channel, options) {\r\n  if (!channel) {\r\n    throw new Error('No Channel ID is defined');\r\n  }\r\n  if (!isString(channel)) {\r\n    throw new Error('Channel ID must be of type string');\r\n  }\r\n  options = assign({}, {\r\n    autoReconnect: true,\r\n    url: null,\r\n    originalInstance: this,\r\n    data: null,\r\n    debug: false,\r\n  }, options);\r\n  this.args = arguments;\r\n  this.args[1] = options;\r\n  this.originalInstance = options.originalInstance;\r\n  this.readyState = States.CLOSED;\r\n  this.callbackId = 0;\r\n  this.callbacks = {};\r\n  this.rooms = {};\r\n  this.disconnected = false;\r\n  this.connection = getConnection(options);\r\n  this.emitter = Events.mixin({});\r\n  sockEvents(this.connection, this.emitter, {debug: options.debug});\r\n  this.autoReconnect = options.autoReconnect;\r\n  this.innerEmitter = Events.mixin({});\r\n  this.eventPromises = this.createEventPromises();\r\n\r\n  this.emitter.on('open', () => {\r\n    this.readyState = States.OPEN;\r\n    this._sendMessage('handshake', {\r\n      channel,\r\n      version: 2,\r\n      client_data: options.data,\r\n    }, {}, (error, data) => {\r\n      if (!error) {\r\n        this.clientId = data.client_id;\r\n        this.readyState = States.HANDSHAKEN;\r\n        this.requireAuth = data.require_auth;\r\n      }\r\n      this._trigger('open', error);\r\n    });\r\n  });\r\n\r\n  this.emitter.on('message', event => {\r\n    const data = JSON.parse(event.data);\r\n    const safeData = omit(data, ['callback', 'error']);\r\n\r\n    const observableMessageTypes = [\r\n      'observable_members',\r\n      'observable_member_join',\r\n      'observable_member_leave',\r\n    ];\r\n\r\n    // observable event\r\n    if (observableMessageTypes.indexOf(data.type) !== -1) {\r\n      const room = this.rooms[data.room];\r\n      if (!room) {\r\n        return;\r\n      }\r\n      const eventName = data.type.slice('observable_'.length);\r\n      room.trigger(eventName, data.data);\r\n      return;\r\n    }\r\n\r\n    // callback\r\n    if (data.callback != null) {\r\n      const cid = data.callback,\r\n      callback = this.callbacks[cid];\r\n      if (isFunction(callback)) {\r\n        callback(wrapError(data.error), safeData);\r\n        delete this.callbacks[cid];\r\n        return;\r\n      }\r\n    }\r\n\r\n    // error\r\n    if (data.error) {\r\n      this.trigger('error', wrapError(data.error));\r\n      return;\r\n    }\r\n\r\n    // message / publish\r\n    if (data.type === 'publish') {\r\n      const room = this.rooms[data.room];\r\n      if (!room) {\r\n        return;\r\n      }\r\n      const message = {\r\n        data: data.message,\r\n        id: data.id,\r\n        timestamp: data.timestamp,\r\n      };\r\n      const {client_id} = data;\r\n      if (data.client_id) {\r\n        message.clientId = client_id;\r\n      }\r\n      let member;\r\n      if (room._observable && client_id) {\r\n        member = room._getCacheMember(client_id);\r\n        message.member = member;\r\n      }\r\n      room.trigger('message', message);\r\n      room.trigger('data', data.message, member); // deprecated 'data' event\r\n      return;\r\n    }\r\n\r\n    // history message\r\n    if (data.type === 'history_message') {\r\n      const room = this.rooms[data.room];\r\n      if (!room) {\r\n        return;\r\n      }\r\n      room._handleHistoryMessage(data);\r\n      return;\r\n    }\r\n  });\r\n\r\n  this.emitter.on('close', event => {\r\n    if (\r\n      this.autoReconnect &&\r\n      get(event, 'code') === ABNORMAL_CLOSURE &&\r\n      get(event, 'reason', '').indexOf('exceeded') === -1\r\n    ) {\r\n      // check if client has already disconnected\r\n      // has already tired to reconnect\r\n      if (!this.disconnected) {\r\n        this.trigger('disconnect');\r\n      }\r\n      reconnect(this, options, event);\r\n    } else {\r\n      this.trigger('close', event);\r\n    }\r\n  });\r\n\r\n  this.emitter.on('error', error => this.trigger('error', error));\r\n\r\n  this.emitter.on('disconnect', () => this.disconnected = true);\r\n  this.emitter.on('reconnect', () => this.disconnected = false);\r\n  this.emitter.on('authenticate',\r\n    error => this._trigger('authenticate', error)\r\n  );\r\n}\r\n\r\nEvents.mixin(Scaledrone.prototype);\r\n\r\nScaledrone.prototype._trigger = function(type, error) {\r\n  if (hasListeners(this, type)) {\r\n    this.trigger(type, error);\r\n  } else if (error) {\r\n    this.trigger('error', error);\r\n  }\r\n  this.innerEmitter.trigger(type, error);\r\n};\r\n\r\nScaledrone.prototype._sendMessage = function(\r\n  type, data, options = {}, callback\r\n) {\r\n  const message = assign({type}, data);\r\n  if (callback) {\r\n    const callbackID = this.callbackId++;\r\n    message.callback = callbackID;\r\n    this.callbacks[callbackID] = callback;\r\n  }\r\n  const promise = options.waitForPromise || Promise.resolve();\r\n  promise.then(() => this.connection.send(JSON.stringify(message)));\r\n};\r\n\r\nScaledrone.prototype.subscribe = function(roomName, {historyCount} = {}) {\r\n  if (!roomName) {\r\n    throw new Error('Room name is not defined');\r\n  }\r\n  if (!isString(roomName)) {\r\n    throw new Error('Room name must be of type string');\r\n  }\r\n  const room = new Room(roomName, {historyCount}, this);\r\n  this.rooms[roomName] = room;\r\n  this._sendMessage('subscribe', {\r\n    room: roomName,\r\n    history: historyCount, //TODO: remove once all servers have depracated this param\r\n    history_count: historyCount,\r\n  }, {\r\n    waitForPromise: this.eventPromises.fullyConnected\r\n  }, error => room._trigger('open', error));\r\n  return room;\r\n};\r\n\r\nScaledrone.prototype.unsubscribe = function(roomName) {\r\n  if (!roomName) {\r\n    throw new Error('Room name is not defined');\r\n  }\r\n  if (!isString(roomName)) {\r\n    throw new Error('Room name must be of type string');\r\n  }\r\n  this._sendMessage(\r\n    'unsubscribe',\r\n    {room: roomName},\r\n    {waitForPromise: this.eventPromises.fullyConnected}\r\n  );\r\n};\r\n\r\nScaledrone.prototype.publish = function(options) {\r\n  if (!options) {\r\n    throw new Error('No options defined');\r\n  }\r\n  if (!options.room) {\r\n    throw new Error('No room defined');\r\n  }\r\n  if (!options.message) {\r\n    throw new Error('No message defined');\r\n  }\r\n  if (this.readyState === States.CLOSED) {\r\n    throw new Error('Connection is closed');\r\n  }\r\n  let sendOptions = {waitForPromise: this.eventPromises.fullyConnected};\r\n  if (this.requireAuth && this.readyState !== States.AUTHENTICATED) {\r\n    warn('Messages can be sent after authenticating');\r\n    sendOptions = {};\r\n  }\r\n  this._sendMessage(\r\n    'publish', {room: options.room, message: options.message}, sendOptions\r\n  );\r\n};\r\n\r\nScaledrone.prototype.authenticate = function(token) {\r\n  if (!token) {\r\n    throw new Error('No token defined');\r\n  }\r\n  this._sendMessage(\r\n    'authenticate',\r\n    {token},\r\n    {waitForPromise: this.eventPromises.open},\r\n    error => {\r\n      this.readyState = States.AUTHENTICATED;\r\n      this.token = token;\r\n      this.emitter.trigger('authenticate', error);\r\n    }\r\n  );\r\n};\r\n\r\nScaledrone.prototype.close = function() {\r\n  this.connection.close();\r\n};\r\n\r\nScaledrone.prototype.createEventPromises = function() {\r\n  return {\r\n    fullyConnected: new Promise((resolve, reject) => {\r\n      const listenToAuthenticate = () => {\r\n        this.innerEmitter.once('authenticate', error => {\r\n          if (error) {\r\n            reject(error);\r\n          } else {\r\n            resolve();\r\n          }\r\n        });\r\n      };\r\n      this.innerEmitter.once('open', error => {\r\n        if (error) {\r\n          reject(error);\r\n        } else {\r\n          if (this.requireAuth) {\r\n            listenToAuthenticate();\r\n          } else {\r\n            resolve();\r\n          }\r\n        }\r\n      });\r\n    }),\r\n    open: new Promise((resolve, reject) => {\r\n      this.innerEmitter.once('open', error => {\r\n        if (error) {\r\n          reject(error);\r\n        } else {\r\n          resolve();\r\n        }\r\n      });\r\n    }),\r\n  };\r\n};\r\n\r\nfunction reconnect(old, options, cause) {\r\n  const originalInstance = old.originalInstance;\r\n  if (reconnectAttempt > 25) {\r\n    originalInstance.trigger('close', cause);\r\n  } else {\r\n    const timeout = reconnectAttempt++ * 1000 * (Math.random() + 0.5);\r\n    setTimeout(function() {\r\n      const args = originalInstance.args;\r\n      const drone = new Scaledrone(args[0], args[1]);\r\n      drone.innerEmitter.on('open', function() {\r\n        reconnectAttempt = 0;\r\n        drone.emitter = originalInstance.emitter;\r\n        // Just in case give the old flag to the connection\r\n        old.connection.old = true;\r\n        // Replace the old connection so that\r\n        // publish would be made to the new one\r\n        originalInstance.connection = drone.connection;\r\n        // Delegate new connection events to originalInstance emitter\r\n        // that the client is listening to\r\n        sockEvents(drone.connection, originalInstance.emitter);\r\n        // Subscribe to originalInstance rooms\r\n        for (const roomName in originalInstance.rooms) {\r\n          drone.subscribe(roomName);\r\n        }\r\n        originalInstance.trigger('reconnect');\r\n      });\r\n    }, timeout);\r\n  }\r\n}\r\n\r\nfunction getConnection(options) {\r\n  if (options.type !== 'sockjs' && supportsWebsockets()) {\r\n    if (isNode) {\r\n      return new config.WS(\r\n        options.url || config.websocketUrl, config.websocketOptions\r\n      );\r\n    } else {\r\n      return new WebSocket(options.url || config.websocketUrl);\r\n    }\r\n  } else {\r\n    return new config.SockJS(options.url || config.sockjsUrl, null, {\r\n      transports: [\r\n        'xdr', 'websocket-streaming', 'xhr-streaming',\r\n        'iframe-eventsource', 'iframe-htmlfile', 'xdr-polling',\r\n        'xhr-polling', 'iframe-xhr-polling', 'jsonp-polling'\r\n      ]\r\n    });\r\n  }\r\n}\r\n\r\nfunction supportsWebsockets() {\r\n  if (isBrowserLite) { // lite version only supports WS\r\n    return true;\r\n  }\r\n  if (isNode && config.type !== 'sockjs') {\r\n    return true;\r\n  }\r\n  if (isBrowser && 'WebSocket' in window && window.WebSocket.CLOSING === 2) {\r\n    return true;\r\n  }\r\n  if (isReactNative) {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nif (isBrowser) {\r\n  window.ScaleDrone = window.Scaledrone = Scaledrone;\r\n} else {\r\n  module.exports = Scaledrone;\r\n}\r\n"]},"metadata":{},"sourceType":"script"}