{"ast":null,"code":"/**\n * Standalone extraction of Backbone.Events, no external dependency required.\n * Degrades nicely when Backone/underscore are already available in the current\n * global context.\n *\n * Note that docs suggest to use underscore's `_.extend()` method to add Events\n * support to some given object. A `mixin()` method has been added to the Events\n * prototype to avoid using underscore for that sole purpose:\n *\n *     var myEventEmitter = BackboneEvents.mixin({});\n *\n * Or for a function constructor:\n *\n *     function MyConstructor(){}\n *     MyConstructor.prototype.foo = function(){}\n *     BackboneEvents.mixin(MyConstructor.prototype);\n *\n * (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.\n * (c) 2013 Nicolas Perriault\n */\n\n/* global exports:true, define, module */\n(function () {\n  var root = this,\n      nativeForEach = Array.prototype.forEach,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      slice = Array.prototype.slice,\n      idCounter = 0; // Returns a partial implementation matching the minimal API subset required\n  // by Backbone.Events\n\n  function miniscore() {\n    return {\n      keys: Object.keys || function (obj) {\n        if (typeof obj !== \"object\" && typeof obj !== \"function\" || obj === null) {\n          throw new TypeError(\"keys() called on a non-object\");\n        }\n\n        var key,\n            keys = [];\n\n        for (key in obj) {\n          if (obj.hasOwnProperty(key)) {\n            keys[keys.length] = key;\n          }\n        }\n\n        return keys;\n      },\n      uniqueId: function uniqueId(prefix) {\n        var id = ++idCounter + '';\n        return prefix ? prefix + id : id;\n      },\n      has: function has(obj, key) {\n        return hasOwnProperty.call(obj, key);\n      },\n      each: function each(obj, iterator, context) {\n        if (obj == null) return;\n\n        if (nativeForEach && obj.forEach === nativeForEach) {\n          obj.forEach(iterator, context);\n        } else if (obj.length === +obj.length) {\n          for (var i = 0, l = obj.length; i < l; i++) {\n            iterator.call(context, obj[i], i, obj);\n          }\n        } else {\n          for (var key in obj) {\n            if (this.has(obj, key)) {\n              iterator.call(context, obj[key], key, obj);\n            }\n          }\n        }\n      },\n      once: function once(func) {\n        var ran = false,\n            memo;\n        return function () {\n          if (ran) return memo;\n          ran = true;\n          memo = func.apply(this, arguments);\n          func = null;\n          return memo;\n        };\n      }\n    };\n  }\n\n  var _ = miniscore(),\n      Events; // Backbone.Events\n  // ---------------\n  // A module that can be mixed in to *any object* in order to provide it with\n  // custom events. You may bind with `on` or remove with `off` callback\n  // functions to an event; `trigger`-ing an event fires all callbacks in\n  // succession.\n  //\n  //     var object = {};\n  //     _.extend(object, Backbone.Events);\n  //     object.on('expand', function(){ alert('expanded'); });\n  //     object.trigger('expand');\n  //\n\n\n  Events = {\n    // Bind an event to a `callback` function. Passing `\"all\"` will bind\n    // the callback to all events fired.\n    on: function on(name, callback, context) {\n      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;\n      this._events || (this._events = {});\n      var events = this._events[name] || (this._events[name] = []);\n      events.push({\n        callback: callback,\n        context: context,\n        ctx: context || this\n      });\n      return this;\n    },\n    // Bind an event to only be triggered a single time. After the first time\n    // the callback is invoked, it will be removed.\n    once: function once(name, callback, context) {\n      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;\n      var self = this;\n\n      var once = _.once(function () {\n        self.off(name, once);\n        callback.apply(this, arguments);\n      });\n\n      once._callback = callback;\n      return this.on(name, once, context);\n    },\n    // Remove one or many callbacks. If `context` is null, removes all\n    // callbacks with that function. If `callback` is null, removes all\n    // callbacks for the event. If `name` is null, removes all bound\n    // callbacks for all events.\n    off: function off(name, callback, context) {\n      var retain, ev, events, names, i, l, j, k;\n      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;\n\n      if (!name && !callback && !context) {\n        this._events = {};\n        return this;\n      }\n\n      names = name ? [name] : _.keys(this._events);\n\n      for (i = 0, l = names.length; i < l; i++) {\n        name = names[i];\n\n        if (events = this._events[name]) {\n          this._events[name] = retain = [];\n\n          if (callback || context) {\n            for (j = 0, k = events.length; j < k; j++) {\n              ev = events[j];\n\n              if (callback && callback !== ev.callback && callback !== ev.callback._callback || context && context !== ev.context) {\n                retain.push(ev);\n              }\n            }\n          }\n\n          if (!retain.length) delete this._events[name];\n        }\n      }\n\n      return this;\n    },\n    // Trigger one or many events, firing all bound callbacks. Callbacks are\n    // passed the same arguments as `trigger` is, apart from the event name\n    // (unless you're listening on `\"all\"`, which will cause your callback to\n    // receive the true name of the event as the first argument).\n    trigger: function trigger(name) {\n      if (!this._events) return this;\n      var args = slice.call(arguments, 1);\n      if (!eventsApi(this, 'trigger', name, args)) return this;\n      var events = this._events[name];\n      var allEvents = this._events.all;\n      if (events) triggerEvents(events, args);\n      if (allEvents) triggerEvents(allEvents, arguments);\n      return this;\n    },\n    // Tell this object to stop listening to either specific events ... or\n    // to every object it's currently listening to.\n    stopListening: function stopListening(obj, name, callback) {\n      var listeners = this._listeners;\n      if (!listeners) return this;\n      var deleteListener = !name && !callback;\n      if (typeof name === 'object') callback = this;\n      if (obj) (listeners = {})[obj._listenerId] = obj;\n\n      for (var id in listeners) {\n        listeners[id].off(name, callback, this);\n        if (deleteListener) delete this._listeners[id];\n      }\n\n      return this;\n    }\n  }; // Regular expression used to split event strings.\n\n  var eventSplitter = /\\s+/; // Implement fancy features of the Events API such as multiple event\n  // names `\"change blur\"` and jQuery-style event maps `{change: action}`\n  // in terms of the existing API.\n\n  var eventsApi = function eventsApi(obj, action, name, rest) {\n    if (!name) return true; // Handle event maps.\n\n    if (typeof name === 'object') {\n      for (var key in name) {\n        obj[action].apply(obj, [key, name[key]].concat(rest));\n      }\n\n      return false;\n    } // Handle space separated event names.\n\n\n    if (eventSplitter.test(name)) {\n      var names = name.split(eventSplitter);\n\n      for (var i = 0, l = names.length; i < l; i++) {\n        obj[action].apply(obj, [names[i]].concat(rest));\n      }\n\n      return false;\n    }\n\n    return true;\n  }; // A difficult-to-believe, but optimized internal dispatch function for\n  // triggering events. Tries to keep the usual cases speedy (most internal\n  // Backbone events have 3 arguments).\n\n\n  var triggerEvents = function triggerEvents(events, args) {\n    var ev,\n        i = -1,\n        l = events.length,\n        a1 = args[0],\n        a2 = args[1],\n        a3 = args[2];\n\n    switch (args.length) {\n      case 0:\n        while (++i < l) (ev = events[i]).callback.call(ev.ctx);\n\n        return;\n\n      case 1:\n        while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1);\n\n        return;\n\n      case 2:\n        while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2);\n\n        return;\n\n      case 3:\n        while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n\n        return;\n\n      default:\n        while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);\n\n    }\n  };\n\n  var listenMethods = {\n    listenTo: 'on',\n    listenToOnce: 'once'\n  }; // Inversion-of-control versions of `on` and `once`. Tell *this* object to\n  // listen to an event in another object ... keeping track of what it's\n  // listening to.\n\n  _.each(listenMethods, function (implementation, method) {\n    Events[method] = function (obj, name, callback) {\n      var listeners = this._listeners || (this._listeners = {});\n\n      var id = obj._listenerId || (obj._listenerId = _.uniqueId('l'));\n\n      listeners[id] = obj;\n      if (typeof name === 'object') callback = this;\n      obj[implementation](name, callback, this);\n      return this;\n    };\n  }); // Aliases for backwards compatibility.\n\n\n  Events.bind = Events.on;\n  Events.unbind = Events.off; // Mixin utility\n\n  Events.mixin = function (proto) {\n    var exports = ['on', 'once', 'off', 'trigger', 'stopListening', 'listenTo', 'listenToOnce', 'bind', 'unbind'];\n\n    _.each(exports, function (name) {\n      proto[name] = this[name];\n    }, this);\n\n    return proto;\n  }; // Export Events as BackboneEvents depending on current context\n\n\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = Events;\n    }\n\n    exports.BackboneEvents = Events;\n  } else if (typeof define === \"function\" && typeof define.amd == \"object\") {\n    define(function () {\n      return Events;\n    });\n  } else {\n    root.BackboneEvents = Events;\n  }\n})(this);","map":{"version":3,"sources":["C:/Users/khouloud/Documents/PI/MERN_Stack_PI/node_modules/backbone-events-standalone/backbone-events-standalone.js"],"names":["root","nativeForEach","Array","prototype","forEach","hasOwnProperty","Object","slice","idCounter","miniscore","keys","obj","TypeError","key","length","uniqueId","prefix","id","has","call","each","iterator","context","i","l","once","func","ran","memo","apply","arguments","_","Events","on","name","callback","eventsApi","_events","events","push","ctx","self","off","_callback","retain","ev","names","j","k","trigger","args","allEvents","all","triggerEvents","stopListening","listeners","_listeners","deleteListener","_listenerId","eventSplitter","action","rest","concat","test","split","a1","a2","a3","listenMethods","listenTo","listenToOnce","implementation","method","bind","unbind","mixin","proto","exports","module","BackboneEvents","define","amd"],"mappings":"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","sourcesContent":["/**\n * Standalone extraction of Backbone.Events, no external dependency required.\n * Degrades nicely when Backone/underscore are already available in the current\n * global context.\n *\n * Note that docs suggest to use underscore's `_.extend()` method to add Events\n * support to some given object. A `mixin()` method has been added to the Events\n * prototype to avoid using underscore for that sole purpose:\n *\n *     var myEventEmitter = BackboneEvents.mixin({});\n *\n * Or for a function constructor:\n *\n *     function MyConstructor(){}\n *     MyConstructor.prototype.foo = function(){}\n *     BackboneEvents.mixin(MyConstructor.prototype);\n *\n * (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.\n * (c) 2013 Nicolas Perriault\n */\n/* global exports:true, define, module */\n(function() {\n  var root = this,\n      nativeForEach = Array.prototype.forEach,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      slice = Array.prototype.slice,\n      idCounter = 0;\n\n  // Returns a partial implementation matching the minimal API subset required\n  // by Backbone.Events\n  function miniscore() {\n    return {\n      keys: Object.keys || function (obj) {\n        if (typeof obj !== \"object\" && typeof obj !== \"function\" || obj === null) {\n          throw new TypeError(\"keys() called on a non-object\");\n        }\n        var key, keys = [];\n        for (key in obj) {\n          if (obj.hasOwnProperty(key)) {\n            keys[keys.length] = key;\n          }\n        }\n        return keys;\n      },\n\n      uniqueId: function(prefix) {\n        var id = ++idCounter + '';\n        return prefix ? prefix + id : id;\n      },\n\n      has: function(obj, key) {\n        return hasOwnProperty.call(obj, key);\n      },\n\n      each: function(obj, iterator, context) {\n        if (obj == null) return;\n        if (nativeForEach && obj.forEach === nativeForEach) {\n          obj.forEach(iterator, context);\n        } else if (obj.length === +obj.length) {\n          for (var i = 0, l = obj.length; i < l; i++) {\n            iterator.call(context, obj[i], i, obj);\n          }\n        } else {\n          for (var key in obj) {\n            if (this.has(obj, key)) {\n              iterator.call(context, obj[key], key, obj);\n            }\n          }\n        }\n      },\n\n      once: function(func) {\n        var ran = false, memo;\n        return function() {\n          if (ran) return memo;\n          ran = true;\n          memo = func.apply(this, arguments);\n          func = null;\n          return memo;\n        };\n      }\n    };\n  }\n\n  var _ = miniscore(), Events;\n\n  // Backbone.Events\n  // ---------------\n\n  // A module that can be mixed in to *any object* in order to provide it with\n  // custom events. You may bind with `on` or remove with `off` callback\n  // functions to an event; `trigger`-ing an event fires all callbacks in\n  // succession.\n  //\n  //     var object = {};\n  //     _.extend(object, Backbone.Events);\n  //     object.on('expand', function(){ alert('expanded'); });\n  //     object.trigger('expand');\n  //\n  Events = {\n\n    // Bind an event to a `callback` function. Passing `\"all\"` will bind\n    // the callback to all events fired.\n    on: function(name, callback, context) {\n      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;\n      this._events || (this._events = {});\n      var events = this._events[name] || (this._events[name] = []);\n      events.push({callback: callback, context: context, ctx: context || this});\n      return this;\n    },\n\n    // Bind an event to only be triggered a single time. After the first time\n    // the callback is invoked, it will be removed.\n    once: function(name, callback, context) {\n      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;\n      var self = this;\n      var once = _.once(function() {\n        self.off(name, once);\n        callback.apply(this, arguments);\n      });\n      once._callback = callback;\n      return this.on(name, once, context);\n    },\n\n    // Remove one or many callbacks. If `context` is null, removes all\n    // callbacks with that function. If `callback` is null, removes all\n    // callbacks for the event. If `name` is null, removes all bound\n    // callbacks for all events.\n    off: function(name, callback, context) {\n      var retain, ev, events, names, i, l, j, k;\n      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;\n      if (!name && !callback && !context) {\n        this._events = {};\n        return this;\n      }\n\n      names = name ? [name] : _.keys(this._events);\n      for (i = 0, l = names.length; i < l; i++) {\n        name = names[i];\n        if (events = this._events[name]) {\n          this._events[name] = retain = [];\n          if (callback || context) {\n            for (j = 0, k = events.length; j < k; j++) {\n              ev = events[j];\n              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||\n                  (context && context !== ev.context)) {\n                retain.push(ev);\n              }\n            }\n          }\n          if (!retain.length) delete this._events[name];\n        }\n      }\n\n      return this;\n    },\n\n    // Trigger one or many events, firing all bound callbacks. Callbacks are\n    // passed the same arguments as `trigger` is, apart from the event name\n    // (unless you're listening on `\"all\"`, which will cause your callback to\n    // receive the true name of the event as the first argument).\n    trigger: function(name) {\n      if (!this._events) return this;\n      var args = slice.call(arguments, 1);\n      if (!eventsApi(this, 'trigger', name, args)) return this;\n      var events = this._events[name];\n      var allEvents = this._events.all;\n      if (events) triggerEvents(events, args);\n      if (allEvents) triggerEvents(allEvents, arguments);\n      return this;\n    },\n\n    // Tell this object to stop listening to either specific events ... or\n    // to every object it's currently listening to.\n    stopListening: function(obj, name, callback) {\n      var listeners = this._listeners;\n      if (!listeners) return this;\n      var deleteListener = !name && !callback;\n      if (typeof name === 'object') callback = this;\n      if (obj) (listeners = {})[obj._listenerId] = obj;\n      for (var id in listeners) {\n        listeners[id].off(name, callback, this);\n        if (deleteListener) delete this._listeners[id];\n      }\n      return this;\n    }\n\n  };\n\n  // Regular expression used to split event strings.\n  var eventSplitter = /\\s+/;\n\n  // Implement fancy features of the Events API such as multiple event\n  // names `\"change blur\"` and jQuery-style event maps `{change: action}`\n  // in terms of the existing API.\n  var eventsApi = function(obj, action, name, rest) {\n    if (!name) return true;\n\n    // Handle event maps.\n    if (typeof name === 'object') {\n      for (var key in name) {\n        obj[action].apply(obj, [key, name[key]].concat(rest));\n      }\n      return false;\n    }\n\n    // Handle space separated event names.\n    if (eventSplitter.test(name)) {\n      var names = name.split(eventSplitter);\n      for (var i = 0, l = names.length; i < l; i++) {\n        obj[action].apply(obj, [names[i]].concat(rest));\n      }\n      return false;\n    }\n\n    return true;\n  };\n\n  // A difficult-to-believe, but optimized internal dispatch function for\n  // triggering events. Tries to keep the usual cases speedy (most internal\n  // Backbone events have 3 arguments).\n  var triggerEvents = function(events, args) {\n    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];\n    switch (args.length) {\n      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;\n      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;\n      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;\n      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;\n      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);\n    }\n  };\n\n  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};\n\n  // Inversion-of-control versions of `on` and `once`. Tell *this* object to\n  // listen to an event in another object ... keeping track of what it's\n  // listening to.\n  _.each(listenMethods, function(implementation, method) {\n    Events[method] = function(obj, name, callback) {\n      var listeners = this._listeners || (this._listeners = {});\n      var id = obj._listenerId || (obj._listenerId = _.uniqueId('l'));\n      listeners[id] = obj;\n      if (typeof name === 'object') callback = this;\n      obj[implementation](name, callback, this);\n      return this;\n    };\n  });\n\n  // Aliases for backwards compatibility.\n  Events.bind   = Events.on;\n  Events.unbind = Events.off;\n\n  // Mixin utility\n  Events.mixin = function(proto) {\n    var exports = ['on', 'once', 'off', 'trigger', 'stopListening', 'listenTo',\n                   'listenToOnce', 'bind', 'unbind'];\n    _.each(exports, function(name) {\n      proto[name] = this[name];\n    }, this);\n    return proto;\n  };\n\n  // Export Events as BackboneEvents depending on current context\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = Events;\n    }\n    exports.BackboneEvents = Events;\n  }else if (typeof define === \"function\"  && typeof define.amd == \"object\") {\n    define(function() {\n      return Events;\n    });\n  } else {\n    root.BackboneEvents = Events;\n  }\n})(this);\n"]},"metadata":{},"sourceType":"script"}