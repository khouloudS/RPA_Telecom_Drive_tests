{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\khouloud\\\\Documents\\\\PI\\\\MERN_Stack_PI\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\khouloud\\\\Documents\\\\PI\\\\MERN_Stack_PI\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"events\");\n\nconst twilsock_1 = require(\"twilsock\");\n\nconst twilio_notifications_1 = require(\"twilio-notifications\");\n\nconst uri_1 = require(\"./utils/uri\");\n\nconst syncerror_1 = require(\"./utils/syncerror\");\n\nconst sanitize_1 = require(\"./utils/sanitize\");\n\nconst logger_1 = require(\"./utils/logger\");\n\nconst configuration_1 = require(\"./configuration\");\n\nconst subscriptions_1 = require(\"./subscriptions\");\n\nconst router_1 = require(\"./router\");\n\nconst network_1 = require(\"./services/network\");\n\nconst syncdocument_1 = require(\"./syncdocument\");\n\nconst synclist_1 = require(\"./synclist\");\n\nconst syncmap_1 = require(\"./syncmap\");\n\nconst clientInfo_1 = require(\"./clientInfo\");\n\nconst entitiesCache_1 = require(\"./entitiesCache\");\n\nconst storage_1 = require(\"./services/storage\");\n\nconst syncstream_1 = require(\"./streams/syncstream\");\n\nconst livequery_1 = require(\"./livequery\");\n\nconst livequery_2 = require(\"./livequery\");\n\nconst SYNC_PRODUCT_ID = 'data_sync';\n\nconst SDK_VERSION = require('../package.json').version;\n\nfunction decompose(arg) {\n  if (!arg) {\n    return {\n      mode: 'create_new'\n    };\n  } else if (typeof arg === 'string') {\n    return {\n      id: arg,\n      mode: 'open_or_create'\n    };\n  } else {\n    sanitize_1.validateOptionalTtl(arg.ttl);\n    sanitize_1.validateId(arg.id);\n    let mode = arg.mode || (arg.id ? 'open_or_create' : 'create_new');\n    return Object.assign(Object.assign({}, arg), {\n      mode: mode\n    });\n  }\n}\n/**\n * @class Client\n * @classdesc\n * Client for the Twilio Sync service.\n * @constructor\n * @param {String} token - Twilio access token.\n * @param {Client#ClientOptions} [options] - Options to customize the Client.\n * @example\n * // Using NPM\n * var SyncClient = require('twilio-sync');\n * var syncClient = new SyncClient(token, { logLevel: 'debug' });\n *\n * // Using CDN\n * var SyncClient = new Twilio.Sync.Client(token, { logLevel: 'debug' });\n *\n * @property {Client#ConnectionState} connectionState - Contains current service connection state.\n * Valid options are ['connecting', 'connected', 'disconnecting', 'disconnected', 'denied', 'error'].\n */\n\n\nclass Client extends events_1.EventEmitter {\n  constructor(fpaToken, options = {}) {\n    super();\n\n    if (!fpaToken) {\n      throw new Error('Sync library needs a valid Twilio token to be passed');\n    }\n\n    if (options.hasOwnProperty('logLevel')) {\n      logger_1.default.setLevel(options.logLevel);\n    } else {\n      logger_1.default.setLevel('silent');\n    }\n\n    const productId = options.productId = options.productId || SYNC_PRODUCT_ID; // Filling ClientMetadata\n\n    options.clientMetadata = options.clientMetadata || {};\n\n    if (!options.clientMetadata.hasOwnProperty('type')) {\n      options.clientMetadata.type = SYNC_PRODUCT_ID;\n    }\n\n    if (!options.clientMetadata.hasOwnProperty('sdk')) {\n      options.clientMetadata.sdk = 'JS';\n      options.clientMetadata.sdkv = SDK_VERSION;\n    }\n\n    let twilsock = options.twilsockClient = options.twilsockClient || new twilsock_1.Twilsock(fpaToken, productId, options);\n    twilsock.on('tokenAboutToExpire', ttl => this.emit('tokenAboutToExpire', ttl));\n    twilsock.on('tokenExpired', () => this.emit('tokenExpired'));\n    twilsock.on('connectionError', err => this.emit('connectionError', err));\n    let notifications = options.notificationsClient = options.notificationsClient || new twilio_notifications_1.Notifications(fpaToken, options);\n    let config = new configuration_1.Configuration(options);\n    let network = new network_1.NetworkService(new clientInfo_1.ClientInfo(SDK_VERSION), config, twilsock);\n    let storage = new storage_1.SessionStorage(config);\n    this.localStorageId = null;\n    twilsock.connect();\n    this.services = {\n      config,\n      twilsock,\n      notifications,\n      network,\n      storage,\n      router: null,\n      subscriptions: null\n    };\n    let subscriptions = new subscriptions_1.Subscriptions(this.services);\n    let router = new router_1.Router({\n      config,\n      subscriptions,\n      notifications\n    });\n    this.services.router = router;\n    this.services.subscriptions = subscriptions;\n    this.entities = new entitiesCache_1.EntitiesCache();\n    notifications.on('connectionStateChanged', () => {\n      this.emit('connectionStateChanged', this.services.notifications.connectionState);\n    });\n  }\n  /**\n   * Current version of Sync client.\n   * @name Client#version\n   * @type String\n   * @readonly\n   */\n\n\n  static get version() {\n    return SDK_VERSION;\n  }\n\n  get connectionState() {\n    return this.services.notifications.connectionState;\n  }\n  /**\n   * Returns promise which resolves when library is correctly initialized\n   * Or throws if initialization is impossible\n   * @private\n   */\n\n\n  ensureReady() {\n    var _this = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var storageSettings;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            if (_this.services.config.sessionStorageEnabled) {\n              _context.next = 2;\n              break;\n            }\n\n            return _context.abrupt(\"return\");\n\n          case 2:\n            _context.prev = 2;\n            _context.next = 5;\n            return _this.services.twilsock.storageId();\n\n          case 5:\n            storageSettings = _context.sent;\n\n            _this.services.storage.updateStorageId(storageSettings.id);\n\n            _context.next = 12;\n            break;\n\n          case 9:\n            _context.prev = 9;\n            _context.t0 = _context[\"catch\"](2);\n            logger_1.default.warn('Failed to initialize storage', _context.t0);\n\n          case 12:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, null, [[2, 9]]);\n    }))();\n  }\n\n  storeRootInSessionCache(type, id, value) {\n    // can't store without id\n    if (!this.services.config.sessionStorageEnabled || !id) {\n      return;\n    }\n\n    let valueToStore = sanitize_1.deepClone(value);\n\n    if (type === synclist_1.SyncList.type || type === syncmap_1.SyncMap.type) {\n      valueToStore['last_event_id'] = null;\n      delete valueToStore['items'];\n    }\n\n    this.services.storage.store(type, id, valueToStore);\n  }\n\n  readRootFromSessionCache(type, id) {\n    if (!this.services.config.sessionStorageEnabled || !id) {\n      return null;\n    }\n\n    return this.services.storage.read(type, id);\n  }\n\n  _get(baseUri, id, optimistic = false) {\n    var _this2 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      var uri, response;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            if (id) {\n              _context2.next = 2;\n              break;\n            }\n\n            throw new syncerror_1.SyncError(\"Cannot get entity without id\", 404);\n\n          case 2:\n            uri = new uri_1.UriBuilder(baseUri).pathSegment(id).queryParam('Include', optimistic ? 'items' : undefined).build();\n            _context2.next = 5;\n            return _this2.services.network.get(uri);\n\n          case 5:\n            response = _context2.sent;\n            return _context2.abrupt(\"return\", response.body);\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }))();\n  }\n\n  _createDocument(id, data, ttl) {\n    const requestBody = {\n      unique_name: id,\n      data: data || {}\n    };\n\n    if (ttl !== undefined) {\n      requestBody.ttl = ttl;\n    }\n\n    return this.services.network.post(this.services.config.documentsUri, requestBody).then(response => {\n      response.body.data = requestBody.data;\n      return response.body;\n    });\n  }\n\n  _getDocument(id) {\n    var _this3 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            return _context3.abrupt(\"return\", _this3.readRootFromSessionCache(syncdocument_1.SyncDocument.type, id) || _this3._get(_this3.services.config.documentsUri, id));\n\n          case 1:\n          case \"end\":\n            return _context3.stop();\n        }\n      }, _callee3);\n    }))();\n  }\n\n  _createList(id, purpose, context, ttl) {\n    const requestBody = {\n      unique_name: id,\n      purpose: purpose,\n      context: context\n    };\n\n    if (ttl !== undefined) {\n      requestBody.ttl = ttl;\n    }\n\n    return this.services.network.post(this.services.config.listsUri, requestBody).then(response => response.body);\n  }\n\n  _getList(id) {\n    var _this4 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            return _context4.abrupt(\"return\", _this4.readRootFromSessionCache(synclist_1.SyncList.type, id) || _this4._get(_this4.services.config.listsUri, id));\n\n          case 1:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee4);\n    }))();\n  }\n\n  _createMap(id, ttl) {\n    const requestBody = {\n      unique_name: id\n    };\n\n    if (ttl !== undefined) {\n      requestBody.ttl = ttl;\n    }\n\n    return this.services.network.post(this.services.config.mapsUri, requestBody).then(response => response.body);\n  }\n\n  _getMap(id, optimistic = false) {\n    var _this5 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            return _context5.abrupt(\"return\", _this5.readRootFromSessionCache(syncmap_1.SyncMap.type, id) || _this5._get(_this5.services.config.mapsUri, id, optimistic));\n\n          case 1:\n          case \"end\":\n            return _context5.stop();\n        }\n      }, _callee5);\n    }))();\n  }\n\n  _getStream(id) {\n    var _this6 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n      return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n        while (1) switch (_context6.prev = _context6.next) {\n          case 0:\n            return _context6.abrupt(\"return\", _this6.readRootFromSessionCache(syncstream_1.SyncStream.type, id) || _this6._get(_this6.services.config.streamsUri, id, false));\n\n          case 1:\n          case \"end\":\n            return _context6.stop();\n        }\n      }, _callee6);\n    }))();\n  }\n\n  _createStream(id, ttl) {\n    var _this7 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n      var requestBody, response;\n      return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n        while (1) switch (_context7.prev = _context7.next) {\n          case 0:\n            requestBody = {\n              unique_name: id\n            };\n\n            if (ttl !== undefined) {\n              requestBody.ttl = ttl;\n            }\n\n            _context7.next = 4;\n            return _this7.services.network.post(_this7.services.config.streamsUri, requestBody);\n\n          case 4:\n            response = _context7.sent;\n            return _context7.abrupt(\"return\", response.body);\n\n          case 6:\n          case \"end\":\n            return _context7.stop();\n        }\n      }, _callee7);\n    }))();\n  }\n\n  _getLiveQuery(sid) {\n    return this.readRootFromSessionCache(livequery_1.LiveQuery.type, sid);\n  }\n\n  getCached(id, type) {\n    if (id) {\n      return this.entities.get(id, type) || null;\n    }\n\n    return null;\n  }\n\n  removeFromCacheAndSession(type, sid, uniqueName) {\n    this.entities.remove(sid);\n\n    if (this.services.config.sessionStorageEnabled) {\n      this.services.storage.remove(type, sid, uniqueName);\n    }\n  }\n  /**\n   * Read or create a Sync Document.\n   * @param {String | Client#OpenOptions} [arg] One of:\n   * <li>Unique name or SID identifying a Sync Document - opens a Document with the given identifier or creates one if it does not exist.</li>\n   * <li>none - creates a new Document with a randomly assigned SID and no unique name.</li>\n   * <li>{@link Client#OpenOptions} object for more granular control.</li>\n   * @return {Promise<Document>} a promise which resolves after the Document is successfully read (or created).\n   * This promise may reject if the Document could not be created or if this endpoint lacks the necessary permissions to access it.\n   * @public\n   * @example\n   * syncClient.document('MyDocument')\n   *   .then(function(document) {\n   *     console.log('Successfully opened a Document. SID: ' + document.sid);\n   *     document.on('updated', function(event) {\n   *       console.log('Received updated event: ', event);\n   *     });\n   *   })\n   *   .catch(function(error) {\n   *     console.log('Unexpected error', error);\n   *   });\n   */\n\n\n  document(arg) {\n    var _this8 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n      var opts, docDescriptor, docFromInMemoryCache, syncDocumentImpl;\n      return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n        while (1) switch (_context8.prev = _context8.next) {\n          case 0:\n            _context8.next = 2;\n            return _this8.ensureReady();\n\n          case 2:\n            opts = decompose(arg);\n\n            if (!(opts.mode === 'create_new')) {\n              _context8.next = 9;\n              break;\n            }\n\n            _context8.next = 6;\n            return _this8._createDocument(opts.id, opts.value, opts.ttl);\n\n          case 6:\n            docDescriptor = _context8.sent;\n            _context8.next = 39;\n            break;\n\n          case 9:\n            docFromInMemoryCache = _this8.getCached(opts.id, syncdocument_1.SyncDocument.type);\n\n            if (!docFromInMemoryCache) {\n              _context8.next = 14;\n              break;\n            }\n\n            return _context8.abrupt(\"return\", new syncdocument_1.SyncDocument(docFromInMemoryCache));\n\n          case 14:\n            _context8.prev = 14;\n            _context8.next = 17;\n            return _this8._getDocument(opts.id);\n\n          case 17:\n            docDescriptor = _context8.sent;\n            _context8.next = 39;\n            break;\n\n          case 20:\n            _context8.prev = 20;\n            _context8.t0 = _context8[\"catch\"](14);\n\n            if (!(_context8.t0.status !== 404 || opts.mode === 'open_existing')) {\n              _context8.next = 26;\n              break;\n            }\n\n            throw _context8.t0;\n\n          case 26:\n            _context8.prev = 26;\n            _context8.next = 29;\n            return _this8._createDocument(opts.id, opts.value, opts.ttl);\n\n          case 29:\n            docDescriptor = _context8.sent;\n            _context8.next = 39;\n            break;\n\n          case 32:\n            _context8.prev = 32;\n            _context8.t1 = _context8[\"catch\"](26);\n\n            if (!(_context8.t1.status === 409)) {\n              _context8.next = 38;\n              break;\n            }\n\n            return _context8.abrupt(\"return\", _this8.document(arg));\n\n          case 38:\n            throw _context8.t1;\n\n          case 39:\n            _this8.storeRootInSessionCache(syncdocument_1.SyncDocument.type, opts.id, docDescriptor);\n\n            syncDocumentImpl = new syncdocument_1.SyncDocumentImpl(_this8.services, docDescriptor, (type, sid, uniqueName) => _this8.removeFromCacheAndSession(type, sid, uniqueName));\n            syncDocumentImpl = _this8.entities.store(syncDocumentImpl);\n            return _context8.abrupt(\"return\", new syncdocument_1.SyncDocument(syncDocumentImpl));\n\n          case 43:\n          case \"end\":\n            return _context8.stop();\n        }\n      }, _callee8, null, [[14, 20], [26, 32]]);\n    }))();\n  }\n  /**\n   * Read or create a Sync Map.\n   * @param {String | Client#OpenOptions} [arg] One of:\n   * <li>Unique name or SID identifying a Sync Map - opens a Map with the given identifier or creates one if it does not exist.</li>\n   * <li>none - creates a new Map with a randomly assigned SID and no unique name.</li>\n   * <li>{@link Client#OpenOptions} object for more granular control.</li>\n   * @return {Promise<Map>} a promise which resolves after the Map is successfully read (or created).\n   * This promise may reject if the Map could not be created or if this endpoint lacks the necessary permissions to access it.\n   * @public\n   * @example\n   * syncClient.map('MyMap')\n   *   .then(function(map) {\n   *     console.log('Successfully opened a Map. SID: ' + map.sid);\n   *     map.on('itemUpdated', function(event) {\n   *       console.log('Received itemUpdated event: ', event);\n   *     });\n   *   })\n   *   .catch(function(error) {\n   *     console.log('Unexpected error', error);\n   *   });\n   */\n\n\n  map(arg) {\n    var _this9 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n      var opts, mapDescriptor, mapFromInMemoryCache, syncMapImpl;\n      return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n        while (1) switch (_context9.prev = _context9.next) {\n          case 0:\n            _context9.next = 2;\n            return _this9.ensureReady();\n\n          case 2:\n            opts = decompose(arg);\n\n            if (!(opts.mode === 'create_new')) {\n              _context9.next = 9;\n              break;\n            }\n\n            _context9.next = 6;\n            return _this9._createMap(opts.id, opts.ttl);\n\n          case 6:\n            mapDescriptor = _context9.sent;\n            _context9.next = 39;\n            break;\n\n          case 9:\n            mapFromInMemoryCache = _this9.getCached(opts.id, syncmap_1.SyncMap.type);\n\n            if (!mapFromInMemoryCache) {\n              _context9.next = 14;\n              break;\n            }\n\n            return _context9.abrupt(\"return\", new syncmap_1.SyncMap(mapFromInMemoryCache));\n\n          case 14:\n            _context9.prev = 14;\n            _context9.next = 17;\n            return _this9._getMap(opts.id, opts.includeItems);\n\n          case 17:\n            mapDescriptor = _context9.sent;\n            _context9.next = 39;\n            break;\n\n          case 20:\n            _context9.prev = 20;\n            _context9.t0 = _context9[\"catch\"](14);\n\n            if (!(_context9.t0.status !== 404 || opts.mode === 'open_existing')) {\n              _context9.next = 26;\n              break;\n            }\n\n            throw _context9.t0;\n\n          case 26:\n            _context9.prev = 26;\n            _context9.next = 29;\n            return _this9._createMap(opts.id, opts.ttl);\n\n          case 29:\n            mapDescriptor = _context9.sent;\n            _context9.next = 39;\n            break;\n\n          case 32:\n            _context9.prev = 32;\n            _context9.t1 = _context9[\"catch\"](26);\n\n            if (!(_context9.t1.status === 409)) {\n              _context9.next = 38;\n              break;\n            }\n\n            return _context9.abrupt(\"return\", _this9.map(arg));\n\n          case 38:\n            throw _context9.t1;\n\n          case 39:\n            _this9.storeRootInSessionCache(syncmap_1.SyncMap.type, opts.id, mapDescriptor);\n\n            syncMapImpl = new syncmap_1.SyncMapImpl(_this9.services, mapDescriptor, (type, sid, uniqueName) => _this9.removeFromCacheAndSession(type, sid, uniqueName));\n            syncMapImpl = _this9.entities.store(syncMapImpl);\n            return _context9.abrupt(\"return\", new syncmap_1.SyncMap(syncMapImpl));\n\n          case 43:\n          case \"end\":\n            return _context9.stop();\n        }\n      }, _callee9, null, [[14, 20], [26, 32]]);\n    }))();\n  }\n  /**\n   * Read or create a Sync List.\n   * @param {String | Client#OpenOptions} [arg] One of:\n   * <li>Unique name or SID identifying a Sync List - opens a List with the given identifier or creates one if it does not exist.</li>\n   * <li>none - creates a new List with a randomly assigned SID and no unique name.</li>\n   * <li>{@link Client#OpenOptions} object for more granular control.</li>\n   * @return {Promise<List>} a promise which resolves after the List is successfully read (or created).\n   * This promise may reject if the List could not be created or if this endpoint lacks the necessary permissions to access it.\n   * @public\n   * @example\n   * syncClient.list('MyList')\n   *   .then(function(list) {\n   *     console.log('Successfully opened a List. SID: ' + list.sid);\n   *     list.on('itemAdded', function(event) {\n   *       console.log('Received itemAdded event: ', event);\n   *     });\n   *   })\n   *   .catch(function(error) {\n   *     console.log('Unexpected error', error);\n   *   });\n   */\n\n\n  list(arg) {\n    var _this10 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n      var opts, listDescriptor, listFromInMemoryCache, syncListImpl;\n      return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n        while (1) switch (_context10.prev = _context10.next) {\n          case 0:\n            _context10.next = 2;\n            return _this10.ensureReady();\n\n          case 2:\n            opts = decompose(arg);\n\n            if (!(opts.mode === 'create_new')) {\n              _context10.next = 9;\n              break;\n            }\n\n            _context10.next = 6;\n            return _this10._createList(opts.id, opts.purpose, opts.context, opts.ttl);\n\n          case 6:\n            listDescriptor = _context10.sent;\n            _context10.next = 39;\n            break;\n\n          case 9:\n            listFromInMemoryCache = _this10.getCached(opts.id, synclist_1.SyncList.type);\n\n            if (!listFromInMemoryCache) {\n              _context10.next = 14;\n              break;\n            }\n\n            return _context10.abrupt(\"return\", new synclist_1.SyncList(listFromInMemoryCache));\n\n          case 14:\n            _context10.prev = 14;\n            _context10.next = 17;\n            return _this10._getList(opts.id);\n\n          case 17:\n            listDescriptor = _context10.sent;\n            _context10.next = 39;\n            break;\n\n          case 20:\n            _context10.prev = 20;\n            _context10.t0 = _context10[\"catch\"](14);\n\n            if (!(_context10.t0.status !== 404 || opts.mode === 'open_existing')) {\n              _context10.next = 26;\n              break;\n            }\n\n            throw _context10.t0;\n\n          case 26:\n            _context10.prev = 26;\n            _context10.next = 29;\n            return _this10._createList(opts.id, opts.purpose, opts.context, opts.ttl);\n\n          case 29:\n            listDescriptor = _context10.sent;\n            _context10.next = 39;\n            break;\n\n          case 32:\n            _context10.prev = 32;\n            _context10.t1 = _context10[\"catch\"](26);\n\n            if (!(_context10.t1.status === 409)) {\n              _context10.next = 38;\n              break;\n            }\n\n            return _context10.abrupt(\"return\", _this10.list(arg));\n\n          case 38:\n            throw _context10.t1;\n\n          case 39:\n            _this10.storeRootInSessionCache(synclist_1.SyncList.type, opts.id, listDescriptor);\n\n            syncListImpl = new synclist_1.SyncListImpl(_this10.services, listDescriptor, (type, sid, uniqueName) => _this10.removeFromCacheAndSession(type, sid, uniqueName));\n            syncListImpl = _this10.entities.store(syncListImpl);\n            return _context10.abrupt(\"return\", new synclist_1.SyncList(syncListImpl));\n\n          case 43:\n          case \"end\":\n            return _context10.stop();\n        }\n      }, _callee10, null, [[14, 20], [26, 32]]);\n    }))();\n  }\n  /**\n   * Read or create a Sync Message Stream.\n   * @param {String | Client#OpenOptions} [arg] One of:\n   * <li>Unique name or SID identifying a Stream - opens a Stream with the given identifier or creates one if it does not exist.</li>\n   * <li>none - creates a new Stream with a randomly assigned SID and no unique name.</li>\n   * <li>{@link Client#OpenOptions} object for more granular control.</li>\n   * @return {Promise<Stream>} a promise which resolves after the Stream is successfully read (or created).\n   * The flow of messages will begin imminently (but not necessarily immediately) upon resolution.\n   * This promise may reject if the Stream could not be created or if this endpoint lacks the necessary permissions to access it.\n   * @public\n   * @example\n   * syncClient.stream('MyStream')\n   *   .then(function(stream) {\n   *     console.log('Successfully opened a Message Stream. SID: ' + stream.sid);\n   *     stream.on('messagePublished', function(event) {\n   *       console.log('Received messagePublished event: ', event);\n   *     });\n   *   })\n   *   .catch(function(error) {\n   *     console.log('Unexpected error', error);\n   *   });\n   */\n\n\n  stream(arg) {\n    var _this11 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {\n      var opts, streamDescriptor, streamFromInMemoryCache, streamRemovalHandler, syncStreamImpl;\n      return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n        while (1) switch (_context11.prev = _context11.next) {\n          case 0:\n            _context11.next = 2;\n            return _this11.ensureReady();\n\n          case 2:\n            opts = decompose(arg);\n\n            if (!(opts.mode === 'create_new')) {\n              _context11.next = 9;\n              break;\n            }\n\n            _context11.next = 6;\n            return _this11._createStream(opts.id, opts.ttl);\n\n          case 6:\n            streamDescriptor = _context11.sent;\n            _context11.next = 39;\n            break;\n\n          case 9:\n            streamFromInMemoryCache = _this11.getCached(opts.id, syncstream_1.SyncStream.type);\n\n            if (!streamFromInMemoryCache) {\n              _context11.next = 14;\n              break;\n            }\n\n            return _context11.abrupt(\"return\", new syncstream_1.SyncStream(streamFromInMemoryCache));\n\n          case 14:\n            _context11.prev = 14;\n            _context11.next = 17;\n            return _this11._getStream(opts.id);\n\n          case 17:\n            streamDescriptor = _context11.sent;\n            _context11.next = 39;\n            break;\n\n          case 20:\n            _context11.prev = 20;\n            _context11.t0 = _context11[\"catch\"](14);\n\n            if (!(_context11.t0.status !== 404 || opts.mode === 'open_existing')) {\n              _context11.next = 26;\n              break;\n            }\n\n            throw _context11.t0;\n\n          case 26:\n            _context11.prev = 26;\n            _context11.next = 29;\n            return _this11._createStream(opts.id, opts.ttl);\n\n          case 29:\n            streamDescriptor = _context11.sent;\n            _context11.next = 39;\n            break;\n\n          case 32:\n            _context11.prev = 32;\n            _context11.t1 = _context11[\"catch\"](26);\n\n            if (!(_context11.t1.status === 409)) {\n              _context11.next = 38;\n              break;\n            }\n\n            return _context11.abrupt(\"return\", _this11.stream(arg));\n\n          case 38:\n            throw _context11.t1;\n\n          case 39:\n            _this11.storeRootInSessionCache(syncstream_1.SyncStream.type, opts.id, streamDescriptor);\n\n            streamRemovalHandler = (type, sid, uniqueName) => _this11.removeFromCacheAndSession(type, sid, uniqueName);\n\n            syncStreamImpl = new syncstream_1.SyncStreamImpl(_this11.services, streamDescriptor, streamRemovalHandler);\n            syncStreamImpl = _this11.entities.store(syncStreamImpl);\n            return _context11.abrupt(\"return\", new syncstream_1.SyncStream(syncStreamImpl));\n\n          case 44:\n          case \"end\":\n            return _context11.stop();\n        }\n      }, _callee11, null, [[14, 20], [26, 32]]);\n    }))();\n  }\n  /**\n   * Gracefully shutdown the libray\n   * Currently it is not properly implemented and being used only in tests\n   * But should be made a part of public API\n   * @private\n   */\n\n\n  shutdown() {\n    var _this12 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {\n      return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n        while (1) switch (_context12.prev = _context12.next) {\n          case 0:\n            _context12.next = 2;\n            return _this12.services.subscriptions.shutdown();\n\n          case 2:\n            _context12.next = 4;\n            return _this12.services.twilsock.disconnect();\n\n          case 4:\n          case \"end\":\n            return _context12.stop();\n        }\n      }, _callee12);\n    }))();\n  }\n  /**\n   * Set new authentication token.\n   * @param {String} token New token to set.\n   * @return {Promise<void>}\n   * @public\n   */\n\n\n  updateToken(token) {\n    if (!token) {\n      return Promise.reject(new Error('A valid Twilio token should be provided'));\n    }\n\n    return this.services.twilsock.updateToken(token);\n  }\n  /**\n   * For Flex customers only. Establishes a long-running query against Flex data wherein the returned\n   * result set is updated whenever new (or updated) records match the given expression. Updated results\n   * are presented row-by-row according to the lifetime of the returned LiveQuery object.\n   *\n   * @param indexName {String} Must specify one of the Flex data classes for which Live Queries are available.\n   * @param queryExpression {String} A query expression to be executed against the given data index.\n   * Please review <a href=\"https://www.twilio.com/docs/sync/live-query\" target=\"_blank\">Live Query Language</a>\n   * page for Sync Client limits and full list of operators currently supported in query expressions.\n   *\n   * @return {Promise<LiveQuery>} a promise that resolves when the query has been successfully executed.\n   * @public\n   * @example\n   * syncClient.liveQuery('tr-worker', 'data.attributes.worker_name == \"Bob\"')\n   *     .then(function(args) {\n   *        console.log('Subscribed to live data updates for worker Bob');\n   *        let items = args.getItems();\n   *        Object.entries(items).forEach(([key, value]) => {\n   *          console.log('Search result item key: ' + key);\n   *          console.log('Search result item value: ' + value);\n   *        });\n   *     })\n   *     .catch(function(err) {\n   *        console.log('Error when subscribing to live updates for worker Bob', err);\n   *     });\n   */\n\n\n  liveQuery(indexName, queryExpression) {\n    var _this13 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {\n      var queryUri, response, liveQueryImpl, descriptor, liveQueryRemovalHandler;\n      return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n        while (1) switch (_context13.prev = _context13.next) {\n          case 0:\n            _context13.next = 2;\n            return _this13.ensureReady();\n\n          case 2:\n            if (!(!indexName || typeof indexName !== 'string')) {\n              _context13.next = 4;\n              break;\n            }\n\n            throw new Error('Index name must contain a non-empty string value');\n\n          case 4:\n            queryUri = new uri_1.UriBuilder(_this13.services.config.insightsUri).pathSegment(indexName).pathSegment('Items').build(); // send query to CDS to get server-generated sid and item list\n\n            _context13.next = 7;\n            return livequery_2.queryItems({\n              network: _this13.services.network,\n              uri: queryUri,\n              queryString: queryExpression,\n              type: livequery_1.LiveQuery.type\n            });\n\n          case 7:\n            response = _context13.sent;\n            liveQueryImpl = _this13.getCached(response.query_id, livequery_1.LiveQuery.type);\n\n            if (!liveQueryImpl) {\n              descriptor = _this13._getLiveQuery(response.query_id);\n\n              if (!descriptor) {\n                descriptor = {\n                  indexName,\n                  queryExpression,\n                  sid: response.query_id,\n                  queryUri,\n                  last_event_id: response.last_event_id\n                };\n              }\n\n              liveQueryRemovalHandler = (type, sid, uniqueName) => _this13.removeFromCacheAndSession(type, sid, uniqueName);\n\n              liveQueryImpl = new livequery_1.LiveQueryImpl(descriptor, _this13.services, liveQueryRemovalHandler, response.items);\n            }\n\n            _this13.storeRootInSessionCache(livequery_1.LiveQuery.type, response.query_id, liveQueryImpl.liveQueryDescriptor);\n\n            liveQueryImpl = _this13.entities.store(liveQueryImpl);\n            return _context13.abrupt(\"return\", new livequery_1.LiveQuery(liveQueryImpl));\n\n          case 13:\n          case \"end\":\n            return _context13.stop();\n        }\n      }, _callee13);\n    }))();\n  }\n  /**\n   * For Flex customers only. Creates a query object that can be used to issue one-time queries repeatedly\n   * against the target index.\n   *\n   * @param indexName {String} Must specify one of the Flex data classes for which Live Queries are available.\n   * @return {Promise<InstantQuery>} a promise which resolves after the InstantQuery is successfully created.\n   * @public\n   * @example\n   * syncClient.instantQuery('tr-worker')\n   *    .then(function(q) {\n   *        q.on('searchResult', function(items) {\n   *          Object.entries(items).forEach(([key, value]) => {\n   *             console.log('Search result item key: ' + key);\n   *             console.log('Search result item value: ' + value);\n   *          });\n   *       });\n   *    });\n   */\n\n\n  instantQuery(indexName) {\n    var _this14 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14() {\n      var liveQueryCreator, search;\n      return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n        while (1) switch (_context14.prev = _context14.next) {\n          case 0:\n            _context14.next = 2;\n            return _this14.ensureReady();\n\n          case 2:\n            liveQueryCreator = (indexName, queryExpression) => {\n              return _this14.liveQuery(indexName, queryExpression);\n            };\n\n            search = new livequery_1.InstantQuery({\n              indexName,\n              network: _this14.services.network,\n              insightsUri: _this14.services.config.insightsUri,\n              liveQueryCreator\n            });\n            return _context14.abrupt(\"return\", search);\n\n          case 5:\n          case \"end\":\n            return _context14.stop();\n        }\n      }, _callee14);\n    }))();\n  }\n\n}\n\nexports.Client = Client;\nexports.SyncClient = Client;\nexports.default = Client;\n/**\n * Indicates current state of connection between the client and Sync service.\n * <p>Valid options are as follows:\n * <li>'connecting' - client is offline and connection attempt is in process.\n * <li>'connected' - client is online and ready.\n * <li>'disconnecting' - client is going offline as disconnection is in process.\n * <li>'disconnected' - client is offline and no connection attempt is in process.\n * <li>'denied' - client connection is denied because of invalid JWT access token. User must refresh token in order to proceed.\n * <li>'error' - client connection is in a permanent erroneous state. Client re-initialization is required.\n * @typedef {('connecting'|'connected'|'disconnecting'|'disconnected'|'denied'|'error')} Client#ConnectionState\n */\n\n/**\n * These options can be passed to Client constructor.\n * @typedef {Object} Client#ClientOptions\n * @property {String} [logLevel='error'] - The level of logging to enable. Valid options\n *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace'].\n */\n\n/**\n * Fired when connection state has been changed.\n * @param {Client#ConnectionState} connectionState Contains current service connection state.\n * @event Client#connectionStateChanged\n * @example\n * syncClient.on('connectionStateChanged', function(newState) {\n *   console.log('Received new connection state: ' + newState);\n * });\n */\n\n/**\n * Fired when connection is interrupted by unexpected reason\n * @property {Object} error - connection error details\n * @property {Boolean} error.terminal - twilsock will stop connection attempts\n * @property {String} error.message - root cause\n * @property {Number} [error.httpStatusCode] - http status code if available\n * @property {Number} [error.errorCode] - Twilio public error code if available\n * @event Client#connectionError\n * @example\n * syncClient.on('connectionError', function(connectionError) {\n *   console.log('Connection was interrupted: ' + connectionError.message +\n *     ' (isTerminal: ' + connectionError.terminal')');\n * });\n */\n\n/**\n * Options for opening a Sync Object.\n * @typedef {Object} Client#OpenOptions\n * @property {String} [id] Sync object SID or unique name.\n * @property {'open_or_create' | 'open_existing' | 'create_new'} [mode='open_or_create'] - The mode for opening the Sync object:\n * <li>'open_or_create' - reads a Sync object or creates one if it does not exist.\n * <li>'open_existing' - reads an existing Sync object. The promise is rejected if the object does not exist.\n * <li>'create_new' - creates a new Sync object. If the <i>id</i> property is specified, it will be used as the unique name.\n * @property {Number} [ttl] - The time-to-live of the Sync object in seconds. This is applied only if the object is created.\n * @property {Object} [value={ }] - The initial value for the Sync Document (only applicable to Documents).\n * @example <caption>The following example is applicable to all Sync objects\n * (i.e., <code>syncClient.document(), syncClient.list(), syncClient.map(), syncClient.stream()</code>)</caption>\n * // Attempts to open an existing Document with unique name 'MyDocument'\n * // If no such Document exists, the promise is rejected\n * syncClient.document({\n *     id: 'MyDocument',\n *     mode: 'open_existing'\n *   })\n *   .then(...)\n *   .catch(...);\n *\n * // Attempts to create a new Document with unique name 'MyDocument', TTL of 24 hours and initial value { name: 'John Smith' }\n * // If such a Document already exists, the promise is rejected\n * syncClient.document({\n *     id: 'MyDocument',\n *     mode: 'create_new',\n *     ttl: 86400\n *     value: { name: 'John Smith' } // the `value` property is only applicable for Documents\n *   })\n *   .then(...)\n *   .catch(...);\n */\n\n/**\n * Fired when the access token is about to expire and needs to be updated.\n * The trigger takes place three minutes before the JWT access token expiry.\n * For long living applications, you should refresh the token when either <code>tokenAboutToExpire</code> or\n * <code>tokenExpired</code> events occur; handling just one of them is sufficient.\n * @event Client#tokenAboutToExpire\n * @type {void}\n * @example <caption>The following example illustrates access token refresh</caption>\n * syncClient.on('tokenAboutToExpire', function() {\n *   // Obtain a JWT access token: https://www.twilio.com/docs/sync/identity-and-access-tokens\n *   var token = '<your-access-token-here>';\n *   syncClient.updateToken(token);\n * });\n */\n\n/**\n * Fired when the access token is expired.\n * In case the token is not refreshed, all subsequent Sync operations will fail and the client will disconnect.\n * For long living applications, you should refresh the token when either <code>tokenAboutToExpire</code> or\n * <code>tokenExpired</code> events occur; handling just one of them is sufficient.\n * @event Client#tokenExpired\n * @type {void}\n */","map":{"version":3,"sources":["C:/Users/khouloud/Documents/PI/MERN_Stack_PI/node_modules/twilio-sync/lib/client.js"],"names":["Object","defineProperty","exports","value","events_1","require","twilsock_1","twilio_notifications_1","uri_1","syncerror_1","sanitize_1","logger_1","configuration_1","subscriptions_1","router_1","network_1","syncdocument_1","synclist_1","syncmap_1","clientInfo_1","entitiesCache_1","storage_1","syncstream_1","livequery_1","livequery_2","SYNC_PRODUCT_ID","SDK_VERSION","version","decompose","arg","mode","id","validateOptionalTtl","ttl","validateId","assign","Client","EventEmitter","constructor","fpaToken","options","Error","hasOwnProperty","default","setLevel","logLevel","productId","clientMetadata","type","sdk","sdkv","twilsock","twilsockClient","Twilsock","on","emit","err","notifications","notificationsClient","Notifications","config","Configuration","network","NetworkService","ClientInfo","storage","SessionStorage","localStorageId","connect","services","router","subscriptions","Subscriptions","Router","entities","EntitiesCache","connectionState","ensureReady","sessionStorageEnabled","storageId","storageSettings","updateStorageId","warn","storeRootInSessionCache","valueToStore","deepClone","SyncList","SyncMap","store","readRootFromSessionCache","read","_get","baseUri","optimistic","SyncError","uri","UriBuilder","pathSegment","queryParam","undefined","build","get","response","body","_createDocument","data","requestBody","unique_name","post","documentsUri","then","_getDocument","SyncDocument","_createList","purpose","context","listsUri","_getList","_createMap","mapsUri","_getMap","_getStream","SyncStream","streamsUri","_createStream","_getLiveQuery","sid","LiveQuery","getCached","removeFromCacheAndSession","uniqueName","remove","document","opts","docDescriptor","docFromInMemoryCache","status","syncDocumentImpl","SyncDocumentImpl","map","mapDescriptor","mapFromInMemoryCache","includeItems","syncMapImpl","SyncMapImpl","list","listDescriptor","listFromInMemoryCache","syncListImpl","SyncListImpl","stream","streamDescriptor","streamFromInMemoryCache","streamRemovalHandler","syncStreamImpl","SyncStreamImpl","shutdown","disconnect","updateToken","token","Promise","reject","liveQuery","indexName","queryExpression","queryUri","insightsUri","queryItems","queryString","liveQueryImpl","query_id","descriptor","last_event_id","liveQueryRemovalHandler","LiveQueryImpl","items","liveQueryDescriptor","instantQuery","liveQueryCreator","search","InstantQuery","SyncClient"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nconst twilsock_1 = require(\"twilsock\");\nconst twilio_notifications_1 = require(\"twilio-notifications\");\nconst uri_1 = require(\"./utils/uri\");\nconst syncerror_1 = require(\"./utils/syncerror\");\nconst sanitize_1 = require(\"./utils/sanitize\");\nconst logger_1 = require(\"./utils/logger\");\nconst configuration_1 = require(\"./configuration\");\nconst subscriptions_1 = require(\"./subscriptions\");\nconst router_1 = require(\"./router\");\nconst network_1 = require(\"./services/network\");\nconst syncdocument_1 = require(\"./syncdocument\");\nconst synclist_1 = require(\"./synclist\");\nconst syncmap_1 = require(\"./syncmap\");\nconst clientInfo_1 = require(\"./clientInfo\");\nconst entitiesCache_1 = require(\"./entitiesCache\");\nconst storage_1 = require(\"./services/storage\");\nconst syncstream_1 = require(\"./streams/syncstream\");\nconst livequery_1 = require(\"./livequery\");\nconst livequery_2 = require(\"./livequery\");\nconst SYNC_PRODUCT_ID = 'data_sync';\nconst SDK_VERSION = require('../package.json').version;\nfunction decompose(arg) {\n    if (!arg) {\n        return { mode: 'create_new' };\n    }\n    else if (typeof arg === 'string') {\n        return { id: arg, mode: 'open_or_create' };\n    }\n    else {\n        sanitize_1.validateOptionalTtl(arg.ttl);\n        sanitize_1.validateId(arg.id);\n        let mode = arg.mode || (arg.id ? 'open_or_create' : 'create_new');\n        return Object.assign(Object.assign({}, arg), { mode: mode });\n    }\n}\n/**\n * @class Client\n * @classdesc\n * Client for the Twilio Sync service.\n * @constructor\n * @param {String} token - Twilio access token.\n * @param {Client#ClientOptions} [options] - Options to customize the Client.\n * @example\n * // Using NPM\n * var SyncClient = require('twilio-sync');\n * var syncClient = new SyncClient(token, { logLevel: 'debug' });\n *\n * // Using CDN\n * var SyncClient = new Twilio.Sync.Client(token, { logLevel: 'debug' });\n *\n * @property {Client#ConnectionState} connectionState - Contains current service connection state.\n * Valid options are ['connecting', 'connected', 'disconnecting', 'disconnected', 'denied', 'error'].\n */\nclass Client extends events_1.EventEmitter {\n    constructor(fpaToken, options = {}) {\n        super();\n        if (!fpaToken) {\n            throw new Error('Sync library needs a valid Twilio token to be passed');\n        }\n        if (options.hasOwnProperty('logLevel')) {\n            logger_1.default.setLevel(options.logLevel);\n        }\n        else {\n            logger_1.default.setLevel('silent');\n        }\n        const productId = options.productId = options.productId || SYNC_PRODUCT_ID;\n        // Filling ClientMetadata\n        options.clientMetadata = options.clientMetadata || {};\n        if (!options.clientMetadata.hasOwnProperty('type')) {\n            options.clientMetadata.type = SYNC_PRODUCT_ID;\n        }\n        if (!options.clientMetadata.hasOwnProperty('sdk')) {\n            options.clientMetadata.sdk = 'JS';\n            options.clientMetadata.sdkv = SDK_VERSION;\n        }\n        let twilsock = options.twilsockClient = options.twilsockClient || new twilsock_1.Twilsock(fpaToken, productId, options);\n        twilsock.on('tokenAboutToExpire', ttl => this.emit('tokenAboutToExpire', ttl));\n        twilsock.on('tokenExpired', () => this.emit('tokenExpired'));\n        twilsock.on('connectionError', err => this.emit('connectionError', err));\n        let notifications = options.notificationsClient = options.notificationsClient || new twilio_notifications_1.Notifications(fpaToken, options);\n        let config = new configuration_1.Configuration(options);\n        let network = new network_1.NetworkService(new clientInfo_1.ClientInfo(SDK_VERSION), config, twilsock);\n        let storage = new storage_1.SessionStorage(config);\n        this.localStorageId = null;\n        twilsock.connect();\n        this.services = {\n            config,\n            twilsock,\n            notifications,\n            network,\n            storage,\n            router: null,\n            subscriptions: null\n        };\n        let subscriptions = new subscriptions_1.Subscriptions(this.services);\n        let router = new router_1.Router({ config, subscriptions, notifications });\n        this.services.router = router;\n        this.services.subscriptions = subscriptions;\n        this.entities = new entitiesCache_1.EntitiesCache();\n        notifications.on('connectionStateChanged', () => {\n            this.emit('connectionStateChanged', this.services.notifications.connectionState);\n        });\n    }\n    /**\n     * Current version of Sync client.\n     * @name Client#version\n     * @type String\n     * @readonly\n     */\n    static get version() {\n        return SDK_VERSION;\n    }\n    get connectionState() {\n        return this.services.notifications.connectionState;\n    }\n    /**\n     * Returns promise which resolves when library is correctly initialized\n     * Or throws if initialization is impossible\n     * @private\n     */\n    async ensureReady() {\n        if (!this.services.config.sessionStorageEnabled) {\n            return;\n        }\n        try {\n            let storageSettings = await this.services.twilsock.storageId();\n            this.services.storage.updateStorageId(storageSettings.id);\n        }\n        catch (e) {\n            logger_1.default.warn('Failed to initialize storage', e);\n        }\n    }\n    storeRootInSessionCache(type, id, value) {\n        // can't store without id\n        if (!this.services.config.sessionStorageEnabled || !id) {\n            return;\n        }\n        let valueToStore = sanitize_1.deepClone(value);\n        if (type === synclist_1.SyncList.type || type === syncmap_1.SyncMap.type) {\n            valueToStore['last_event_id'] = null;\n            delete valueToStore['items'];\n        }\n        this.services.storage.store(type, id, valueToStore);\n    }\n    readRootFromSessionCache(type, id) {\n        if (!this.services.config.sessionStorageEnabled || !id) {\n            return null;\n        }\n        return this.services.storage.read(type, id);\n    }\n    async _get(baseUri, id, optimistic = false) {\n        if (!id) {\n            throw new syncerror_1.SyncError(`Cannot get entity without id`, 404);\n        }\n        const uri = new uri_1.UriBuilder(baseUri).pathSegment(id)\n            .queryParam('Include', optimistic ? 'items' : undefined).build();\n        let response = await this.services.network.get(uri);\n        return response.body;\n    }\n    _createDocument(id, data, ttl) {\n        const requestBody = {\n            unique_name: id,\n            data: data || {}\n        };\n        if (ttl !== undefined) {\n            requestBody.ttl = ttl;\n        }\n        return this.services.network.post(this.services.config.documentsUri, requestBody)\n            .then(response => {\n            response.body.data = requestBody.data;\n            return response.body;\n        });\n    }\n    async _getDocument(id) {\n        return (this.readRootFromSessionCache(syncdocument_1.SyncDocument.type, id) || this._get(this.services.config.documentsUri, id));\n    }\n    _createList(id, purpose, context, ttl) {\n        const requestBody = {\n            unique_name: id,\n            purpose: purpose,\n            context: context\n        };\n        if (ttl !== undefined) {\n            requestBody.ttl = ttl;\n        }\n        return this.services.network.post(this.services.config.listsUri, requestBody).then(response => response.body);\n    }\n    async _getList(id) {\n        return (this.readRootFromSessionCache(synclist_1.SyncList.type, id) || this._get(this.services.config.listsUri, id));\n    }\n    _createMap(id, ttl) {\n        const requestBody = {\n            unique_name: id\n        };\n        if (ttl !== undefined) {\n            requestBody.ttl = ttl;\n        }\n        return this.services.network.post(this.services.config.mapsUri, requestBody).then(response => response.body);\n    }\n    async _getMap(id, optimistic = false) {\n        return (this.readRootFromSessionCache(syncmap_1.SyncMap.type, id) || this._get(this.services.config.mapsUri, id, optimistic));\n    }\n    async _getStream(id) {\n        return (this.readRootFromSessionCache(syncstream_1.SyncStream.type, id) || this._get(this.services.config.streamsUri, id, false));\n    }\n    async _createStream(id, ttl) {\n        const requestBody = {\n            unique_name: id\n        };\n        if (ttl !== undefined) {\n            requestBody.ttl = ttl;\n        }\n        const response = await this.services.network.post(this.services.config.streamsUri, requestBody);\n        return response.body;\n    }\n    _getLiveQuery(sid) {\n        return this.readRootFromSessionCache(livequery_1.LiveQuery.type, sid);\n    }\n    getCached(id, type) {\n        if (id) {\n            return this.entities.get(id, type) || null;\n        }\n        return null;\n    }\n    removeFromCacheAndSession(type, sid, uniqueName) {\n        this.entities.remove(sid);\n        if (this.services.config.sessionStorageEnabled) {\n            this.services.storage.remove(type, sid, uniqueName);\n        }\n    }\n    /**\n     * Read or create a Sync Document.\n     * @param {String | Client#OpenOptions} [arg] One of:\n     * <li>Unique name or SID identifying a Sync Document - opens a Document with the given identifier or creates one if it does not exist.</li>\n     * <li>none - creates a new Document with a randomly assigned SID and no unique name.</li>\n     * <li>{@link Client#OpenOptions} object for more granular control.</li>\n     * @return {Promise<Document>} a promise which resolves after the Document is successfully read (or created).\n     * This promise may reject if the Document could not be created or if this endpoint lacks the necessary permissions to access it.\n     * @public\n     * @example\n     * syncClient.document('MyDocument')\n     *   .then(function(document) {\n     *     console.log('Successfully opened a Document. SID: ' + document.sid);\n     *     document.on('updated', function(event) {\n     *       console.log('Received updated event: ', event);\n     *     });\n     *   })\n     *   .catch(function(error) {\n     *     console.log('Unexpected error', error);\n     *   });\n     */\n    async document(arg) {\n        await this.ensureReady();\n        let opts = decompose(arg);\n        let docDescriptor;\n        if (opts.mode === 'create_new') {\n            docDescriptor = await this._createDocument(opts.id, opts.value, opts.ttl);\n        }\n        else {\n            let docFromInMemoryCache = this.getCached(opts.id, syncdocument_1.SyncDocument.type);\n            if (docFromInMemoryCache) {\n                return new syncdocument_1.SyncDocument(docFromInMemoryCache);\n            }\n            else {\n                try {\n                    docDescriptor = await this._getDocument(opts.id);\n                }\n                catch (err) {\n                    if (err.status !== 404 || opts.mode === 'open_existing') {\n                        throw err;\n                    }\n                    else {\n                        try {\n                            docDescriptor = await this._createDocument(opts.id, opts.value, opts.ttl);\n                        }\n                        catch (err) {\n                            if (err.status === 409) {\n                                return this.document(arg);\n                            }\n                            else {\n                                throw err;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        this.storeRootInSessionCache(syncdocument_1.SyncDocument.type, opts.id, docDescriptor);\n        let syncDocumentImpl = new syncdocument_1.SyncDocumentImpl(this.services, docDescriptor, (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName));\n        syncDocumentImpl = this.entities.store(syncDocumentImpl);\n        return new syncdocument_1.SyncDocument(syncDocumentImpl);\n    }\n    /**\n     * Read or create a Sync Map.\n     * @param {String | Client#OpenOptions} [arg] One of:\n     * <li>Unique name or SID identifying a Sync Map - opens a Map with the given identifier or creates one if it does not exist.</li>\n     * <li>none - creates a new Map with a randomly assigned SID and no unique name.</li>\n     * <li>{@link Client#OpenOptions} object for more granular control.</li>\n     * @return {Promise<Map>} a promise which resolves after the Map is successfully read (or created).\n     * This promise may reject if the Map could not be created or if this endpoint lacks the necessary permissions to access it.\n     * @public\n     * @example\n     * syncClient.map('MyMap')\n     *   .then(function(map) {\n     *     console.log('Successfully opened a Map. SID: ' + map.sid);\n     *     map.on('itemUpdated', function(event) {\n     *       console.log('Received itemUpdated event: ', event);\n     *     });\n     *   })\n     *   .catch(function(error) {\n     *     console.log('Unexpected error', error);\n     *   });\n     */\n    async map(arg) {\n        await this.ensureReady();\n        let opts = decompose(arg);\n        let mapDescriptor;\n        if (opts.mode === 'create_new') {\n            mapDescriptor = await this._createMap(opts.id, opts.ttl);\n        }\n        else {\n            let mapFromInMemoryCache = this.getCached(opts.id, syncmap_1.SyncMap.type);\n            if (mapFromInMemoryCache) {\n                return new syncmap_1.SyncMap(mapFromInMemoryCache);\n            }\n            else {\n                try {\n                    mapDescriptor = await this._getMap(opts.id, opts.includeItems);\n                }\n                catch (err) {\n                    if (err.status !== 404 || opts.mode === 'open_existing') {\n                        throw err;\n                    }\n                    else {\n                        try {\n                            mapDescriptor = await this._createMap(opts.id, opts.ttl);\n                        }\n                        catch (err) {\n                            if (err.status === 409) {\n                                return this.map(arg);\n                            }\n                            else {\n                                throw err;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        this.storeRootInSessionCache(syncmap_1.SyncMap.type, opts.id, mapDescriptor);\n        let syncMapImpl = new syncmap_1.SyncMapImpl(this.services, mapDescriptor, (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName));\n        syncMapImpl = this.entities.store(syncMapImpl);\n        return new syncmap_1.SyncMap(syncMapImpl);\n    }\n    /**\n     * Read or create a Sync List.\n     * @param {String | Client#OpenOptions} [arg] One of:\n     * <li>Unique name or SID identifying a Sync List - opens a List with the given identifier or creates one if it does not exist.</li>\n     * <li>none - creates a new List with a randomly assigned SID and no unique name.</li>\n     * <li>{@link Client#OpenOptions} object for more granular control.</li>\n     * @return {Promise<List>} a promise which resolves after the List is successfully read (or created).\n     * This promise may reject if the List could not be created or if this endpoint lacks the necessary permissions to access it.\n     * @public\n     * @example\n     * syncClient.list('MyList')\n     *   .then(function(list) {\n     *     console.log('Successfully opened a List. SID: ' + list.sid);\n     *     list.on('itemAdded', function(event) {\n     *       console.log('Received itemAdded event: ', event);\n     *     });\n     *   })\n     *   .catch(function(error) {\n     *     console.log('Unexpected error', error);\n     *   });\n     */\n    async list(arg) {\n        await this.ensureReady();\n        let opts = decompose(arg);\n        let listDescriptor;\n        if (opts.mode === 'create_new') {\n            listDescriptor = await this._createList(opts.id, opts.purpose, opts.context, opts.ttl);\n        }\n        else {\n            let listFromInMemoryCache = this.getCached(opts.id, synclist_1.SyncList.type);\n            if (listFromInMemoryCache) {\n                return new synclist_1.SyncList(listFromInMemoryCache);\n            }\n            else {\n                try {\n                    listDescriptor = await this._getList(opts.id);\n                }\n                catch (err) {\n                    if (err.status !== 404 || opts.mode === 'open_existing') {\n                        throw err;\n                    }\n                    else {\n                        try {\n                            listDescriptor = await this._createList(opts.id, opts.purpose, opts.context, opts.ttl);\n                        }\n                        catch (err) {\n                            if (err.status === 409) {\n                                return this.list(arg);\n                            }\n                            else {\n                                throw err;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        this.storeRootInSessionCache(synclist_1.SyncList.type, opts.id, listDescriptor);\n        let syncListImpl = new synclist_1.SyncListImpl(this.services, listDescriptor, (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName));\n        syncListImpl = this.entities.store(syncListImpl);\n        return new synclist_1.SyncList(syncListImpl);\n    }\n    /**\n     * Read or create a Sync Message Stream.\n     * @param {String | Client#OpenOptions} [arg] One of:\n     * <li>Unique name or SID identifying a Stream - opens a Stream with the given identifier or creates one if it does not exist.</li>\n     * <li>none - creates a new Stream with a randomly assigned SID and no unique name.</li>\n     * <li>{@link Client#OpenOptions} object for more granular control.</li>\n     * @return {Promise<Stream>} a promise which resolves after the Stream is successfully read (or created).\n     * The flow of messages will begin imminently (but not necessarily immediately) upon resolution.\n     * This promise may reject if the Stream could not be created or if this endpoint lacks the necessary permissions to access it.\n     * @public\n     * @example\n     * syncClient.stream('MyStream')\n     *   .then(function(stream) {\n     *     console.log('Successfully opened a Message Stream. SID: ' + stream.sid);\n     *     stream.on('messagePublished', function(event) {\n     *       console.log('Received messagePublished event: ', event);\n     *     });\n     *   })\n     *   .catch(function(error) {\n     *     console.log('Unexpected error', error);\n     *   });\n     */\n    async stream(arg) {\n        await this.ensureReady();\n        let opts = decompose(arg);\n        let streamDescriptor;\n        if (opts.mode === 'create_new') {\n            streamDescriptor = await this._createStream(opts.id, opts.ttl);\n        }\n        else {\n            let streamFromInMemoryCache = this.getCached(opts.id, syncstream_1.SyncStream.type);\n            if (streamFromInMemoryCache) {\n                return new syncstream_1.SyncStream(streamFromInMemoryCache);\n            }\n            else {\n                try {\n                    streamDescriptor = await this._getStream(opts.id);\n                }\n                catch (err) {\n                    if (err.status !== 404 || opts.mode === 'open_existing') {\n                        throw err;\n                    }\n                    else {\n                        try {\n                            streamDescriptor = await this._createStream(opts.id, opts.ttl);\n                        }\n                        catch (err) {\n                            if (err.status === 409) {\n                                return this.stream(arg);\n                            }\n                            else {\n                                throw err;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        this.storeRootInSessionCache(syncstream_1.SyncStream.type, opts.id, streamDescriptor);\n        const streamRemovalHandler = (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName);\n        let syncStreamImpl = new syncstream_1.SyncStreamImpl(this.services, streamDescriptor, streamRemovalHandler);\n        syncStreamImpl = this.entities.store(syncStreamImpl);\n        return new syncstream_1.SyncStream(syncStreamImpl);\n    }\n    /**\n     * Gracefully shutdown the libray\n     * Currently it is not properly implemented and being used only in tests\n     * But should be made a part of public API\n     * @private\n     */\n    async shutdown() {\n        await this.services.subscriptions.shutdown();\n        await this.services.twilsock.disconnect();\n    }\n    /**\n     * Set new authentication token.\n     * @param {String} token New token to set.\n     * @return {Promise<void>}\n     * @public\n     */\n    updateToken(token) {\n        if (!token) {\n            return Promise.reject(new Error('A valid Twilio token should be provided'));\n        }\n        return this.services.twilsock.updateToken(token);\n    }\n    /**\n     * For Flex customers only. Establishes a long-running query against Flex data wherein the returned\n     * result set is updated whenever new (or updated) records match the given expression. Updated results\n     * are presented row-by-row according to the lifetime of the returned LiveQuery object.\n     *\n     * @param indexName {String} Must specify one of the Flex data classes for which Live Queries are available.\n     * @param queryExpression {String} A query expression to be executed against the given data index.\n     * Please review <a href=\"https://www.twilio.com/docs/sync/live-query\" target=\"_blank\">Live Query Language</a>\n     * page for Sync Client limits and full list of operators currently supported in query expressions.\n     *\n     * @return {Promise<LiveQuery>} a promise that resolves when the query has been successfully executed.\n     * @public\n     * @example\n     * syncClient.liveQuery('tr-worker', 'data.attributes.worker_name == \"Bob\"')\n     *     .then(function(args) {\n     *        console.log('Subscribed to live data updates for worker Bob');\n     *        let items = args.getItems();\n     *        Object.entries(items).forEach(([key, value]) => {\n     *          console.log('Search result item key: ' + key);\n     *          console.log('Search result item value: ' + value);\n     *        });\n     *     })\n     *     .catch(function(err) {\n     *        console.log('Error when subscribing to live updates for worker Bob', err);\n     *     });\n     */\n    async liveQuery(indexName, queryExpression) {\n        await this.ensureReady();\n        if (!indexName || typeof indexName !== 'string') {\n            throw new Error('Index name must contain a non-empty string value');\n        }\n        let queryUri = new uri_1.UriBuilder(this.services.config.insightsUri)\n            .pathSegment(indexName)\n            .pathSegment('Items')\n            .build();\n        // send query to CDS to get server-generated sid and item list\n        let response = await livequery_2.queryItems({\n            network: this.services.network,\n            uri: queryUri,\n            queryString: queryExpression,\n            type: livequery_1.LiveQuery.type\n        });\n        let liveQueryImpl = this.getCached(response.query_id, livequery_1.LiveQuery.type);\n        if (!liveQueryImpl) {\n            let descriptor = this._getLiveQuery(response.query_id);\n            if (!descriptor) {\n                descriptor = {\n                    indexName,\n                    queryExpression,\n                    sid: response.query_id,\n                    queryUri,\n                    last_event_id: response.last_event_id\n                };\n            }\n            const liveQueryRemovalHandler = (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName);\n            liveQueryImpl = new livequery_1.LiveQueryImpl(descriptor, this.services, liveQueryRemovalHandler, response.items);\n        }\n        this.storeRootInSessionCache(livequery_1.LiveQuery.type, response.query_id, liveQueryImpl.liveQueryDescriptor);\n        liveQueryImpl = this.entities.store(liveQueryImpl);\n        return new livequery_1.LiveQuery(liveQueryImpl);\n    }\n    /**\n     * For Flex customers only. Creates a query object that can be used to issue one-time queries repeatedly\n     * against the target index.\n     *\n     * @param indexName {String} Must specify one of the Flex data classes for which Live Queries are available.\n     * @return {Promise<InstantQuery>} a promise which resolves after the InstantQuery is successfully created.\n     * @public\n     * @example\n     * syncClient.instantQuery('tr-worker')\n     *    .then(function(q) {\n     *        q.on('searchResult', function(items) {\n     *          Object.entries(items).forEach(([key, value]) => {\n     *             console.log('Search result item key: ' + key);\n     *             console.log('Search result item value: ' + value);\n     *          });\n     *       });\n     *    });\n     */\n    async instantQuery(indexName) {\n        await this.ensureReady();\n        let liveQueryCreator = (indexName, queryExpression) => {\n            return this.liveQuery(indexName, queryExpression);\n        };\n        const search = new livequery_1.InstantQuery({\n            indexName,\n            network: this.services.network,\n            insightsUri: this.services.config.insightsUri,\n            liveQueryCreator\n        });\n        return search;\n    }\n}\nexports.Client = Client;\nexports.SyncClient = Client;\nexports.default = Client;\n/**\n * Indicates current state of connection between the client and Sync service.\n * <p>Valid options are as follows:\n * <li>'connecting' - client is offline and connection attempt is in process.\n * <li>'connected' - client is online and ready.\n * <li>'disconnecting' - client is going offline as disconnection is in process.\n * <li>'disconnected' - client is offline and no connection attempt is in process.\n * <li>'denied' - client connection is denied because of invalid JWT access token. User must refresh token in order to proceed.\n * <li>'error' - client connection is in a permanent erroneous state. Client re-initialization is required.\n * @typedef {('connecting'|'connected'|'disconnecting'|'disconnected'|'denied'|'error')} Client#ConnectionState\n */\n/**\n * These options can be passed to Client constructor.\n * @typedef {Object} Client#ClientOptions\n * @property {String} [logLevel='error'] - The level of logging to enable. Valid options\n *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace'].\n */\n/**\n * Fired when connection state has been changed.\n * @param {Client#ConnectionState} connectionState Contains current service connection state.\n * @event Client#connectionStateChanged\n * @example\n * syncClient.on('connectionStateChanged', function(newState) {\n *   console.log('Received new connection state: ' + newState);\n * });\n */\n/**\n * Fired when connection is interrupted by unexpected reason\n * @property {Object} error - connection error details\n * @property {Boolean} error.terminal - twilsock will stop connection attempts\n * @property {String} error.message - root cause\n * @property {Number} [error.httpStatusCode] - http status code if available\n * @property {Number} [error.errorCode] - Twilio public error code if available\n * @event Client#connectionError\n * @example\n * syncClient.on('connectionError', function(connectionError) {\n *   console.log('Connection was interrupted: ' + connectionError.message +\n *     ' (isTerminal: ' + connectionError.terminal')');\n * });\n */\n/**\n * Options for opening a Sync Object.\n * @typedef {Object} Client#OpenOptions\n * @property {String} [id] Sync object SID or unique name.\n * @property {'open_or_create' | 'open_existing' | 'create_new'} [mode='open_or_create'] - The mode for opening the Sync object:\n * <li>'open_or_create' - reads a Sync object or creates one if it does not exist.\n * <li>'open_existing' - reads an existing Sync object. The promise is rejected if the object does not exist.\n * <li>'create_new' - creates a new Sync object. If the <i>id</i> property is specified, it will be used as the unique name.\n * @property {Number} [ttl] - The time-to-live of the Sync object in seconds. This is applied only if the object is created.\n * @property {Object} [value={ }] - The initial value for the Sync Document (only applicable to Documents).\n * @example <caption>The following example is applicable to all Sync objects\n * (i.e., <code>syncClient.document(), syncClient.list(), syncClient.map(), syncClient.stream()</code>)</caption>\n * // Attempts to open an existing Document with unique name 'MyDocument'\n * // If no such Document exists, the promise is rejected\n * syncClient.document({\n *     id: 'MyDocument',\n *     mode: 'open_existing'\n *   })\n *   .then(...)\n *   .catch(...);\n *\n * // Attempts to create a new Document with unique name 'MyDocument', TTL of 24 hours and initial value { name: 'John Smith' }\n * // If such a Document already exists, the promise is rejected\n * syncClient.document({\n *     id: 'MyDocument',\n *     mode: 'create_new',\n *     ttl: 86400\n *     value: { name: 'John Smith' } // the `value` property is only applicable for Documents\n *   })\n *   .then(...)\n *   .catch(...);\n */\n/**\n * Fired when the access token is about to expire and needs to be updated.\n * The trigger takes place three minutes before the JWT access token expiry.\n * For long living applications, you should refresh the token when either <code>tokenAboutToExpire</code> or\n * <code>tokenExpired</code> events occur; handling just one of them is sufficient.\n * @event Client#tokenAboutToExpire\n * @type {void}\n * @example <caption>The following example illustrates access token refresh</caption>\n * syncClient.on('tokenAboutToExpire', function() {\n *   // Obtain a JWT access token: https://www.twilio.com/docs/sync/identity-and-access-tokens\n *   var token = '<your-access-token-here>';\n *   syncClient.updateToken(token);\n * });\n */\n/**\n * Fired when the access token is expired.\n * In case the token is not refreshed, all subsequent Sync operations will fail and the client will disconnect.\n * For long living applications, you should refresh the token when either <code>tokenAboutToExpire</code> or\n * <code>tokenExpired</code> events occur; handling just one of them is sufficient.\n * @event Client#tokenExpired\n * @type {void}\n */\n"]},"metadata":{},"sourceType":"script"}