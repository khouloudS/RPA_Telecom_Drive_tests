{"ast":null,"code":"'use strict';\n\nconst Limiter = require('async-limiter');\n\nconst zlib = require('zlib');\n\nconst bufferUtil = require('./buffer-util');\n\nconst constants = require('./constants');\n\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\nconst EMPTY_BLOCK = Buffer.from([0x00]);\nconst kPerMessageDeflate = Symbol('permessage-deflate');\nconst kWriteInProgress = Symbol('write-in-progress');\nconst kPendingClose = Symbol('pending-close');\nconst kTotalLength = Symbol('total-length');\nconst kCallback = Symbol('callback');\nconst kBuffers = Symbol('buffers');\nconst kError = Symbol('error'); //\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\n\nlet zlibLimiter;\n/**\r\n * permessage-deflate implementation.\r\n */\n\nclass PerMessageDeflate {\n  /**\r\n   * Creates a PerMessageDeflate instance.\r\n   *\r\n   * @param {Object} options Configuration options\r\n   * @param {Boolean} options.serverNoContextTakeover Request/accept disabling\r\n   *     of server context takeover\r\n   * @param {Boolean} options.clientNoContextTakeover Advertise/acknowledge\r\n   *     disabling of client context takeover\r\n   * @param {(Boolean|Number)} options.serverMaxWindowBits Request/confirm the\r\n   *     use of a custom server window size\r\n   * @param {(Boolean|Number)} options.clientMaxWindowBits Advertise support\r\n   *     for, or request, a custom client window size\r\n   * @param {Object} options.zlibDeflateOptions Options to pass to zlib on deflate\r\n   * @param {Object} options.zlibInflateOptions Options to pass to zlib on inflate\r\n   * @param {Number} options.threshold Size (in bytes) below which messages\r\n   *     should not be compressed\r\n   * @param {Number} options.concurrencyLimit The number of concurrent calls to\r\n   *     zlib\r\n   * @param {Boolean} isServer Create the instance in either server or client\r\n   *     mode\r\n   * @param {Number} maxPayload The maximum allowed message length\r\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n    this.params = null;\n\n    if (!zlibLimiter) {\n      const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;\n      zlibLimiter = new Limiter({\n        concurrency\n      });\n    }\n  }\n  /**\r\n   * @type {String}\r\n   */\n\n\n  static get extensionName() {\n    return 'permessage-deflate';\n  }\n  /**\r\n   * Create an extension negotiation offer.\r\n   *\r\n   * @return {Object} Extension parameters\r\n   * @public\r\n   */\n\n\n  offer() {\n    const params = {};\n\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n\n    return params;\n  }\n  /**\r\n   * Accept an extension negotiation offer/response.\r\n   *\r\n   * @param {Array} configurations The extension negotiation offers/reponse\r\n   * @return {Object} Accepted configuration\r\n   * @public\r\n   */\n\n\n  accept(configurations) {\n    configurations = this.normalizeParams(configurations);\n    this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);\n    return this.params;\n  }\n  /**\r\n   * Releases all resources used by the extension.\r\n   *\r\n   * @public\r\n   */\n\n\n  cleanup() {\n    if (this._inflate) {\n      if (this._inflate[kWriteInProgress]) {\n        this._inflate[kPendingClose] = true;\n      } else {\n        this._inflate.close();\n\n        this._inflate = null;\n      }\n    }\n\n    if (this._deflate) {\n      if (this._deflate[kWriteInProgress]) {\n        this._deflate[kPendingClose] = true;\n      } else {\n        this._deflate.close();\n\n        this._deflate = null;\n      }\n    }\n  }\n  /**\r\n   *  Accept an extension negotiation offer.\r\n   *\r\n   * @param {Array} offers The extension negotiation offers\r\n   * @return {Object} Accepted configuration\r\n   * @private\r\n   */\n\n\n  acceptAsServer(offers) {\n    const opts = this._options;\n    const accepted = offers.find(params => {\n      if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === 'number' && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === 'number' && !params.client_max_window_bits) {\n        return false;\n      }\n\n      return true;\n    });\n\n    if (!accepted) {\n      throw new Error('None of the extension offers can be accepted');\n    }\n\n    if (opts.serverNoContextTakeover) {\n      accepted.server_no_context_takeover = true;\n    }\n\n    if (opts.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n\n    if (typeof opts.serverMaxWindowBits === 'number') {\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\n    }\n\n    if (typeof opts.clientMaxWindowBits === 'number') {\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\n    } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {\n      delete accepted.client_max_window_bits;\n    }\n\n    return accepted;\n  }\n  /**\r\n   * Accept the extension negotiation response.\r\n   *\r\n   * @param {Array} response The extension negotiation response\r\n   * @return {Object} Accepted configuration\r\n   * @private\r\n   */\n\n\n  acceptAsClient(response) {\n    const params = response[0];\n\n    if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    }\n\n    if (!params.client_max_window_bits) {\n      if (typeof this._options.clientMaxWindowBits === 'number') {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      }\n    } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === 'number' && params.client_max_window_bits > this._options.clientMaxWindowBits) {\n      throw new Error('Unexpected or invalid parameter \"client_max_window_bits\"');\n    }\n\n    return params;\n  }\n  /**\r\n   * Normalize parameters.\r\n   *\r\n   * @param {Array} configurations The extension negotiation offers/reponse\r\n   * @return {Array} The offers/response with normalized parameters\r\n   * @private\r\n   */\n\n\n  normalizeParams(configurations) {\n    configurations.forEach(params => {\n      Object.keys(params).forEach(key => {\n        var value = params[key];\n\n        if (value.length > 1) {\n          throw new Error(\"Parameter \\\"\".concat(key, \"\\\" must have only a single value\"));\n        }\n\n        value = value[0];\n\n        if (key === 'client_max_window_bits') {\n          if (value !== true) {\n            const num = +value;\n\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\n              throw new TypeError(\"Invalid value for parameter \\\"\".concat(key, \"\\\": \").concat(value));\n            }\n\n            value = num;\n          } else if (!this._isServer) {\n            throw new TypeError(\"Invalid value for parameter \\\"\".concat(key, \"\\\": \").concat(value));\n          }\n        } else if (key === 'server_max_window_bits') {\n          const num = +value;\n\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\n            throw new TypeError(\"Invalid value for parameter \\\"\".concat(key, \"\\\": \").concat(value));\n          }\n\n          value = num;\n        } else if (key === 'client_no_context_takeover' || key === 'server_no_context_takeover') {\n          if (value !== true) {\n            throw new TypeError(\"Invalid value for parameter \\\"\".concat(key, \"\\\": \").concat(value));\n          }\n        } else {\n          throw new Error(\"Unknown parameter \\\"\".concat(key, \"\\\"\"));\n        }\n\n        params[key] = value;\n      });\n    });\n    return configurations;\n  }\n  /**\r\n   * Decompress data. Concurrency limited by async-limiter.\r\n   *\r\n   * @param {Buffer} data Compressed data\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @public\r\n   */\n\n\n  decompress(data, fin, callback) {\n    zlibLimiter.push(done => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n  /**\r\n   * Compress data. Concurrency limited by async-limiter.\r\n   *\r\n   * @param {Buffer} data Data to compress\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @public\r\n   */\n\n\n  compress(data, fin, callback) {\n    zlibLimiter.push(done => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n  /**\r\n   * Decompress data.\r\n   *\r\n   * @param {Buffer} data Compressed data\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @private\r\n   */\n\n\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? 'client' : 'server';\n\n    if (!this._inflate) {\n      const key = \"\".concat(endpoint, \"_max_window_bits\");\n      const windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n      this._inflate = zlib.createInflateRaw(Object.assign({}, this._options.zlibInflateOptions, {\n        windowBits\n      }));\n      this._inflate[kPerMessageDeflate] = this;\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n\n      this._inflate.on('error', inflateOnError);\n\n      this._inflate.on('data', inflateOnData);\n    }\n\n    this._inflate[kCallback] = callback;\n    this._inflate[kWriteInProgress] = true;\n\n    this._inflate.write(data);\n\n    if (fin) this._inflate.write(TRAILER);\n\n    this._inflate.flush(() => {\n      const err = this._inflate[kError];\n\n      if (err) {\n        this._inflate.close();\n\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n\n      const data = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);\n\n      if (fin && this.params[\"\".concat(endpoint, \"_no_context_takeover\")] || this._inflate[kPendingClose]) {\n        this._inflate.close();\n\n        this._inflate = null;\n      } else {\n        this._inflate[kWriteInProgress] = false;\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n      }\n\n      callback(null, data);\n    });\n  }\n  /**\r\n   * Compress data.\r\n   *\r\n   * @param {Buffer} data Data to compress\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @private\r\n   */\n\n\n  _compress(data, fin, callback) {\n    if (!data || data.length === 0) {\n      process.nextTick(callback, null, EMPTY_BLOCK);\n      return;\n    }\n\n    const endpoint = this._isServer ? 'server' : 'client';\n\n    if (!this._deflate) {\n      const key = \"\".concat(endpoint, \"_max_window_bits\");\n      const windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n      this._deflate = zlib.createDeflateRaw(Object.assign( // TODO deprecate memLevel/level and recommend zlibDeflateOptions instead\n      {\n        memLevel: this._options.memLevel,\n        level: this._options.level\n      }, this._options.zlibDeflateOptions, {\n        windowBits\n      }));\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = []; //\n      // `zlib.DeflateRaw` emits an `'error'` event only when an attempt to use\n      // it is made after it has already been closed. This cannot happen here,\n      // so we only add a listener for the `'data'` event.\n      //\n\n      this._deflate.on('data', deflateOnData);\n    }\n\n    this._deflate[kWriteInProgress] = true;\n\n    this._deflate.write(data);\n\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      var data = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);\n      if (fin) data = data.slice(0, data.length - 4);\n\n      if (fin && this.params[\"\".concat(endpoint, \"_no_context_takeover\")] || this._deflate[kPendingClose]) {\n        this._deflate.close();\n\n        this._deflate = null;\n      } else {\n        this._deflate[kWriteInProgress] = false;\n        this._deflate[kTotalLength] = 0;\n        this._deflate[kBuffers] = [];\n      }\n\n      callback(null, data);\n    });\n  }\n\n}\n\nmodule.exports = PerMessageDeflate;\n/**\r\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\r\n *\r\n * @param {Buffer} chunk A chunk of data\r\n * @private\r\n */\n\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\n/**\r\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\r\n *\r\n * @param {Buffer} chunk A chunk of data\r\n * @private\r\n */\n\n\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n\n  if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n\n  this[kError] = new RangeError('Max payload size exceeded');\n  this[kError][constants.kStatusCode] = 1009;\n  this.removeListener('data', inflateOnData);\n  this.reset();\n}\n/**\r\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\r\n *\r\n * @param {Error} err The emitted error\r\n * @private\r\n */\n\n\nfunction inflateOnError(err) {\n  //\n  // There is no need to call `Zlib#close()` as the handle is automatically\n  // closed when an error is emitted.\n  //\n  this[kPerMessageDeflate]._inflate = null;\n  err[constants.kStatusCode] = 1007;\n  this[kCallback](err);\n}","map":{"version":3,"sources":["C:/Users/khouloud/Documents/PI/MERN_Stack_PI/node_modules/ws/lib/permessage-deflate.js"],"names":["Limiter","require","zlib","bufferUtil","constants","TRAILER","Buffer","from","EMPTY_BLOCK","kPerMessageDeflate","Symbol","kWriteInProgress","kPendingClose","kTotalLength","kCallback","kBuffers","kError","zlibLimiter","PerMessageDeflate","constructor","options","isServer","maxPayload","_maxPayload","_options","_threshold","threshold","undefined","_isServer","_deflate","_inflate","params","concurrency","concurrencyLimit","extensionName","offer","serverNoContextTakeover","server_no_context_takeover","clientNoContextTakeover","client_no_context_takeover","serverMaxWindowBits","server_max_window_bits","clientMaxWindowBits","client_max_window_bits","accept","configurations","normalizeParams","acceptAsServer","acceptAsClient","cleanup","close","offers","opts","accepted","find","Error","response","forEach","Object","keys","key","value","length","num","Number","isInteger","TypeError","decompress","data","fin","callback","push","done","_decompress","err","result","compress","_compress","endpoint","windowBits","Z_DEFAULT_WINDOWBITS","createInflateRaw","assign","zlibInflateOptions","on","inflateOnError","inflateOnData","write","flush","concat","process","nextTick","createDeflateRaw","memLevel","level","zlibDeflateOptions","deflateOnData","Z_SYNC_FLUSH","slice","module","exports","chunk","RangeError","kStatusCode","removeListener","reset"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst Limiter = require('async-limiter');\r\nconst zlib = require('zlib');\r\n\r\nconst bufferUtil = require('./buffer-util');\r\nconst constants = require('./constants');\r\n\r\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\r\nconst EMPTY_BLOCK = Buffer.from([0x00]);\r\n\r\nconst kPerMessageDeflate = Symbol('permessage-deflate');\r\nconst kWriteInProgress = Symbol('write-in-progress');\r\nconst kPendingClose = Symbol('pending-close');\r\nconst kTotalLength = Symbol('total-length');\r\nconst kCallback = Symbol('callback');\r\nconst kBuffers = Symbol('buffers');\r\nconst kError = Symbol('error');\r\n\r\n//\r\n// We limit zlib concurrency, which prevents severe memory fragmentation\r\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\r\n// and https://github.com/websockets/ws/issues/1202\r\n//\r\n// Intentionally global; it's the global thread pool that's an issue.\r\n//\r\nlet zlibLimiter;\r\n\r\n/**\r\n * permessage-deflate implementation.\r\n */\r\nclass PerMessageDeflate {\r\n  /**\r\n   * Creates a PerMessageDeflate instance.\r\n   *\r\n   * @param {Object} options Configuration options\r\n   * @param {Boolean} options.serverNoContextTakeover Request/accept disabling\r\n   *     of server context takeover\r\n   * @param {Boolean} options.clientNoContextTakeover Advertise/acknowledge\r\n   *     disabling of client context takeover\r\n   * @param {(Boolean|Number)} options.serverMaxWindowBits Request/confirm the\r\n   *     use of a custom server window size\r\n   * @param {(Boolean|Number)} options.clientMaxWindowBits Advertise support\r\n   *     for, or request, a custom client window size\r\n   * @param {Object} options.zlibDeflateOptions Options to pass to zlib on deflate\r\n   * @param {Object} options.zlibInflateOptions Options to pass to zlib on inflate\r\n   * @param {Number} options.threshold Size (in bytes) below which messages\r\n   *     should not be compressed\r\n   * @param {Number} options.concurrencyLimit The number of concurrent calls to\r\n   *     zlib\r\n   * @param {Boolean} isServer Create the instance in either server or client\r\n   *     mode\r\n   * @param {Number} maxPayload The maximum allowed message length\r\n   */\r\n  constructor (options, isServer, maxPayload) {\r\n    this._maxPayload = maxPayload | 0;\r\n    this._options = options || {};\r\n    this._threshold = this._options.threshold !== undefined\r\n      ? this._options.threshold\r\n      : 1024;\r\n    this._isServer = !!isServer;\r\n    this._deflate = null;\r\n    this._inflate = null;\r\n\r\n    this.params = null;\r\n\r\n    if (!zlibLimiter) {\r\n      const concurrency = this._options.concurrencyLimit !== undefined\r\n        ? this._options.concurrencyLimit\r\n        : 10;\r\n      zlibLimiter = new Limiter({ concurrency });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @type {String}\r\n   */\r\n  static get extensionName () {\r\n    return 'permessage-deflate';\r\n  }\r\n\r\n  /**\r\n   * Create an extension negotiation offer.\r\n   *\r\n   * @return {Object} Extension parameters\r\n   * @public\r\n   */\r\n  offer () {\r\n    const params = {};\r\n\r\n    if (this._options.serverNoContextTakeover) {\r\n      params.server_no_context_takeover = true;\r\n    }\r\n    if (this._options.clientNoContextTakeover) {\r\n      params.client_no_context_takeover = true;\r\n    }\r\n    if (this._options.serverMaxWindowBits) {\r\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\r\n    }\r\n    if (this._options.clientMaxWindowBits) {\r\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\r\n    } else if (this._options.clientMaxWindowBits == null) {\r\n      params.client_max_window_bits = true;\r\n    }\r\n\r\n    return params;\r\n  }\r\n\r\n  /**\r\n   * Accept an extension negotiation offer/response.\r\n   *\r\n   * @param {Array} configurations The extension negotiation offers/reponse\r\n   * @return {Object} Accepted configuration\r\n   * @public\r\n   */\r\n  accept (configurations) {\r\n    configurations = this.normalizeParams(configurations);\r\n\r\n    this.params = this._isServer\r\n      ? this.acceptAsServer(configurations)\r\n      : this.acceptAsClient(configurations);\r\n\r\n    return this.params;\r\n  }\r\n\r\n  /**\r\n   * Releases all resources used by the extension.\r\n   *\r\n   * @public\r\n   */\r\n  cleanup () {\r\n    if (this._inflate) {\r\n      if (this._inflate[kWriteInProgress]) {\r\n        this._inflate[kPendingClose] = true;\r\n      } else {\r\n        this._inflate.close();\r\n        this._inflate = null;\r\n      }\r\n    }\r\n    if (this._deflate) {\r\n      if (this._deflate[kWriteInProgress]) {\r\n        this._deflate[kPendingClose] = true;\r\n      } else {\r\n        this._deflate.close();\r\n        this._deflate = null;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   *  Accept an extension negotiation offer.\r\n   *\r\n   * @param {Array} offers The extension negotiation offers\r\n   * @return {Object} Accepted configuration\r\n   * @private\r\n   */\r\n  acceptAsServer (offers) {\r\n    const opts = this._options;\r\n    const accepted = offers.find((params) => {\r\n      if (\r\n        (opts.serverNoContextTakeover === false &&\r\n          params.server_no_context_takeover) ||\r\n        (params.server_max_window_bits &&\r\n          (opts.serverMaxWindowBits === false ||\r\n            (typeof opts.serverMaxWindowBits === 'number' &&\r\n              opts.serverMaxWindowBits > params.server_max_window_bits))) ||\r\n        (typeof opts.clientMaxWindowBits === 'number' &&\r\n          !params.client_max_window_bits)\r\n      ) {\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    });\r\n\r\n    if (!accepted) {\r\n      throw new Error('None of the extension offers can be accepted');\r\n    }\r\n\r\n    if (opts.serverNoContextTakeover) {\r\n      accepted.server_no_context_takeover = true;\r\n    }\r\n    if (opts.clientNoContextTakeover) {\r\n      accepted.client_no_context_takeover = true;\r\n    }\r\n    if (typeof opts.serverMaxWindowBits === 'number') {\r\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\r\n    }\r\n    if (typeof opts.clientMaxWindowBits === 'number') {\r\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\r\n    } else if (\r\n      accepted.client_max_window_bits === true ||\r\n      opts.clientMaxWindowBits === false\r\n    ) {\r\n      delete accepted.client_max_window_bits;\r\n    }\r\n\r\n    return accepted;\r\n  }\r\n\r\n  /**\r\n   * Accept the extension negotiation response.\r\n   *\r\n   * @param {Array} response The extension negotiation response\r\n   * @return {Object} Accepted configuration\r\n   * @private\r\n   */\r\n  acceptAsClient (response) {\r\n    const params = response[0];\r\n\r\n    if (\r\n      this._options.clientNoContextTakeover === false &&\r\n      params.client_no_context_takeover\r\n    ) {\r\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\r\n    }\r\n\r\n    if (!params.client_max_window_bits) {\r\n      if (typeof this._options.clientMaxWindowBits === 'number') {\r\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\r\n      }\r\n    } else if (\r\n      this._options.clientMaxWindowBits === false ||\r\n      (typeof this._options.clientMaxWindowBits === 'number' &&\r\n        params.client_max_window_bits > this._options.clientMaxWindowBits)\r\n    ) {\r\n      throw new Error(\r\n        'Unexpected or invalid parameter \"client_max_window_bits\"'\r\n      );\r\n    }\r\n\r\n    return params;\r\n  }\r\n\r\n  /**\r\n   * Normalize parameters.\r\n   *\r\n   * @param {Array} configurations The extension negotiation offers/reponse\r\n   * @return {Array} The offers/response with normalized parameters\r\n   * @private\r\n   */\r\n  normalizeParams (configurations) {\r\n    configurations.forEach((params) => {\r\n      Object.keys(params).forEach((key) => {\r\n        var value = params[key];\r\n\r\n        if (value.length > 1) {\r\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\r\n        }\r\n\r\n        value = value[0];\r\n\r\n        if (key === 'client_max_window_bits') {\r\n          if (value !== true) {\r\n            const num = +value;\r\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\r\n              throw new TypeError(\r\n                `Invalid value for parameter \"${key}\": ${value}`\r\n              );\r\n            }\r\n            value = num;\r\n          } else if (!this._isServer) {\r\n            throw new TypeError(\r\n              `Invalid value for parameter \"${key}\": ${value}`\r\n            );\r\n          }\r\n        } else if (key === 'server_max_window_bits') {\r\n          const num = +value;\r\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\r\n            throw new TypeError(\r\n              `Invalid value for parameter \"${key}\": ${value}`\r\n            );\r\n          }\r\n          value = num;\r\n        } else if (\r\n          key === 'client_no_context_takeover' ||\r\n          key === 'server_no_context_takeover'\r\n        ) {\r\n          if (value !== true) {\r\n            throw new TypeError(\r\n              `Invalid value for parameter \"${key}\": ${value}`\r\n            );\r\n          }\r\n        } else {\r\n          throw new Error(`Unknown parameter \"${key}\"`);\r\n        }\r\n\r\n        params[key] = value;\r\n      });\r\n    });\r\n\r\n    return configurations;\r\n  }\r\n\r\n  /**\r\n   * Decompress data. Concurrency limited by async-limiter.\r\n   *\r\n   * @param {Buffer} data Compressed data\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @public\r\n   */\r\n  decompress (data, fin, callback) {\r\n    zlibLimiter.push((done) => {\r\n      this._decompress(data, fin, (err, result) => {\r\n        done();\r\n        callback(err, result);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Compress data. Concurrency limited by async-limiter.\r\n   *\r\n   * @param {Buffer} data Data to compress\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @public\r\n   */\r\n  compress (data, fin, callback) {\r\n    zlibLimiter.push((done) => {\r\n      this._compress(data, fin, (err, result) => {\r\n        done();\r\n        callback(err, result);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Decompress data.\r\n   *\r\n   * @param {Buffer} data Compressed data\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @private\r\n   */\r\n  _decompress (data, fin, callback) {\r\n    const endpoint = this._isServer ? 'client' : 'server';\r\n\r\n    if (!this._inflate) {\r\n      const key = `${endpoint}_max_window_bits`;\r\n      const windowBits = typeof this.params[key] !== 'number'\r\n        ? zlib.Z_DEFAULT_WINDOWBITS\r\n        : this.params[key];\r\n\r\n      this._inflate = zlib.createInflateRaw(\r\n        Object.assign({}, this._options.zlibInflateOptions, { windowBits })\r\n      );\r\n      this._inflate[kPerMessageDeflate] = this;\r\n      this._inflate[kTotalLength] = 0;\r\n      this._inflate[kBuffers] = [];\r\n      this._inflate.on('error', inflateOnError);\r\n      this._inflate.on('data', inflateOnData);\r\n    }\r\n\r\n    this._inflate[kCallback] = callback;\r\n    this._inflate[kWriteInProgress] = true;\r\n\r\n    this._inflate.write(data);\r\n    if (fin) this._inflate.write(TRAILER);\r\n\r\n    this._inflate.flush(() => {\r\n      const err = this._inflate[kError];\r\n\r\n      if (err) {\r\n        this._inflate.close();\r\n        this._inflate = null;\r\n        callback(err);\r\n        return;\r\n      }\r\n\r\n      const data = bufferUtil.concat(\r\n        this._inflate[kBuffers],\r\n        this._inflate[kTotalLength]\r\n      );\r\n\r\n      if (\r\n        (fin && this.params[`${endpoint}_no_context_takeover`]) ||\r\n        this._inflate[kPendingClose]\r\n      ) {\r\n        this._inflate.close();\r\n        this._inflate = null;\r\n      } else {\r\n        this._inflate[kWriteInProgress] = false;\r\n        this._inflate[kTotalLength] = 0;\r\n        this._inflate[kBuffers] = [];\r\n      }\r\n\r\n      callback(null, data);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Compress data.\r\n   *\r\n   * @param {Buffer} data Data to compress\r\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\r\n   * @param {Function} callback Callback\r\n   * @private\r\n   */\r\n  _compress (data, fin, callback) {\r\n    if (!data || data.length === 0) {\r\n      process.nextTick(callback, null, EMPTY_BLOCK);\r\n      return;\r\n    }\r\n\r\n    const endpoint = this._isServer ? 'server' : 'client';\r\n\r\n    if (!this._deflate) {\r\n      const key = `${endpoint}_max_window_bits`;\r\n      const windowBits = typeof this.params[key] !== 'number'\r\n        ? zlib.Z_DEFAULT_WINDOWBITS\r\n        : this.params[key];\r\n\r\n      this._deflate = zlib.createDeflateRaw(\r\n        Object.assign(\r\n          // TODO deprecate memLevel/level and recommend zlibDeflateOptions instead\r\n          {\r\n            memLevel: this._options.memLevel,\r\n            level: this._options.level\r\n          },\r\n          this._options.zlibDeflateOptions,\r\n          { windowBits }\r\n        )\r\n      );\r\n\r\n      this._deflate[kTotalLength] = 0;\r\n      this._deflate[kBuffers] = [];\r\n\r\n      //\r\n      // `zlib.DeflateRaw` emits an `'error'` event only when an attempt to use\r\n      // it is made after it has already been closed. This cannot happen here,\r\n      // so we only add a listener for the `'data'` event.\r\n      //\r\n      this._deflate.on('data', deflateOnData);\r\n    }\r\n\r\n    this._deflate[kWriteInProgress] = true;\r\n\r\n    this._deflate.write(data);\r\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\r\n      var data = bufferUtil.concat(\r\n        this._deflate[kBuffers],\r\n        this._deflate[kTotalLength]\r\n      );\r\n\r\n      if (fin) data = data.slice(0, data.length - 4);\r\n\r\n      if (\r\n        (fin && this.params[`${endpoint}_no_context_takeover`]) ||\r\n        this._deflate[kPendingClose]\r\n      ) {\r\n        this._deflate.close();\r\n        this._deflate = null;\r\n      } else {\r\n        this._deflate[kWriteInProgress] = false;\r\n        this._deflate[kTotalLength] = 0;\r\n        this._deflate[kBuffers] = [];\r\n      }\r\n\r\n      callback(null, data);\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = PerMessageDeflate;\r\n\r\n/**\r\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\r\n *\r\n * @param {Buffer} chunk A chunk of data\r\n * @private\r\n */\r\nfunction deflateOnData (chunk) {\r\n  this[kBuffers].push(chunk);\r\n  this[kTotalLength] += chunk.length;\r\n}\r\n\r\n/**\r\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\r\n *\r\n * @param {Buffer} chunk A chunk of data\r\n * @private\r\n */\r\nfunction inflateOnData (chunk) {\r\n  this[kTotalLength] += chunk.length;\r\n\r\n  if (\r\n    this[kPerMessageDeflate]._maxPayload < 1 ||\r\n    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload\r\n  ) {\r\n    this[kBuffers].push(chunk);\r\n    return;\r\n  }\r\n\r\n  this[kError] = new RangeError('Max payload size exceeded');\r\n  this[kError][constants.kStatusCode] = 1009;\r\n  this.removeListener('data', inflateOnData);\r\n  this.reset();\r\n}\r\n\r\n/**\r\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\r\n *\r\n * @param {Error} err The emitted error\r\n * @private\r\n */\r\nfunction inflateOnError (err) {\r\n  //\r\n  // There is no need to call `Zlib#close()` as the handle is automatically\r\n  // closed when an error is emitted.\r\n  //\r\n  this[kPerMessageDeflate]._inflate = null;\r\n  err[constants.kStatusCode] = 1007;\r\n  this[kCallback](err);\r\n}\r\n"]},"metadata":{},"sourceType":"script"}