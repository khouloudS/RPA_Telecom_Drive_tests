{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\khouloud\\\\Documents\\\\PI\\\\MERN_Stack_PI\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\khouloud\\\\Documents\\\\PI\\\\MERN_Stack_PI\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst sanitize_1 = require(\"./utils/sanitize\");\n\nconst uri_1 = require(\"./utils/uri\");\n\nconst syncerror_1 = require(\"./utils/syncerror\");\n\nconst logger_1 = require(\"./utils/logger\");\n\nconst entity_1 = require(\"./entity\");\n\nconst mapitem_1 = require(\"./mapitem\");\n\nconst paginator_1 = require(\"./paginator\");\n\nconst cache_1 = require(\"./cache\");\n\nconst mergingqueue_1 = require(\"./mergingqueue\");\n\nconst closeable_1 = require(\"./closeable\");\n\nclass SyncMapImpl extends entity_1.SyncEntity {\n  /**\n   * @private\n   */\n  constructor(services, descriptor, removalHandler) {\n    super(services, removalHandler);\n\n    const updateRequestReducer = (acc, input) => typeof input.ttl === 'number' ? {\n      ttl: input.ttl\n    } : acc;\n\n    this.updateMergingQueue = new mergingqueue_1.NamespacedMergingQueue(updateRequestReducer);\n    this.cache = new cache_1.Cache();\n    this.descriptor = descriptor;\n    this.descriptor.date_updated = new Date(this.descriptor.date_updated);\n\n    if (descriptor.items) {\n      descriptor.items.forEach(itemDescriptor => {\n        itemDescriptor.date_updated = new Date(itemDescriptor.date_updated);\n        this.cache.store(itemDescriptor.key, new mapitem_1.MapItem(itemDescriptor), itemDescriptor.last_event_id);\n      });\n    }\n  } // private props\n\n\n  get uri() {\n    return this.descriptor.url;\n  }\n\n  get links() {\n    return this.descriptor.links;\n  }\n\n  get revision() {\n    return this.descriptor.revision;\n  }\n\n  get lastEventId() {\n    return this.descriptor.last_event_id;\n  }\n\n  get dateExpires() {\n    return this.descriptor.date_expires;\n  }\n\n  static get type() {\n    return 'map';\n  }\n\n  get type() {\n    return 'map';\n  } // below properties are specific to Insights only\n\n\n  get indexName() {\n    return undefined;\n  }\n\n  get queryString() {\n    return undefined;\n  } // public props, documented along with class description\n\n\n  get sid() {\n    return this.descriptor.sid;\n  }\n\n  get uniqueName() {\n    return this.descriptor.unique_name || null;\n  }\n\n  get dateUpdated() {\n    return this.descriptor.date_updated;\n  }\n\n  set(key, value, itemMetadataUpdates) {\n    var _this = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var input;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            input = itemMetadataUpdates || {};\n            sanitize_1.validateOptionalTtl(input.ttl);\n            return _context.abrupt(\"return\", _this.updateMergingQueue.squashAndAdd(key, input, input => _this._putItemUnconditionally(key, value, input.ttl)));\n\n          case 3:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }))();\n  }\n\n  get(key) {\n    var _this2 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!_this2.cache.has(key)) {\n              _context2.next = 4;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", _this2.cache.get(key));\n\n          case 4:\n            return _context2.abrupt(\"return\", _this2._getItemFromServer(key));\n\n          case 5:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }))();\n  }\n\n  _getItemFromServer(key) {\n    var _this3 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n      var result;\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return _this3.queryItems({\n              key: key\n            });\n\n          case 2:\n            result = _context3.sent;\n\n            if (!(result.items.length < 1)) {\n              _context3.next = 7;\n              break;\n            }\n\n            throw new syncerror_1.SyncError(\"No item with key \".concat(key, \" found\"), 404, 54201);\n\n          case 7:\n            return _context3.abrupt(\"return\", result.items[0]);\n\n          case 8:\n          case \"end\":\n            return _context3.stop();\n        }\n      }, _callee3);\n    }))();\n  }\n\n  mutate(key, mutator, itemMetadataUpdates) {\n    var _this4 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n      var input;\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            input = itemMetadataUpdates || {};\n            sanitize_1.validateOptionalTtl(input.ttl);\n            return _context4.abrupt(\"return\", _this4.updateMergingQueue.add(key, input, input => _this4._putItemWithIfMatch(key, mutator, input.ttl)));\n\n          case 3:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee4);\n    }))();\n  }\n\n  update(key, obj, itemMetadataUpdates) {\n    var _this5 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            return _context5.abrupt(\"return\", _this5.mutate(key, remote => Object.assign(remote, obj), itemMetadataUpdates));\n\n          case 1:\n          case \"end\":\n            return _context5.stop();\n        }\n      }, _callee5);\n    }))();\n  }\n\n  _putItemUnconditionally(key, data, ttl) {\n    var _this6 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n      var result, item;\n      return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n        while (1) switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.next = 2;\n            return _this6._putItemToServer(key, data, undefined, ttl);\n\n          case 2:\n            result = _context6.sent;\n            item = result.item;\n\n            _this6._handleItemMutated(item.key, item.url, item.last_event_id, item.revision, item.data, item.date_updated, item.date_expires, result.added, false);\n\n            return _context6.abrupt(\"return\", _this6.cache.get(item.key));\n\n          case 6:\n          case \"end\":\n            return _context6.stop();\n        }\n      }, _callee6);\n    }))();\n  }\n\n  _putItemWithIfMatch(key, mutatorFunction, ttl) {\n    var _this7 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n      var currentItem, data, ifMatch, result, item;\n      return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n        while (1) switch (_context7.prev = _context7.next) {\n          case 0:\n            _context7.next = 2;\n            return _this7.get(key).catch(error => {\n              if (error.status === 404) {\n                // PUT /Items/myKey with `If-Match: -1` acts as \"put if not exists\"\n                return new mapitem_1.MapItem({\n                  key: key,\n                  data: {},\n                  last_event_id: -1,\n                  revision: '-1',\n                  url: null,\n                  date_updated: null,\n                  date_expires: null\n                });\n              } else {\n                throw error;\n              }\n            });\n\n          case 2:\n            currentItem = _context7.sent;\n            data = mutatorFunction(sanitize_1.deepClone(currentItem.value));\n\n            if (!data) {\n              _context7.next = 26;\n              break;\n            }\n\n            ifMatch = currentItem.revision;\n            _context7.prev = 6;\n            _context7.next = 9;\n            return _this7._putItemToServer(key, data, ifMatch, ttl);\n\n          case 9:\n            result = _context7.sent;\n            item = result.item;\n\n            _this7._handleItemMutated(item.key, item.url, item.last_event_id, item.revision, item.data, item.date_updated, item.date_expires, result.added, false);\n\n            return _context7.abrupt(\"return\", _this7.cache.get(item.key));\n\n          case 15:\n            _context7.prev = 15;\n            _context7.t0 = _context7[\"catch\"](6);\n\n            if (!(_context7.t0.status === 412)) {\n              _context7.next = 23;\n              break;\n            }\n\n            _context7.next = 20;\n            return _this7._getItemFromServer(key);\n\n          case 20:\n            return _context7.abrupt(\"return\", _this7._putItemWithIfMatch(key, mutatorFunction, ttl));\n\n          case 23:\n            throw _context7.t0;\n\n          case 24:\n            _context7.next = 27;\n            break;\n\n          case 26:\n            return _context7.abrupt(\"return\", currentItem);\n\n          case 27:\n          case \"end\":\n            return _context7.stop();\n        }\n      }, _callee7, null, [[6, 15]]);\n    }))();\n  }\n\n  _putItemToServer(key, data, ifMatch, ttl) {\n    var _this8 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n      var url, requestBody, response, mapItemDescriptor, added;\n      return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n        while (1) switch (_context8.prev = _context8.next) {\n          case 0:\n            url = new uri_1.UriBuilder(_this8.links.items).pathSegment(key).build();\n            requestBody = {\n              data\n            };\n\n            if (ttl !== undefined) {\n              requestBody.ttl = ttl;\n            }\n\n            _context8.prev = 3;\n            _context8.next = 6;\n            return _this8.services.network.put(url, requestBody, ifMatch);\n\n          case 6:\n            response = _context8.sent;\n            mapItemDescriptor = response.body;\n            mapItemDescriptor.data = data; // The server does not return the data in the response\n\n            mapItemDescriptor.date_updated = new Date(mapItemDescriptor.date_updated);\n            added = response.status.code === 201;\n            return _context8.abrupt(\"return\", {\n              added,\n              item: mapItemDescriptor\n            });\n\n          case 14:\n            _context8.prev = 14;\n            _context8.t0 = _context8[\"catch\"](3);\n\n            if (_context8.t0.status === 404) {\n              _this8.onRemoved(false);\n            }\n\n            throw _context8.t0;\n\n          case 18:\n          case \"end\":\n            return _context8.stop();\n        }\n      }, _callee8, null, [[3, 14]]);\n    }))();\n  }\n\n  remove(key) {\n    var _this9 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n      var item, response;\n      return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n        while (1) switch (_context9.prev = _context9.next) {\n          case 0:\n            if (!(typeof key === 'undefined')) {\n              _context9.next = 2;\n              break;\n            }\n\n            throw new Error('Key argument is invalid');\n\n          case 2:\n            _context9.next = 4;\n            return _this9.get(key);\n\n          case 4:\n            item = _context9.sent;\n            _context9.next = 7;\n            return _this9.services.network.delete(item.uri);\n\n          case 7:\n            response = _context9.sent;\n\n            _this9._handleItemRemoved(key, response.body.last_event_id, undefined, new Date(response.body.date_updated), false);\n\n          case 9:\n          case \"end\":\n            return _context9.stop();\n        }\n      }, _callee9);\n    }))();\n  }\n  /**\n   * @private\n   */\n\n\n  queryItems(args) {\n    var _this10 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n      var uri, response, items, meta;\n      return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n        while (1) switch (_context10.prev = _context10.next) {\n          case 0:\n            args = args || {};\n            uri = new uri_1.UriBuilder(_this10.links.items).queryParam('From', args.from).queryParam('PageSize', args.limit).queryParam('Key', args.key).queryParam('PageToken', args.pageToken).queryParam('Order', args.order).build();\n            _context10.next = 4;\n            return _this10.services.network.get(uri);\n\n          case 4:\n            response = _context10.sent;\n            items = response.body.items.map(el => {\n              el.date_updated = new Date(el.date_updated);\n\n              let itemInCache = _this10.cache.get(el.key);\n\n              if (itemInCache) {\n                _this10._handleItemMutated(el.key, el.url, el.last_event_id, el.revision, el.data, el.date_updated, el.date_expires, false, true);\n              } else {\n                _this10.cache.store(el.key, new mapitem_1.MapItem(el), el.last_event_id);\n              }\n\n              return _this10.cache.get(el.key);\n            });\n            meta = response.body.meta;\n            return _context10.abrupt(\"return\", new paginator_1.Paginator(items, pageToken => _this10.queryItems({\n              pageToken\n            }), meta.previous_token, meta.next_token));\n\n          case 8:\n          case \"end\":\n            return _context10.stop();\n        }\n      }, _callee10);\n    }))();\n  }\n\n  getItems(args) {\n    var _this11 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {\n      return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n        while (1) switch (_context11.prev = _context11.next) {\n          case 0:\n            args = args || {};\n            sanitize_1.validatePageSize(args.pageSize);\n            args.limit = args.pageSize || args.limit || 50;\n            args.order = args.order || 'asc';\n            return _context11.abrupt(\"return\", _this11.queryItems(args));\n\n          case 5:\n          case \"end\":\n            return _context11.stop();\n        }\n      }, _callee11);\n    }))();\n  }\n\n  shouldIgnoreEvent(key, eventId) {\n    return this.cache.isKnown(key, eventId);\n  }\n  /**\n   * Handle update from the server\n   * @private\n   */\n\n\n  _update(update, isStrictlyOrdered) {\n    update.date_created = new Date(update.date_created);\n\n    switch (update.type) {\n      case 'map_item_added':\n      case 'map_item_updated':\n        {\n          this._handleItemMutated(update.item_key, update.item_url, update.id, update.item_revision, update.item_data, update.date_created, undefined, // orchestration events do not include date_expires\n          update.type === 'map_item_added', true);\n        }\n        break;\n\n      case 'map_item_removed':\n        {\n          this._handleItemRemoved(update.item_key, update.id, update.item_data, update.date_created, true);\n        }\n        break;\n\n      case 'map_removed':\n        {\n          this.onRemoved(false);\n        }\n        break;\n    }\n\n    if (isStrictlyOrdered) {\n      this._advanceLastEventId(update.id, update.map_revision);\n    }\n  }\n\n  _advanceLastEventId(eventId, revision) {\n    if (this.lastEventId < eventId) {\n      this.descriptor.last_event_id = eventId;\n\n      if (revision) {\n        this.descriptor.revision = revision;\n      }\n    }\n  }\n\n  _updateRootDateUpdated(dateUpdated) {\n    if (!this.descriptor.date_updated || dateUpdated.getTime() > this.descriptor.date_updated.getTime()) {\n      this.descriptor.date_updated = dateUpdated;\n      this.services.storage.update(this.type, this.sid, this.uniqueName, {\n        date_updated: dateUpdated\n      });\n    }\n  }\n\n  _handleItemMutated(key, url, lastEventId, revision, value, dateUpdated, dateExpires, added, remote) {\n    if (this.shouldIgnoreEvent(key, lastEventId)) {\n      logger_1.default.trace('Item ', key, ' update skipped, current:', this.lastEventId, ', remote:', lastEventId);\n      return;\n    } else {\n      this._updateRootDateUpdated(dateUpdated);\n\n      let item = this.cache.get(key);\n\n      if (!item) {\n        item = new mapitem_1.MapItem({\n          key: key,\n          url,\n          last_event_id: lastEventId,\n          revision,\n          data: value,\n          date_updated: dateUpdated,\n          date_expires: dateExpires\n        });\n        this.cache.store(key, item, lastEventId);\n        this.emitItemMutationEvent(item, remote, added);\n      } else {\n        item.update(lastEventId, revision, value, dateUpdated);\n        this.cache.store(key, item, lastEventId);\n\n        if (dateExpires !== undefined) {\n          item.updateDateExpires(dateExpires);\n        }\n\n        this.emitItemMutationEvent(item, remote, false);\n      }\n    }\n  }\n\n  emitItemMutationEvent(item, remote, added) {\n    let eventName = added ? 'itemAdded' : 'itemUpdated';\n    this.broadcastEventToListeners(eventName, {\n      item: item,\n      isLocal: !remote\n    });\n  }\n  /**\n   * @private\n   */\n\n\n  _handleItemRemoved(key, eventId, oldData, dateUpdated, remote) {\n    this._updateRootDateUpdated(dateUpdated);\n\n    this.cache.delete(key, eventId);\n    this.broadcastEventToListeners('itemRemoved', {\n      key: key,\n      isLocal: !remote,\n      value: oldData\n    });\n  }\n\n  onRemoved(locally) {\n    this._unsubscribe();\n\n    this.removalHandler(this.type, this.sid, this.uniqueName);\n    this.broadcastEventToListeners('removed', {\n      isLocal: locally\n    });\n  }\n\n  setTtl(ttl) {\n    var _this12 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {\n      var requestBody, response;\n      return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n        while (1) switch (_context12.prev = _context12.next) {\n          case 0:\n            sanitize_1.validateMandatoryTtl(ttl);\n            _context12.prev = 1;\n            requestBody = {\n              ttl\n            };\n            _context12.next = 5;\n            return _this12.services.network.post(_this12.uri, requestBody);\n\n          case 5:\n            response = _context12.sent;\n            _this12.descriptor.date_expires = response.body.date_expires;\n            _context12.next = 13;\n            break;\n\n          case 9:\n            _context12.prev = 9;\n            _context12.t0 = _context12[\"catch\"](1);\n\n            if (_context12.t0.status === 404) {\n              _this12.onRemoved(false);\n            }\n\n            throw _context12.t0;\n\n          case 13:\n          case \"end\":\n            return _context12.stop();\n        }\n      }, _callee12, null, [[1, 9]]);\n    }))();\n  }\n\n  setItemTtl(key, ttl) {\n    var _this13 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {\n      var existingItem, requestBody, response;\n      return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n        while (1) switch (_context13.prev = _context13.next) {\n          case 0:\n            sanitize_1.validateMandatoryTtl(ttl);\n            _context13.next = 3;\n            return _this13.get(key);\n\n          case 3:\n            existingItem = _context13.sent;\n            requestBody = {\n              ttl\n            };\n            _context13.next = 7;\n            return _this13.services.network.post(existingItem.uri, requestBody);\n\n          case 7:\n            response = _context13.sent;\n            existingItem.updateDateExpires(response.body.date_expires);\n\n          case 9:\n          case \"end\":\n            return _context13.stop();\n        }\n      }, _callee13);\n    }))();\n  }\n\n  removeMap() {\n    var _this14 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14() {\n      return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n        while (1) switch (_context14.prev = _context14.next) {\n          case 0:\n            _context14.next = 2;\n            return _this14.services.network.delete(_this14.uri);\n\n          case 2:\n            _this14.onRemoved(true);\n\n          case 3:\n          case \"end\":\n            return _context14.stop();\n        }\n      }, _callee14);\n    }))();\n  }\n\n}\n\nexports.SyncMapImpl = SyncMapImpl;\n/**\n * @class\n * @alias Map\n * @classdesc Represents a Sync Map, which stores an unordered set of key:value pairs.\n * Use the {@link Client#map} method to obtain a reference to a Sync Map.\n * @property {String} sid An immutable identifier (a SID) assigned by the system on creation.\n * @property {String} [uniqueName=null] - An optional immutable identifier that may be assigned by the\n * programmer to this map on creation. Unique among other Maps.\n * @property {Date} dateUpdated Date when the Map was last updated.\n *\n * @fires Map#removed\n * @fires Map#itemAdded\n * @fires Map#itemRemoved\n * @fires Map#itemUpdated\n */\n\nclass SyncMap extends closeable_1.Closeable {\n  constructor(syncMapImpl) {\n    super();\n    this.syncMapImpl = syncMapImpl;\n    this.syncMapImpl.attach(this);\n  } // private props\n\n\n  get uri() {\n    return this.syncMapImpl.uri;\n  }\n\n  get links() {\n    return this.syncMapImpl.links;\n  }\n\n  get revision() {\n    return this.syncMapImpl.revision;\n  }\n\n  get lastEventId() {\n    return this.syncMapImpl.lastEventId;\n  }\n\n  get dateExpires() {\n    return this.syncMapImpl.dateExpires;\n  }\n\n  static get type() {\n    return SyncMapImpl.type;\n  }\n\n  get type() {\n    return SyncMapImpl.type;\n  } // public props, documented along with class description\n\n\n  get sid() {\n    return this.syncMapImpl.sid;\n  }\n\n  get uniqueName() {\n    return this.syncMapImpl.uniqueName;\n  }\n\n  get dateUpdated() {\n    return this.syncMapImpl.dateUpdated;\n  }\n  /**\n   * Add a new item to the map with the given key:value pair. Overwrites any value that might already exist at that key.\n   * @param {String} key Unique item identifier.\n   * @param {Object} value Value to be set.\n   * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\n   * @returns {Promise<MapItem>} Newly added item, or modified one if already exists, with the latest known value.\n   * @public\n   * @example\n   * map.set('myKey', { name: 'John Smith' }, { ttl: 86400 })\n   *   .then(function(item) {\n   *     console.log('Map Item set() successful, item value:', item.value);\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map Item set() failed', error);\n   *   });\n   */\n\n\n  set(key, value, itemMetadataUpdates) {\n    var _this15 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15() {\n      return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n        while (1) switch (_context15.prev = _context15.next) {\n          case 0:\n            _this15.ensureNotClosed();\n\n            return _context15.abrupt(\"return\", _this15.syncMapImpl.set(key, value, itemMetadataUpdates));\n\n          case 2:\n          case \"end\":\n            return _context15.stop();\n        }\n      }, _callee15);\n    }))();\n  }\n  /**\n   * Retrieve an item by key.\n   * @param {String} key Identifies the desired item.\n   * @returns {Promise<MapItem>} A promise that resolves when the item has been fetched.\n   * This promise will be rejected if item was not found.\n   * @public\n   * @example\n   * map.get('myKey')\n   *   .then(function(item) {\n   *     console.log('Map Item get() successful, item value:', item.value)\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map Item get() failed', error);\n   *   });\n   */\n\n\n  get(key) {\n    var _this16 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16() {\n      return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n        while (1) switch (_context16.prev = _context16.next) {\n          case 0:\n            _this16.ensureNotClosed();\n\n            return _context16.abrupt(\"return\", _this16.syncMapImpl.get(key));\n\n          case 2:\n          case \"end\":\n            return _context16.stop();\n        }\n      }, _callee16);\n    }))();\n  }\n  /**\n   * Schedules a modification to this Map Item that will apply a mutation function.\n   * If no Item with the given key exists, it will first be created, having the default value (<code>{}</code>).\n   * @param {String} key Selects the map item to be mutated.\n   * @param {Map~Mutator} mutator A function that outputs a new value based on the existing value.\n   * May be called multiple times, particularly if this Map Item is modified concurrently by remote code.\n   * If the mutation ultimately succeeds, the Map Item will have made the particular transition described\n   * by this function.\n   * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\n   * @returns {Promise<MapItem>} Resolves with the most recent item state, the output of a successful\n   * mutation or a state that prompted graceful cancellation (mutator returned <code>null</code>).\n   * @public\n   * @example\n   * var mutatorFunction = function(currentValue) {\n   *     currentValue.viewCount = (currentValue.viewCount || 0) + 1;\n   *     return currentValue;\n   * };\n   * map.mutate('myKey', mutatorFunction, { ttl: 86400 })\n   *   .then(function(item) {\n   *     console.log('Map Item mutate() successful, new value:', item.value)\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map Item mutate() failed', error);\n   *   });\n   */\n\n\n  mutate(key, mutator, itemMetadataUpdates) {\n    var _this17 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17() {\n      return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n        while (1) switch (_context17.prev = _context17.next) {\n          case 0:\n            _this17.ensureNotClosed();\n\n            return _context17.abrupt(\"return\", _this17.syncMapImpl.mutate(key, mutator, itemMetadataUpdates));\n\n          case 2:\n          case \"end\":\n            return _context17.stop();\n        }\n      }, _callee17);\n    }))();\n  }\n  /**\n   * Modify a map item by appending new fields (or by overwriting existing ones) with the values from\n   * the provided Object. Creates a new item if no item by this key exists, copying all given fields and values\n   * into it.\n   * This is equivalent to\n   * <pre>\n   * map.mutate('myKey', function(currentValue) {\n   *   return Object.assign(currentValue, obj));\n   * });\n   * </pre>\n   * @param {String} key Selects the map item to update.\n   * @param {Object} obj Specifies the particular (top-level) attributes that will receive new values.\n   * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\n   * @returns {Promise<MapItem>} A promise resolving to the modified item in its new state.\n   * @public\n   * @example\n   * // Say, the Map Item (key: 'myKey') value is { name: 'John Smith' }\n   * map.update('myKey', { age: 34 }, { ttl: 86400 })\n   *   .then(function(item) {\n   *     // Now the Map Item value is { name: 'John Smith', age: 34 }\n   *     console.log('Map Item update() successful, new value:', item.value);\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map Item update() failed', error);\n   *   });\n   */\n\n\n  update(key, obj, itemMetadataUpdates) {\n    var _this18 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee18() {\n      return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n        while (1) switch (_context18.prev = _context18.next) {\n          case 0:\n            _this18.ensureNotClosed();\n\n            return _context18.abrupt(\"return\", _this18.syncMapImpl.update(key, obj, itemMetadataUpdates));\n\n          case 2:\n          case \"end\":\n            return _context18.stop();\n        }\n      }, _callee18);\n    }))();\n  }\n  /**\n   * Delete an item, given its key.\n   * @param {String} key Selects the item to delete.\n   * @returns {Promise<void>} A promise to remove an item.\n   * The promise will be rejected if 'key' is undefined or an item was not found.\n   * @public\n   * @example\n   * map.remove('myKey')\n   *   .then(function() {\n   *     console.log('Map Item remove() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map Item remove() failed', error);\n   *   });\n   */\n\n\n  remove(key) {\n    var _this19 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee19() {\n      return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n        while (1) switch (_context19.prev = _context19.next) {\n          case 0:\n            _this19.ensureNotClosed();\n\n            return _context19.abrupt(\"return\", _this19.syncMapImpl.remove(key));\n\n          case 2:\n          case \"end\":\n            return _context19.stop();\n        }\n      }, _callee19);\n    }))();\n  }\n  /**\n   * Get a complete list of items from the map.\n   * @param {Object} [args] Arguments for query.\n   * @param {String} [args.from] Item key, which should be used as the offset. If undefined, starts from the beginning or end depending on args.order.\n   * @param {Number} [args.pageSize=50] Result page size.\n   * @param {'asc'|'desc'} [args.order='asc'] Lexicographical order of results.\n   * @return {Promise<Paginator<MapItem>>}\n   * @public\n   * @example\n   * var pageHandler = function(paginator) {\n   *   paginator.items.forEach(function(item) {\n   *     console.log('Item ' + item.key + ': ', item.value);\n   *   });\n   *   return paginator.hasNextPage ? paginator.nextPage().then(pageHandler)\n   *                                : null;\n   * };\n   * map.getItems({ from: 'myKey', order: 'asc' })\n   *   .then(pageHandler)\n   *   .catch(function(error) {\n   *     console.error('Map getItems() failed', error);\n   *   });\n   */\n\n\n  getItems(args) {\n    var _this20 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee20() {\n      return _regeneratorRuntime.wrap(function _callee20$(_context20) {\n        while (1) switch (_context20.prev = _context20.next) {\n          case 0:\n            _this20.ensureNotClosed();\n\n            return _context20.abrupt(\"return\", _this20.syncMapImpl.getItems(args));\n\n          case 2:\n          case \"end\":\n            return _context20.stop();\n        }\n      }, _callee20);\n    }))();\n  }\n  /**\n   * Update the time-to-live of the map.\n   * @param {Number} ttl Specifies the TTL in seconds after which the map is subject to automatic deletion. The value 0 means infinity.\n   * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n   * @public\n   * @example\n   * map.setTtl(3600)\n   *   .then(function() {\n   *     console.log('Map setTtl() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map setTtl() failed', error);\n   *   });\n   */\n\n\n  setTtl(ttl) {\n    var _this21 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee21() {\n      return _regeneratorRuntime.wrap(function _callee21$(_context21) {\n        while (1) switch (_context21.prev = _context21.next) {\n          case 0:\n            _this21.ensureNotClosed();\n\n            return _context21.abrupt(\"return\", _this21.syncMapImpl.setTtl(ttl));\n\n          case 2:\n          case \"end\":\n            return _context21.stop();\n        }\n      }, _callee21);\n    }))();\n  }\n  /**\n   * Update the time-to-live of a map item.\n   * @param {Number} key Item key.\n   * @param {Number} ttl Specifies the TTL in seconds after which the map item is subject to automatic deletion. The value 0 means infinity.\n   * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n   * @public\n   * @example\n   * map.setItemTtl('myKey', 86400)\n   *   .then(function() {\n   *     console.log('Map setItemTtl() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map setItemTtl() failed', error);\n   *   });\n   */\n\n\n  setItemTtl(key, ttl) {\n    var _this22 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee22() {\n      return _regeneratorRuntime.wrap(function _callee22$(_context22) {\n        while (1) switch (_context22.prev = _context22.next) {\n          case 0:\n            _this22.ensureNotClosed();\n\n            return _context22.abrupt(\"return\", _this22.syncMapImpl.setItemTtl(key, ttl));\n\n          case 2:\n          case \"end\":\n            return _context22.stop();\n        }\n      }, _callee22);\n    }))();\n  }\n  /**\n   * Delete this map. It will be impossible to restore it.\n   * @return {Promise<void>} A promise that resolves when the map has been deleted.\n   * @public\n   * @example\n   * map.removeMap()\n   *   .then(function() {\n   *     console.log('Map removeMap() successful');\n   *   })\n   *   .catch(function(error) {\n   *     console.error('Map removeMap() failed', error);\n   *   });\n   */\n\n\n  removeMap() {\n    var _this23 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee23() {\n      return _regeneratorRuntime.wrap(function _callee23$(_context23) {\n        while (1) switch (_context23.prev = _context23.next) {\n          case 0:\n            _this23.ensureNotClosed();\n\n            _context23.next = 3;\n            return _this23.syncMapImpl.removeMap();\n\n          case 3:\n          case \"end\":\n            return _context23.stop();\n        }\n      }, _callee23);\n    }))();\n  }\n  /**\n   * Conclude work with the map instance and remove all event listeners attached to it.\n   * Any subsequent operation on this object will be rejected with error.\n   * Other local copies of this map will continue operating and receiving events normally.\n   * @public\n   * @example\n   * map.close();\n   */\n\n\n  close() {\n    super.close();\n    this.syncMapImpl.detach(this.listenerUuid);\n  }\n\n}\n\nexports.SyncMap = SyncMap;\nexports.default = SyncMap;\n/**\n * Contains Map Item metadata.\n * @typedef {Object} Map#ItemMetadata\n * @property {Number} [ttl] Specifies the time-to-live in seconds after which the map item is subject to automatic deletion.\n * The value 0 means infinity.\n */\n\n/**\n * Applies a transformation to the item value. May be called multiple times on the\n * same datum in case of collisions with remote code.\n * @callback Map~Mutator\n * @param {Object} currentValue The current value of the item in the cloud.\n * @return {Object} The desired new value for the item or <code>null</code> to gracefully cancel the mutation.\n */\n\n/**\n * Fired when a new item appears in the map, whether its creator was local or remote.\n * @event Map#itemAdded\n * @param {Object} args Arguments provided with the event.\n * @param {MapItem} args.item Added item.\n * @param {Boolean} args.isLocal Equals 'true' if item was added by local actor, 'false' otherwise.\n * @example\n * map.on('itemAdded', function(args) {\n *   console.log('Map item ' + args.item.key + ' was added');\n *   console.log('args.item.value:', args.item.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n\n/**\n * Fired when a map item is updated (not added or removed, but changed), whether the updater was local or remote.\n * @event Map#itemUpdated\n * @param {Object} args Arguments provided with the event.\n * @param {MapItem} args.item Updated item.\n * @param {Boolean} args.isLocal Equals 'true' if item was updated by local actor, 'false' otherwise.\n * @example\n * map.on('itemUpdated', function(args) {\n *   console.log('Map item ' + args.item.key + ' was updated');\n *   console.log('args.item.value:', args.item.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n\n/**\n * Fired when a map item is removed, whether the remover was local or remote.\n * @event Map#itemRemoved\n * @param {Object} args Arguments provided with the event.\n * @param {String} args.key The key of the removed item.\n * @param {Boolean} args.isLocal Equals 'true' if item was removed by local actor, 'false' otherwise.\n * @param {Object} args.value In case item was removed by a remote actor, contains a snapshot of item data before removal.\n * @example\n * map.on('itemRemoved', function(args) {\n *   console.log('Map item ' + args.key + ' was removed');\n *   console.log('args.value:', args.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n\n/**\n * Fired when a map is deleted entirely, by any actor local or remote.\n * @event Map#removed\n * @param {Object} args Arguments provided with the event.\n * @param {Boolean} args.isLocal Equals 'true' if map was removed by local actor, 'false' otherwise.\n * @example\n * map.on('removed', function(args) {\n *   console.log('Map ' + map.sid + ' was removed');\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */","map":{"version":3,"sources":["C:/Users/khouloud/Documents/PI/MERN_Stack_PI/node_modules/twilio-sync/lib/syncmap.js"],"names":["Object","defineProperty","exports","value","sanitize_1","require","uri_1","syncerror_1","logger_1","entity_1","mapitem_1","paginator_1","cache_1","mergingqueue_1","closeable_1","SyncMapImpl","SyncEntity","constructor","services","descriptor","removalHandler","updateRequestReducer","acc","input","ttl","updateMergingQueue","NamespacedMergingQueue","cache","Cache","date_updated","Date","items","forEach","itemDescriptor","store","key","MapItem","last_event_id","uri","url","links","revision","lastEventId","dateExpires","date_expires","type","indexName","undefined","queryString","sid","uniqueName","unique_name","dateUpdated","set","itemMetadataUpdates","validateOptionalTtl","squashAndAdd","_putItemUnconditionally","get","has","_getItemFromServer","queryItems","result","length","SyncError","mutate","mutator","add","_putItemWithIfMatch","update","obj","remote","assign","data","_putItemToServer","item","_handleItemMutated","added","mutatorFunction","catch","error","status","currentItem","deepClone","ifMatch","UriBuilder","pathSegment","build","requestBody","network","put","response","mapItemDescriptor","body","code","onRemoved","remove","Error","delete","_handleItemRemoved","args","queryParam","from","limit","pageToken","order","map","el","itemInCache","meta","Paginator","previous_token","next_token","getItems","validatePageSize","pageSize","shouldIgnoreEvent","eventId","isKnown","_update","isStrictlyOrdered","date_created","item_key","item_url","id","item_revision","item_data","_advanceLastEventId","map_revision","_updateRootDateUpdated","getTime","storage","default","trace","emitItemMutationEvent","updateDateExpires","eventName","broadcastEventToListeners","isLocal","oldData","locally","_unsubscribe","setTtl","validateMandatoryTtl","post","setItemTtl","existingItem","removeMap","SyncMap","Closeable","syncMapImpl","attach","ensureNotClosed","close","detach","listenerUuid"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst sanitize_1 = require(\"./utils/sanitize\");\nconst uri_1 = require(\"./utils/uri\");\nconst syncerror_1 = require(\"./utils/syncerror\");\nconst logger_1 = require(\"./utils/logger\");\nconst entity_1 = require(\"./entity\");\nconst mapitem_1 = require(\"./mapitem\");\nconst paginator_1 = require(\"./paginator\");\nconst cache_1 = require(\"./cache\");\nconst mergingqueue_1 = require(\"./mergingqueue\");\nconst closeable_1 = require(\"./closeable\");\nclass SyncMapImpl extends entity_1.SyncEntity {\n    /**\n     * @private\n     */\n    constructor(services, descriptor, removalHandler) {\n        super(services, removalHandler);\n        const updateRequestReducer = (acc, input) => (typeof input.ttl === 'number') ? { ttl: input.ttl }\n            : acc;\n        this.updateMergingQueue = new mergingqueue_1.NamespacedMergingQueue(updateRequestReducer);\n        this.cache = new cache_1.Cache();\n        this.descriptor = descriptor;\n        this.descriptor.date_updated = new Date(this.descriptor.date_updated);\n        if (descriptor.items) {\n            descriptor.items.forEach(itemDescriptor => {\n                itemDescriptor.date_updated = new Date(itemDescriptor.date_updated);\n                this.cache.store(itemDescriptor.key, new mapitem_1.MapItem(itemDescriptor), itemDescriptor.last_event_id);\n            });\n        }\n    }\n    // private props\n    get uri() {\n        return this.descriptor.url;\n    }\n    get links() {\n        return this.descriptor.links;\n    }\n    get revision() {\n        return this.descriptor.revision;\n    }\n    get lastEventId() {\n        return this.descriptor.last_event_id;\n    }\n    get dateExpires() {\n        return this.descriptor.date_expires;\n    }\n    static get type() {\n        return 'map';\n    }\n    get type() {\n        return 'map';\n    }\n    // below properties are specific to Insights only\n    get indexName() {\n        return undefined;\n    }\n    get queryString() {\n        return undefined;\n    }\n    // public props, documented along with class description\n    get sid() {\n        return this.descriptor.sid;\n    }\n    get uniqueName() {\n        return this.descriptor.unique_name || null;\n    }\n    get dateUpdated() {\n        return this.descriptor.date_updated;\n    }\n    async set(key, value, itemMetadataUpdates) {\n        const input = itemMetadataUpdates || {};\n        sanitize_1.validateOptionalTtl(input.ttl);\n        return this.updateMergingQueue.squashAndAdd(key, input, (input) => this._putItemUnconditionally(key, value, input.ttl));\n    }\n    async get(key) {\n        if (this.cache.has(key)) {\n            return this.cache.get(key);\n        }\n        else {\n            return this._getItemFromServer(key);\n        }\n    }\n    async _getItemFromServer(key) {\n        let result = await this.queryItems({ key: key });\n        if (result.items.length < 1) {\n            throw new syncerror_1.SyncError(`No item with key ${key} found`, 404, 54201);\n        }\n        else {\n            return result.items[0];\n        }\n    }\n    async mutate(key, mutator, itemMetadataUpdates) {\n        const input = itemMetadataUpdates || {};\n        sanitize_1.validateOptionalTtl(input.ttl);\n        return this.updateMergingQueue.add(key, input, (input) => this._putItemWithIfMatch(key, mutator, input.ttl));\n    }\n    async update(key, obj, itemMetadataUpdates) {\n        return this.mutate(key, remote => Object.assign(remote, obj), itemMetadataUpdates);\n    }\n    async _putItemUnconditionally(key, data, ttl) {\n        const result = await this._putItemToServer(key, data, undefined, ttl);\n        const item = result.item;\n        this._handleItemMutated(item.key, item.url, item.last_event_id, item.revision, item.data, item.date_updated, item.date_expires, result.added, false);\n        return this.cache.get(item.key);\n    }\n    async _putItemWithIfMatch(key, mutatorFunction, ttl) {\n        const currentItem = await this.get(key)\n            .catch(error => {\n            if (error.status === 404) {\n                // PUT /Items/myKey with `If-Match: -1` acts as \"put if not exists\"\n                return new mapitem_1.MapItem({ key: key, data: {}, last_event_id: -1, revision: '-1', url: null, date_updated: null, date_expires: null });\n            }\n            else {\n                throw error;\n            }\n        });\n        let data = mutatorFunction(sanitize_1.deepClone(currentItem.value));\n        if (data) {\n            let ifMatch = currentItem.revision;\n            try {\n                const result = await this._putItemToServer(key, data, ifMatch, ttl);\n                const item = result.item;\n                this._handleItemMutated(item.key, item.url, item.last_event_id, item.revision, item.data, item.date_updated, item.date_expires, result.added, false);\n                return this.cache.get(item.key);\n            }\n            catch (error) {\n                if (error.status === 412) {\n                    await this._getItemFromServer(key);\n                    return this._putItemWithIfMatch(key, mutatorFunction, ttl);\n                }\n                else {\n                    throw error;\n                }\n            }\n        }\n        else {\n            return currentItem;\n        }\n    }\n    async _putItemToServer(key, data, ifMatch, ttl) {\n        const url = new uri_1.UriBuilder(this.links.items).pathSegment(key).build();\n        const requestBody = { data };\n        if (ttl !== undefined) {\n            requestBody.ttl = ttl;\n        }\n        try {\n            const response = await this.services.network.put(url, requestBody, ifMatch);\n            const mapItemDescriptor = response.body;\n            mapItemDescriptor.data = data; // The server does not return the data in the response\n            mapItemDescriptor.date_updated = new Date(mapItemDescriptor.date_updated);\n            const added = response.status.code === 201;\n            return { added, item: mapItemDescriptor };\n        }\n        catch (error) {\n            if (error.status === 404) {\n                this.onRemoved(false);\n            }\n            throw error;\n        }\n    }\n    async remove(key) {\n        if (typeof key === 'undefined') {\n            throw new Error('Key argument is invalid');\n        }\n        let item = await this.get(key);\n        let response = await this.services.network.delete(item.uri);\n        this._handleItemRemoved(key, response.body.last_event_id, undefined, new Date(response.body.date_updated), false);\n    }\n    /**\n     * @private\n     */\n    async queryItems(args) {\n        args = args || {};\n        const uri = new uri_1.UriBuilder(this.links.items)\n            .queryParam('From', args.from)\n            .queryParam('PageSize', args.limit)\n            .queryParam('Key', args.key)\n            .queryParam('PageToken', args.pageToken)\n            .queryParam('Order', args.order)\n            .build();\n        let response = await this.services.network.get(uri);\n        let items = response.body.items.map(el => {\n            el.date_updated = new Date(el.date_updated);\n            let itemInCache = this.cache.get(el.key);\n            if (itemInCache) {\n                this._handleItemMutated(el.key, el.url, el.last_event_id, el.revision, el.data, el.date_updated, el.date_expires, false, true);\n            }\n            else {\n                this.cache.store(el.key, new mapitem_1.MapItem(el), el.last_event_id);\n            }\n            return this.cache.get(el.key);\n        });\n        const meta = response.body.meta;\n        return new paginator_1.Paginator(items, pageToken => this.queryItems({ pageToken }), meta.previous_token, meta.next_token);\n    }\n    async getItems(args) {\n        args = args || {};\n        sanitize_1.validatePageSize(args.pageSize);\n        args.limit = args.pageSize || args.limit || 50;\n        args.order = args.order || 'asc';\n        return this.queryItems(args);\n    }\n    shouldIgnoreEvent(key, eventId) {\n        return this.cache.isKnown(key, eventId);\n    }\n    /**\n     * Handle update from the server\n     * @private\n     */\n    _update(update, isStrictlyOrdered) {\n        update.date_created = new Date(update.date_created);\n        switch (update.type) {\n            case 'map_item_added':\n            case 'map_item_updated':\n                {\n                    this._handleItemMutated(update.item_key, update.item_url, update.id, update.item_revision, update.item_data, update.date_created, undefined, // orchestration events do not include date_expires\n                    update.type === 'map_item_added', true);\n                }\n                break;\n            case 'map_item_removed':\n                {\n                    this._handleItemRemoved(update.item_key, update.id, update.item_data, update.date_created, true);\n                }\n                break;\n            case 'map_removed':\n                {\n                    this.onRemoved(false);\n                }\n                break;\n        }\n        if (isStrictlyOrdered) {\n            this._advanceLastEventId(update.id, update.map_revision);\n        }\n    }\n    _advanceLastEventId(eventId, revision) {\n        if (this.lastEventId < eventId) {\n            this.descriptor.last_event_id = eventId;\n            if (revision) {\n                this.descriptor.revision = revision;\n            }\n        }\n    }\n    _updateRootDateUpdated(dateUpdated) {\n        if (!this.descriptor.date_updated || dateUpdated.getTime() > this.descriptor.date_updated.getTime()) {\n            this.descriptor.date_updated = dateUpdated;\n            this.services.storage.update(this.type, this.sid, this.uniqueName, { date_updated: dateUpdated });\n        }\n    }\n    _handleItemMutated(key, url, lastEventId, revision, value, dateUpdated, dateExpires, added, remote) {\n        if (this.shouldIgnoreEvent(key, lastEventId)) {\n            logger_1.default.trace('Item ', key, ' update skipped, current:', this.lastEventId, ', remote:', lastEventId);\n            return;\n        }\n        else {\n            this._updateRootDateUpdated(dateUpdated);\n            let item = this.cache.get(key);\n            if (!item) {\n                item = new mapitem_1.MapItem({ key: key, url, last_event_id: lastEventId, revision, data: value, date_updated: dateUpdated, date_expires: dateExpires });\n                this.cache.store(key, item, lastEventId);\n                this.emitItemMutationEvent(item, remote, added);\n            }\n            else {\n                item.update(lastEventId, revision, value, dateUpdated);\n                this.cache.store(key, item, lastEventId);\n                if (dateExpires !== undefined) {\n                    item.updateDateExpires(dateExpires);\n                }\n                this.emitItemMutationEvent(item, remote, false);\n            }\n        }\n    }\n    emitItemMutationEvent(item, remote, added) {\n        let eventName = added ? 'itemAdded' : 'itemUpdated';\n        this.broadcastEventToListeners(eventName, { item: item, isLocal: !remote });\n    }\n    /**\n     * @private\n     */\n    _handleItemRemoved(key, eventId, oldData, dateUpdated, remote) {\n        this._updateRootDateUpdated(dateUpdated);\n        this.cache.delete(key, eventId);\n        this.broadcastEventToListeners('itemRemoved', { key: key, isLocal: !remote, value: oldData });\n    }\n    onRemoved(locally) {\n        this._unsubscribe();\n        this.removalHandler(this.type, this.sid, this.uniqueName);\n        this.broadcastEventToListeners('removed', { isLocal: locally });\n    }\n    async setTtl(ttl) {\n        sanitize_1.validateMandatoryTtl(ttl);\n        try {\n            const requestBody = { ttl };\n            const response = await this.services.network.post(this.uri, requestBody);\n            this.descriptor.date_expires = response.body.date_expires;\n        }\n        catch (error) {\n            if (error.status === 404) {\n                this.onRemoved(false);\n            }\n            throw error;\n        }\n    }\n    async setItemTtl(key, ttl) {\n        sanitize_1.validateMandatoryTtl(ttl);\n        let existingItem = await this.get(key);\n        const requestBody = { ttl };\n        const response = await this.services.network.post(existingItem.uri, requestBody);\n        existingItem.updateDateExpires(response.body.date_expires);\n    }\n    async removeMap() {\n        await this.services.network.delete(this.uri);\n        this.onRemoved(true);\n    }\n}\nexports.SyncMapImpl = SyncMapImpl;\n/**\n * @class\n * @alias Map\n * @classdesc Represents a Sync Map, which stores an unordered set of key:value pairs.\n * Use the {@link Client#map} method to obtain a reference to a Sync Map.\n * @property {String} sid An immutable identifier (a SID) assigned by the system on creation.\n * @property {String} [uniqueName=null] - An optional immutable identifier that may be assigned by the\n * programmer to this map on creation. Unique among other Maps.\n * @property {Date} dateUpdated Date when the Map was last updated.\n *\n * @fires Map#removed\n * @fires Map#itemAdded\n * @fires Map#itemRemoved\n * @fires Map#itemUpdated\n */\nclass SyncMap extends closeable_1.Closeable {\n    constructor(syncMapImpl) {\n        super();\n        this.syncMapImpl = syncMapImpl;\n        this.syncMapImpl.attach(this);\n    }\n    // private props\n    get uri() {\n        return this.syncMapImpl.uri;\n    }\n    get links() {\n        return this.syncMapImpl.links;\n    }\n    get revision() {\n        return this.syncMapImpl.revision;\n    }\n    get lastEventId() {\n        return this.syncMapImpl.lastEventId;\n    }\n    get dateExpires() {\n        return this.syncMapImpl.dateExpires;\n    }\n    static get type() {\n        return SyncMapImpl.type;\n    }\n    get type() {\n        return SyncMapImpl.type;\n    }\n    // public props, documented along with class description\n    get sid() {\n        return this.syncMapImpl.sid;\n    }\n    get uniqueName() {\n        return this.syncMapImpl.uniqueName;\n    }\n    get dateUpdated() {\n        return this.syncMapImpl.dateUpdated;\n    }\n    /**\n     * Add a new item to the map with the given key:value pair. Overwrites any value that might already exist at that key.\n     * @param {String} key Unique item identifier.\n     * @param {Object} value Value to be set.\n     * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\n     * @returns {Promise<MapItem>} Newly added item, or modified one if already exists, with the latest known value.\n     * @public\n     * @example\n     * map.set('myKey', { name: 'John Smith' }, { ttl: 86400 })\n     *   .then(function(item) {\n     *     console.log('Map Item set() successful, item value:', item.value);\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map Item set() failed', error);\n     *   });\n     */\n    async set(key, value, itemMetadataUpdates) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.set(key, value, itemMetadataUpdates);\n    }\n    /**\n     * Retrieve an item by key.\n     * @param {String} key Identifies the desired item.\n     * @returns {Promise<MapItem>} A promise that resolves when the item has been fetched.\n     * This promise will be rejected if item was not found.\n     * @public\n     * @example\n     * map.get('myKey')\n     *   .then(function(item) {\n     *     console.log('Map Item get() successful, item value:', item.value)\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map Item get() failed', error);\n     *   });\n     */\n    async get(key) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.get(key);\n    }\n    /**\n     * Schedules a modification to this Map Item that will apply a mutation function.\n     * If no Item with the given key exists, it will first be created, having the default value (<code>{}</code>).\n     * @param {String} key Selects the map item to be mutated.\n     * @param {Map~Mutator} mutator A function that outputs a new value based on the existing value.\n     * May be called multiple times, particularly if this Map Item is modified concurrently by remote code.\n     * If the mutation ultimately succeeds, the Map Item will have made the particular transition described\n     * by this function.\n     * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\n     * @returns {Promise<MapItem>} Resolves with the most recent item state, the output of a successful\n     * mutation or a state that prompted graceful cancellation (mutator returned <code>null</code>).\n     * @public\n     * @example\n     * var mutatorFunction = function(currentValue) {\n     *     currentValue.viewCount = (currentValue.viewCount || 0) + 1;\n     *     return currentValue;\n     * };\n     * map.mutate('myKey', mutatorFunction, { ttl: 86400 })\n     *   .then(function(item) {\n     *     console.log('Map Item mutate() successful, new value:', item.value)\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map Item mutate() failed', error);\n     *   });\n     */\n    async mutate(key, mutator, itemMetadataUpdates) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.mutate(key, mutator, itemMetadataUpdates);\n    }\n    /**\n     * Modify a map item by appending new fields (or by overwriting existing ones) with the values from\n     * the provided Object. Creates a new item if no item by this key exists, copying all given fields and values\n     * into it.\n     * This is equivalent to\n     * <pre>\n     * map.mutate('myKey', function(currentValue) {\n     *   return Object.assign(currentValue, obj));\n     * });\n     * </pre>\n     * @param {String} key Selects the map item to update.\n     * @param {Object} obj Specifies the particular (top-level) attributes that will receive new values.\n     * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\n     * @returns {Promise<MapItem>} A promise resolving to the modified item in its new state.\n     * @public\n     * @example\n     * // Say, the Map Item (key: 'myKey') value is { name: 'John Smith' }\n     * map.update('myKey', { age: 34 }, { ttl: 86400 })\n     *   .then(function(item) {\n     *     // Now the Map Item value is { name: 'John Smith', age: 34 }\n     *     console.log('Map Item update() successful, new value:', item.value);\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map Item update() failed', error);\n     *   });\n     */\n    async update(key, obj, itemMetadataUpdates) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.update(key, obj, itemMetadataUpdates);\n    }\n    /**\n     * Delete an item, given its key.\n     * @param {String} key Selects the item to delete.\n     * @returns {Promise<void>} A promise to remove an item.\n     * The promise will be rejected if 'key' is undefined or an item was not found.\n     * @public\n     * @example\n     * map.remove('myKey')\n     *   .then(function() {\n     *     console.log('Map Item remove() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map Item remove() failed', error);\n     *   });\n     */\n    async remove(key) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.remove(key);\n    }\n    /**\n     * Get a complete list of items from the map.\n     * @param {Object} [args] Arguments for query.\n     * @param {String} [args.from] Item key, which should be used as the offset. If undefined, starts from the beginning or end depending on args.order.\n     * @param {Number} [args.pageSize=50] Result page size.\n     * @param {'asc'|'desc'} [args.order='asc'] Lexicographical order of results.\n     * @return {Promise<Paginator<MapItem>>}\n     * @public\n     * @example\n     * var pageHandler = function(paginator) {\n     *   paginator.items.forEach(function(item) {\n     *     console.log('Item ' + item.key + ': ', item.value);\n     *   });\n     *   return paginator.hasNextPage ? paginator.nextPage().then(pageHandler)\n     *                                : null;\n     * };\n     * map.getItems({ from: 'myKey', order: 'asc' })\n     *   .then(pageHandler)\n     *   .catch(function(error) {\n     *     console.error('Map getItems() failed', error);\n     *   });\n     */\n    async getItems(args) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.getItems(args);\n    }\n    /**\n     * Update the time-to-live of the map.\n     * @param {Number} ttl Specifies the TTL in seconds after which the map is subject to automatic deletion. The value 0 means infinity.\n     * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n     * @public\n     * @example\n     * map.setTtl(3600)\n     *   .then(function() {\n     *     console.log('Map setTtl() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map setTtl() failed', error);\n     *   });\n     */\n    async setTtl(ttl) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.setTtl(ttl);\n    }\n    /**\n     * Update the time-to-live of a map item.\n     * @param {Number} key Item key.\n     * @param {Number} ttl Specifies the TTL in seconds after which the map item is subject to automatic deletion. The value 0 means infinity.\n     * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n     * @public\n     * @example\n     * map.setItemTtl('myKey', 86400)\n     *   .then(function() {\n     *     console.log('Map setItemTtl() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map setItemTtl() failed', error);\n     *   });\n     */\n    async setItemTtl(key, ttl) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.setItemTtl(key, ttl);\n    }\n    /**\n     * Delete this map. It will be impossible to restore it.\n     * @return {Promise<void>} A promise that resolves when the map has been deleted.\n     * @public\n     * @example\n     * map.removeMap()\n     *   .then(function() {\n     *     console.log('Map removeMap() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map removeMap() failed', error);\n     *   });\n     */\n    async removeMap() {\n        this.ensureNotClosed();\n        await this.syncMapImpl.removeMap();\n    }\n    /**\n     * Conclude work with the map instance and remove all event listeners attached to it.\n     * Any subsequent operation on this object will be rejected with error.\n     * Other local copies of this map will continue operating and receiving events normally.\n     * @public\n     * @example\n     * map.close();\n     */\n    close() {\n        super.close();\n        this.syncMapImpl.detach(this.listenerUuid);\n    }\n}\nexports.SyncMap = SyncMap;\nexports.default = SyncMap;\n/**\n * Contains Map Item metadata.\n * @typedef {Object} Map#ItemMetadata\n * @property {Number} [ttl] Specifies the time-to-live in seconds after which the map item is subject to automatic deletion.\n * The value 0 means infinity.\n */\n/**\n * Applies a transformation to the item value. May be called multiple times on the\n * same datum in case of collisions with remote code.\n * @callback Map~Mutator\n * @param {Object} currentValue The current value of the item in the cloud.\n * @return {Object} The desired new value for the item or <code>null</code> to gracefully cancel the mutation.\n */\n/**\n * Fired when a new item appears in the map, whether its creator was local or remote.\n * @event Map#itemAdded\n * @param {Object} args Arguments provided with the event.\n * @param {MapItem} args.item Added item.\n * @param {Boolean} args.isLocal Equals 'true' if item was added by local actor, 'false' otherwise.\n * @example\n * map.on('itemAdded', function(args) {\n *   console.log('Map item ' + args.item.key + ' was added');\n *   console.log('args.item.value:', args.item.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n/**\n * Fired when a map item is updated (not added or removed, but changed), whether the updater was local or remote.\n * @event Map#itemUpdated\n * @param {Object} args Arguments provided with the event.\n * @param {MapItem} args.item Updated item.\n * @param {Boolean} args.isLocal Equals 'true' if item was updated by local actor, 'false' otherwise.\n * @example\n * map.on('itemUpdated', function(args) {\n *   console.log('Map item ' + args.item.key + ' was updated');\n *   console.log('args.item.value:', args.item.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n/**\n * Fired when a map item is removed, whether the remover was local or remote.\n * @event Map#itemRemoved\n * @param {Object} args Arguments provided with the event.\n * @param {String} args.key The key of the removed item.\n * @param {Boolean} args.isLocal Equals 'true' if item was removed by local actor, 'false' otherwise.\n * @param {Object} args.value In case item was removed by a remote actor, contains a snapshot of item data before removal.\n * @example\n * map.on('itemRemoved', function(args) {\n *   console.log('Map item ' + args.key + ' was removed');\n *   console.log('args.value:', args.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n/**\n * Fired when a map is deleted entirely, by any actor local or remote.\n * @event Map#removed\n * @param {Object} args Arguments provided with the event.\n * @param {Boolean} args.isLocal Equals 'true' if map was removed by local actor, 'false' otherwise.\n * @example\n * map.on('removed', function(args) {\n *   console.log('Map ' + map.sid + ' was removed');\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n"]},"metadata":{},"sourceType":"script"}