{"ast":null,"code":"'use strict';\n\nconst stream = require('stream');\n\nconst PerMessageDeflate = require('./permessage-deflate');\n\nconst bufferUtil = require('./buffer-util');\n\nconst validation = require('./validation');\n\nconst constants = require('./constants');\n\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\n/**\r\n * HyBi Receiver implementation.\r\n *\r\n * @extends stream.Writable\r\n */\n\nclass Receiver extends stream.Writable {\n  /**\r\n   * Creates a Receiver instance.\r\n   *\r\n   * @param {String} binaryType The type for binary data\r\n   * @param {Object} extensions An object containing the negotiated extensions\r\n   * @param {Number} maxPayload The maximum allowed message length\r\n   */\n  constructor(binaryType, extensions, maxPayload) {\n    super();\n    this._binaryType = binaryType || constants.BINARY_TYPES[0];\n    this[constants.kWebSocket] = undefined;\n    this._extensions = extensions || {};\n    this._maxPayload = maxPayload | 0;\n    this._bufferedBytes = 0;\n    this._buffers = [];\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = undefined;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n    this._state = GET_INFO;\n    this._loop = false;\n  }\n  /**\r\n   * Implements `Writable.prototype._write()`.\r\n   *\r\n   * @param {Buffer} chunk The chunk of data to write\r\n   * @param {String} encoding The character encoding of `chunk`\r\n   * @param {Function} cb Callback\r\n   */\n\n\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 0x08) return cb();\n    this._bufferedBytes += chunk.length;\n\n    this._buffers.push(chunk);\n\n    this.startLoop(cb);\n  }\n  /**\r\n   * Consumes `n` bytes from the buffered data.\r\n   *\r\n   * @param {Number} n The number of bytes to consume\r\n   * @return {Buffer} The consumed bytes\r\n   * @private\r\n   */\n\n\n  consume(n) {\n    this._bufferedBytes -= n;\n    if (n === this._buffers[0].length) return this._buffers.shift();\n\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = buf.slice(n);\n      return buf.slice(0, n);\n    }\n\n    const dst = Buffer.allocUnsafe(n);\n\n    do {\n      const buf = this._buffers[0];\n\n      if (n >= buf.length) {\n        this._buffers.shift().copy(dst, dst.length - n);\n      } else {\n        buf.copy(dst, dst.length - n, 0, n);\n        this._buffers[0] = buf.slice(n);\n      }\n\n      n -= buf.length;\n    } while (n > 0);\n\n    return dst;\n  }\n  /**\r\n   * Starts the parsing loop.\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\n\n\n  startLoop(cb) {\n    var err;\n    this._loop = true;\n\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          err = this.getInfo();\n          break;\n\n        case GET_PAYLOAD_LENGTH_16:\n          err = this.getPayloadLength16();\n          break;\n\n        case GET_PAYLOAD_LENGTH_64:\n          err = this.getPayloadLength64();\n          break;\n\n        case GET_MASK:\n          this.getMask();\n          break;\n\n        case GET_DATA:\n          err = this.getData(cb);\n          break;\n\n        default:\n          // `INFLATING`\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n\n    cb(err);\n  }\n  /**\r\n   * Reads the first two bytes of a frame.\r\n   *\r\n   * @return {(RangeError|undefined)} A possible error\r\n   * @private\r\n   */\n\n\n  getInfo() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(2);\n\n    if ((buf[0] & 0x30) !== 0x00) {\n      this._loop = false;\n      return error(RangeError, 'RSV2 and RSV3 must be clear', true, 1002);\n    }\n\n    const compressed = (buf[0] & 0x40) === 0x40;\n\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      this._loop = false;\n      return error(RangeError, 'RSV1 must be clear', true, 1002);\n    }\n\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        this._loop = false;\n        return error(RangeError, 'RSV1 must be clear', true, 1002);\n      }\n\n      if (!this._fragmented) {\n        this._loop = false;\n        return error(RangeError, 'invalid opcode 0', true, 1002);\n      }\n\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        this._loop = false;\n        return error(RangeError, \"invalid opcode \".concat(this._opcode), true, 1002);\n      }\n\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        this._loop = false;\n        return error(RangeError, 'FIN must be set', true, 1002);\n      }\n\n      if (compressed) {\n        this._loop = false;\n        return error(RangeError, 'RSV1 must be clear', true, 1002);\n      }\n\n      if (this._payloadLength > 0x7d) {\n        this._loop = false;\n        return error(RangeError, \"invalid payload length \".concat(this._payloadLength), true, 1002);\n      }\n    } else {\n      this._loop = false;\n      return error(RangeError, \"invalid opcode \".concat(this._opcode), true, 1002);\n    }\n\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 0x80) === 0x80;\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;else return this.haveLength();\n  }\n  /**\r\n   * Gets extended payload length (7+16).\r\n   *\r\n   * @return {(RangeError|undefined)} A possible error\r\n   * @private\r\n   */\n\n\n  getPayloadLength16() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    return this.haveLength();\n  }\n  /**\r\n   * Gets extended payload length (7+64).\r\n   *\r\n   * @return {(RangeError|undefined)} A possible error\r\n   * @private\r\n   */\n\n\n  getPayloadLength64() {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0); //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      this._loop = false;\n      return error(RangeError, 'Unsupported WebSocket frame: payload length > 2^53 - 1', false, 1009);\n    }\n\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    return this.haveLength();\n  }\n  /**\r\n   * Payload length has been read.\r\n   *\r\n   * @return {(RangeError|undefined)} A possible error\r\n   * @private\r\n   */\n\n\n  haveLength() {\n    if (this._payloadLength && this._opcode < 0x08) {\n      this._totalPayloadLength += this._payloadLength;\n\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        this._loop = false;\n        return error(RangeError, 'Max payload size exceeded', false, 1009);\n      }\n    }\n\n    if (this._masked) this._state = GET_MASK;else this._state = GET_DATA;\n  }\n  /**\r\n   * Reads mask bytes.\r\n   *\r\n   * @private\r\n   */\n\n\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n  /**\r\n   * Reads data bytes.\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @return {(Error|RangeError|undefined)} A possible error\r\n   * @private\r\n   */\n\n\n  getData(cb) {\n    var data = constants.EMPTY_BUFFER;\n\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n\n      data = this.consume(this._payloadLength);\n      if (this._masked) bufferUtil.unmask(data, this._mask);\n    }\n\n    if (this._opcode > 0x07) return this.controlMessage(data);\n\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n\n    if (data.length) {\n      //\n      // This message is not compressed so its lenght is the sum of the payload\n      // length of all fragments.\n      //\n      this._messageLength = this._totalPayloadLength;\n\n      this._fragments.push(data);\n    }\n\n    return this.dataMessage();\n  }\n  /**\r\n   * Decompresses data.\r\n   *\r\n   * @param {Buffer} data Compressed data\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\n\n\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) return cb(err);\n\n      if (buf.length) {\n        this._messageLength += buf.length;\n\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          return cb(error(RangeError, 'Max payload size exceeded', false, 1009));\n        }\n\n        this._fragments.push(buf);\n      }\n\n      const er = this.dataMessage();\n      if (er) return cb(er);\n      this.startLoop(cb);\n    });\n  }\n  /**\r\n   * Handles a data message.\r\n   *\r\n   * @return {(Error|undefined)} A possible error\r\n   * @private\r\n   */\n\n\n  dataMessage() {\n    if (this._fin) {\n      const messageLength = this._messageLength;\n      const fragments = this._fragments;\n      this._totalPayloadLength = 0;\n      this._messageLength = 0;\n      this._fragmented = 0;\n      this._fragments = [];\n\n      if (this._opcode === 2) {\n        var data;\n\n        if (this._binaryType === 'nodebuffer') {\n          data = toBuffer(fragments, messageLength);\n        } else if (this._binaryType === 'arraybuffer') {\n          data = toArrayBuffer(toBuffer(fragments, messageLength));\n        } else {\n          data = fragments;\n        }\n\n        this.emit('message', data);\n      } else {\n        const buf = toBuffer(fragments, messageLength);\n\n        if (!validation.isValidUTF8(buf)) {\n          this._loop = false;\n          return error(Error, 'invalid UTF-8 sequence', true, 1007);\n        }\n\n        this.emit('message', buf.toString());\n      }\n    }\n\n    this._state = GET_INFO;\n  }\n  /**\r\n   * Handles a control message.\r\n   *\r\n   * @param {Buffer} data Data to handle\r\n   * @return {(Error|RangeError|undefined)} A possible error\r\n   * @private\r\n   */\n\n\n  controlMessage(data) {\n    if (this._opcode === 0x08) {\n      this._loop = false;\n\n      if (data.length === 0) {\n        this.emit('conclude', 1005, '');\n        this.end();\n      } else if (data.length === 1) {\n        return error(RangeError, 'invalid payload length 1', true, 1002);\n      } else {\n        const code = data.readUInt16BE(0);\n\n        if (!validation.isValidStatusCode(code)) {\n          return error(RangeError, \"invalid status code \".concat(code), true, 1002);\n        }\n\n        const buf = data.slice(2);\n\n        if (!validation.isValidUTF8(buf)) {\n          return error(Error, 'invalid UTF-8 sequence', true, 1007);\n        }\n\n        this.emit('conclude', code, buf.toString());\n        this.end();\n      }\n\n      return;\n    }\n\n    if (this._opcode === 0x09) this.emit('ping', data);else this.emit('pong', data);\n    this._state = GET_INFO;\n  }\n\n}\n\nmodule.exports = Receiver;\n/**\r\n * Builds an error object.\r\n *\r\n * @param {(Error|RangeError)} ErrorCtor The error constructor\r\n * @param {String} message The error message\r\n * @param {Boolean} prefix Specifies whether or not to add a default prefix to\r\n *     `message`\r\n * @param {Number} statusCode The status code\r\n * @return {(Error|RangeError)} The error\r\n * @private\r\n */\n\nfunction error(ErrorCtor, message, prefix, statusCode) {\n  const err = new ErrorCtor(prefix ? \"Invalid WebSocket frame: \".concat(message) : message);\n  Error.captureStackTrace(err, error);\n  err[constants.kStatusCode] = statusCode;\n  return err;\n}\n/**\r\n * Makes a buffer from a list of fragments.\r\n *\r\n * @param {Buffer[]} fragments The list of fragments composing the message\r\n * @param {Number} messageLength The length of the message\r\n * @return {Buffer}\r\n * @private\r\n */\n\n\nfunction toBuffer(fragments, messageLength) {\n  if (fragments.length === 1) return fragments[0];\n  if (fragments.length > 1) return bufferUtil.concat(fragments, messageLength);\n  return constants.EMPTY_BUFFER;\n}\n/**\r\n * Converts a buffer to an `ArrayBuffer`.\r\n *\r\n * @param {Buffer} The buffer to convert\r\n * @return {ArrayBuffer} Converted buffer\r\n */\n\n\nfunction toArrayBuffer(buf) {\n  if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n}","map":{"version":3,"sources":["C:/Users/khouloud/Documents/PI/MERN_Stack_PI/node_modules/ws/lib/receiver.js"],"names":["stream","require","PerMessageDeflate","bufferUtil","validation","constants","GET_INFO","GET_PAYLOAD_LENGTH_16","GET_PAYLOAD_LENGTH_64","GET_MASK","GET_DATA","INFLATING","Receiver","Writable","constructor","binaryType","extensions","maxPayload","_binaryType","BINARY_TYPES","kWebSocket","undefined","_extensions","_maxPayload","_bufferedBytes","_buffers","_compressed","_payloadLength","_mask","_fragmented","_masked","_fin","_opcode","_totalPayloadLength","_messageLength","_fragments","_state","_loop","_write","chunk","encoding","cb","length","push","startLoop","consume","n","shift","buf","slice","dst","Buffer","allocUnsafe","copy","err","getInfo","getPayloadLength16","getPayloadLength64","getMask","getData","error","RangeError","compressed","extensionName","haveLength","readUInt16BE","num","readUInt32BE","Math","pow","data","EMPTY_BUFFER","unmask","controlMessage","decompress","dataMessage","perMessageDeflate","er","messageLength","fragments","toBuffer","toArrayBuffer","emit","isValidUTF8","Error","toString","end","code","isValidStatusCode","module","exports","ErrorCtor","message","prefix","statusCode","captureStackTrace","kStatusCode","concat","byteOffset","byteLength","buffer"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst stream = require('stream');\r\n\r\nconst PerMessageDeflate = require('./permessage-deflate');\r\nconst bufferUtil = require('./buffer-util');\r\nconst validation = require('./validation');\r\nconst constants = require('./constants');\r\n\r\nconst GET_INFO = 0;\r\nconst GET_PAYLOAD_LENGTH_16 = 1;\r\nconst GET_PAYLOAD_LENGTH_64 = 2;\r\nconst GET_MASK = 3;\r\nconst GET_DATA = 4;\r\nconst INFLATING = 5;\r\n\r\n/**\r\n * HyBi Receiver implementation.\r\n *\r\n * @extends stream.Writable\r\n */\r\nclass Receiver extends stream.Writable {\r\n  /**\r\n   * Creates a Receiver instance.\r\n   *\r\n   * @param {String} binaryType The type for binary data\r\n   * @param {Object} extensions An object containing the negotiated extensions\r\n   * @param {Number} maxPayload The maximum allowed message length\r\n   */\r\n  constructor (binaryType, extensions, maxPayload) {\r\n    super();\r\n\r\n    this._binaryType = binaryType || constants.BINARY_TYPES[0];\r\n    this[constants.kWebSocket] = undefined;\r\n    this._extensions = extensions || {};\r\n    this._maxPayload = maxPayload | 0;\r\n\r\n    this._bufferedBytes = 0;\r\n    this._buffers = [];\r\n\r\n    this._compressed = false;\r\n    this._payloadLength = 0;\r\n    this._mask = undefined;\r\n    this._fragmented = 0;\r\n    this._masked = false;\r\n    this._fin = false;\r\n    this._opcode = 0;\r\n\r\n    this._totalPayloadLength = 0;\r\n    this._messageLength = 0;\r\n    this._fragments = [];\r\n\r\n    this._state = GET_INFO;\r\n    this._loop = false;\r\n  }\r\n\r\n  /**\r\n   * Implements `Writable.prototype._write()`.\r\n   *\r\n   * @param {Buffer} chunk The chunk of data to write\r\n   * @param {String} encoding The character encoding of `chunk`\r\n   * @param {Function} cb Callback\r\n   */\r\n  _write (chunk, encoding, cb) {\r\n    if (this._opcode === 0x08) return cb();\r\n\r\n    this._bufferedBytes += chunk.length;\r\n    this._buffers.push(chunk);\r\n    this.startLoop(cb);\r\n  }\r\n\r\n  /**\r\n   * Consumes `n` bytes from the buffered data.\r\n   *\r\n   * @param {Number} n The number of bytes to consume\r\n   * @return {Buffer} The consumed bytes\r\n   * @private\r\n   */\r\n  consume (n) {\r\n    this._bufferedBytes -= n;\r\n\r\n    if (n === this._buffers[0].length) return this._buffers.shift();\r\n\r\n    if (n < this._buffers[0].length) {\r\n      const buf = this._buffers[0];\r\n      this._buffers[0] = buf.slice(n);\r\n      return buf.slice(0, n);\r\n    }\r\n\r\n    const dst = Buffer.allocUnsafe(n);\r\n\r\n    do {\r\n      const buf = this._buffers[0];\r\n\r\n      if (n >= buf.length) {\r\n        this._buffers.shift().copy(dst, dst.length - n);\r\n      } else {\r\n        buf.copy(dst, dst.length - n, 0, n);\r\n        this._buffers[0] = buf.slice(n);\r\n      }\r\n\r\n      n -= buf.length;\r\n    } while (n > 0);\r\n\r\n    return dst;\r\n  }\r\n\r\n  /**\r\n   * Starts the parsing loop.\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  startLoop (cb) {\r\n    var err;\r\n    this._loop = true;\r\n\r\n    do {\r\n      switch (this._state) {\r\n        case GET_INFO:\r\n          err = this.getInfo();\r\n          break;\r\n        case GET_PAYLOAD_LENGTH_16:\r\n          err = this.getPayloadLength16();\r\n          break;\r\n        case GET_PAYLOAD_LENGTH_64:\r\n          err = this.getPayloadLength64();\r\n          break;\r\n        case GET_MASK:\r\n          this.getMask();\r\n          break;\r\n        case GET_DATA:\r\n          err = this.getData(cb);\r\n          break;\r\n        default: // `INFLATING`\r\n          this._loop = false;\r\n          return;\r\n      }\r\n    } while (this._loop);\r\n\r\n    cb(err);\r\n  }\r\n\r\n  /**\r\n   * Reads the first two bytes of a frame.\r\n   *\r\n   * @return {(RangeError|undefined)} A possible error\r\n   * @private\r\n   */\r\n  getInfo () {\r\n    if (this._bufferedBytes < 2) {\r\n      this._loop = false;\r\n      return;\r\n    }\r\n\r\n    const buf = this.consume(2);\r\n\r\n    if ((buf[0] & 0x30) !== 0x00) {\r\n      this._loop = false;\r\n      return error(RangeError, 'RSV2 and RSV3 must be clear', true, 1002);\r\n    }\r\n\r\n    const compressed = (buf[0] & 0x40) === 0x40;\r\n\r\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\r\n      this._loop = false;\r\n      return error(RangeError, 'RSV1 must be clear', true, 1002);\r\n    }\r\n\r\n    this._fin = (buf[0] & 0x80) === 0x80;\r\n    this._opcode = buf[0] & 0x0f;\r\n    this._payloadLength = buf[1] & 0x7f;\r\n\r\n    if (this._opcode === 0x00) {\r\n      if (compressed) {\r\n        this._loop = false;\r\n        return error(RangeError, 'RSV1 must be clear', true, 1002);\r\n      }\r\n\r\n      if (!this._fragmented) {\r\n        this._loop = false;\r\n        return error(RangeError, 'invalid opcode 0', true, 1002);\r\n      }\r\n\r\n      this._opcode = this._fragmented;\r\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\r\n      if (this._fragmented) {\r\n        this._loop = false;\r\n        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);\r\n      }\r\n\r\n      this._compressed = compressed;\r\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\r\n      if (!this._fin) {\r\n        this._loop = false;\r\n        return error(RangeError, 'FIN must be set', true, 1002);\r\n      }\r\n\r\n      if (compressed) {\r\n        this._loop = false;\r\n        return error(RangeError, 'RSV1 must be clear', true, 1002);\r\n      }\r\n\r\n      if (this._payloadLength > 0x7d) {\r\n        this._loop = false;\r\n        return error(\r\n          RangeError,\r\n          `invalid payload length ${this._payloadLength}`,\r\n          true,\r\n          1002\r\n        );\r\n      }\r\n    } else {\r\n      this._loop = false;\r\n      return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);\r\n    }\r\n\r\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\r\n    this._masked = (buf[1] & 0x80) === 0x80;\r\n\r\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\r\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\r\n    else return this.haveLength();\r\n  }\r\n\r\n  /**\r\n   * Gets extended payload length (7+16).\r\n   *\r\n   * @return {(RangeError|undefined)} A possible error\r\n   * @private\r\n   */\r\n  getPayloadLength16 () {\r\n    if (this._bufferedBytes < 2) {\r\n      this._loop = false;\r\n      return;\r\n    }\r\n\r\n    this._payloadLength = this.consume(2).readUInt16BE(0);\r\n    return this.haveLength();\r\n  }\r\n\r\n  /**\r\n   * Gets extended payload length (7+64).\r\n   *\r\n   * @return {(RangeError|undefined)} A possible error\r\n   * @private\r\n   */\r\n  getPayloadLength64 () {\r\n    if (this._bufferedBytes < 8) {\r\n      this._loop = false;\r\n      return;\r\n    }\r\n\r\n    const buf = this.consume(8);\r\n    const num = buf.readUInt32BE(0);\r\n\r\n    //\r\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\r\n    // if payload length is greater than this number.\r\n    //\r\n    if (num > Math.pow(2, 53 - 32) - 1) {\r\n      this._loop = false;\r\n      return error(\r\n        RangeError,\r\n        'Unsupported WebSocket frame: payload length > 2^53 - 1',\r\n        false,\r\n        1009\r\n      );\r\n    }\r\n\r\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\r\n    return this.haveLength();\r\n  }\r\n\r\n  /**\r\n   * Payload length has been read.\r\n   *\r\n   * @return {(RangeError|undefined)} A possible error\r\n   * @private\r\n   */\r\n  haveLength () {\r\n    if (this._payloadLength && this._opcode < 0x08) {\r\n      this._totalPayloadLength += this._payloadLength;\r\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\r\n        this._loop = false;\r\n        return error(RangeError, 'Max payload size exceeded', false, 1009);\r\n      }\r\n    }\r\n\r\n    if (this._masked) this._state = GET_MASK;\r\n    else this._state = GET_DATA;\r\n  }\r\n\r\n  /**\r\n   * Reads mask bytes.\r\n   *\r\n   * @private\r\n   */\r\n  getMask () {\r\n    if (this._bufferedBytes < 4) {\r\n      this._loop = false;\r\n      return;\r\n    }\r\n\r\n    this._mask = this.consume(4);\r\n    this._state = GET_DATA;\r\n  }\r\n\r\n  /**\r\n   * Reads data bytes.\r\n   *\r\n   * @param {Function} cb Callback\r\n   * @return {(Error|RangeError|undefined)} A possible error\r\n   * @private\r\n   */\r\n  getData (cb) {\r\n    var data = constants.EMPTY_BUFFER;\r\n\r\n    if (this._payloadLength) {\r\n      if (this._bufferedBytes < this._payloadLength) {\r\n        this._loop = false;\r\n        return;\r\n      }\r\n\r\n      data = this.consume(this._payloadLength);\r\n      if (this._masked) bufferUtil.unmask(data, this._mask);\r\n    }\r\n\r\n    if (this._opcode > 0x07) return this.controlMessage(data);\r\n\r\n    if (this._compressed) {\r\n      this._state = INFLATING;\r\n      this.decompress(data, cb);\r\n      return;\r\n    }\r\n\r\n    if (data.length) {\r\n      //\r\n      // This message is not compressed so its lenght is the sum of the payload\r\n      // length of all fragments.\r\n      //\r\n      this._messageLength = this._totalPayloadLength;\r\n      this._fragments.push(data);\r\n    }\r\n\r\n    return this.dataMessage();\r\n  }\r\n\r\n  /**\r\n   * Decompresses data.\r\n   *\r\n   * @param {Buffer} data Compressed data\r\n   * @param {Function} cb Callback\r\n   * @private\r\n   */\r\n  decompress (data, cb) {\r\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\r\n\r\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\r\n      if (err) return cb(err);\r\n\r\n      if (buf.length) {\r\n        this._messageLength += buf.length;\r\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\r\n          return cb(error(RangeError, 'Max payload size exceeded', false, 1009));\r\n        }\r\n\r\n        this._fragments.push(buf);\r\n      }\r\n\r\n      const er = this.dataMessage();\r\n      if (er) return cb(er);\r\n\r\n      this.startLoop(cb);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handles a data message.\r\n   *\r\n   * @return {(Error|undefined)} A possible error\r\n   * @private\r\n   */\r\n  dataMessage () {\r\n    if (this._fin) {\r\n      const messageLength = this._messageLength;\r\n      const fragments = this._fragments;\r\n\r\n      this._totalPayloadLength = 0;\r\n      this._messageLength = 0;\r\n      this._fragmented = 0;\r\n      this._fragments = [];\r\n\r\n      if (this._opcode === 2) {\r\n        var data;\r\n\r\n        if (this._binaryType === 'nodebuffer') {\r\n          data = toBuffer(fragments, messageLength);\r\n        } else if (this._binaryType === 'arraybuffer') {\r\n          data = toArrayBuffer(toBuffer(fragments, messageLength));\r\n        } else {\r\n          data = fragments;\r\n        }\r\n\r\n        this.emit('message', data);\r\n      } else {\r\n        const buf = toBuffer(fragments, messageLength);\r\n\r\n        if (!validation.isValidUTF8(buf)) {\r\n          this._loop = false;\r\n          return error(Error, 'invalid UTF-8 sequence', true, 1007);\r\n        }\r\n\r\n        this.emit('message', buf.toString());\r\n      }\r\n    }\r\n\r\n    this._state = GET_INFO;\r\n  }\r\n\r\n  /**\r\n   * Handles a control message.\r\n   *\r\n   * @param {Buffer} data Data to handle\r\n   * @return {(Error|RangeError|undefined)} A possible error\r\n   * @private\r\n   */\r\n  controlMessage (data) {\r\n    if (this._opcode === 0x08) {\r\n      this._loop = false;\r\n\r\n      if (data.length === 0) {\r\n        this.emit('conclude', 1005, '');\r\n        this.end();\r\n      } else if (data.length === 1) {\r\n        return error(RangeError, 'invalid payload length 1', true, 1002);\r\n      } else {\r\n        const code = data.readUInt16BE(0);\r\n\r\n        if (!validation.isValidStatusCode(code)) {\r\n          return error(RangeError, `invalid status code ${code}`, true, 1002);\r\n        }\r\n\r\n        const buf = data.slice(2);\r\n\r\n        if (!validation.isValidUTF8(buf)) {\r\n          return error(Error, 'invalid UTF-8 sequence', true, 1007);\r\n        }\r\n\r\n        this.emit('conclude', code, buf.toString());\r\n        this.end();\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    if (this._opcode === 0x09) this.emit('ping', data);\r\n    else this.emit('pong', data);\r\n\r\n    this._state = GET_INFO;\r\n  }\r\n}\r\n\r\nmodule.exports = Receiver;\r\n\r\n/**\r\n * Builds an error object.\r\n *\r\n * @param {(Error|RangeError)} ErrorCtor The error constructor\r\n * @param {String} message The error message\r\n * @param {Boolean} prefix Specifies whether or not to add a default prefix to\r\n *     `message`\r\n * @param {Number} statusCode The status code\r\n * @return {(Error|RangeError)} The error\r\n * @private\r\n */\r\nfunction error (ErrorCtor, message, prefix, statusCode) {\r\n  const err = new ErrorCtor(\r\n    prefix ? `Invalid WebSocket frame: ${message}` : message\r\n  );\r\n\r\n  Error.captureStackTrace(err, error);\r\n  err[constants.kStatusCode] = statusCode;\r\n  return err;\r\n}\r\n\r\n/**\r\n * Makes a buffer from a list of fragments.\r\n *\r\n * @param {Buffer[]} fragments The list of fragments composing the message\r\n * @param {Number} messageLength The length of the message\r\n * @return {Buffer}\r\n * @private\r\n */\r\nfunction toBuffer (fragments, messageLength) {\r\n  if (fragments.length === 1) return fragments[0];\r\n  if (fragments.length > 1) return bufferUtil.concat(fragments, messageLength);\r\n  return constants.EMPTY_BUFFER;\r\n}\r\n\r\n/**\r\n * Converts a buffer to an `ArrayBuffer`.\r\n *\r\n * @param {Buffer} The buffer to convert\r\n * @return {ArrayBuffer} Converted buffer\r\n */\r\nfunction toArrayBuffer (buf) {\r\n  if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {\r\n    return buf.buffer;\r\n  }\r\n\r\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\r\n}\r\n"]},"metadata":{},"sourceType":"script"}