{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\khouloud\\\\Documents\\\\PI\\\\MERN_Stack_PI\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\khouloud\\\\Documents\\\\PI\\\\MERN_Stack_PI\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\khouloud\\\\Documents\\\\PI\\\\MERN_Stack_PI\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst operation_retrier_1 = require(\"operation-retrier\");\n\nconst syncerror_1 = require(\"./utils/syncerror\");\n\nconst logger_1 = require(\"./utils/logger\");\n\nconst twilsock_1 = require(\"twilsock\");\n/**\n * A data container used by the Subscriptions class to track subscribed entities' local\n * representations and their state.\n */\n\n\nclass SubscribedEntity {\n  constructor(entity) {\n    this.localObject = entity;\n    this.pendingCorrelationId = null;\n    this.pendingAction = null;\n    this.established = false;\n    this.retryCount = 0;\n  }\n\n  get sid() {\n    return this.localObject.sid;\n  }\n\n  get type() {\n    return this.localObject.type;\n  }\n\n  get lastEventId() {\n    return this.localObject.lastEventId;\n  } // below properties are specific to Insights only\n\n\n  get indexName() {\n    return this.localObject.indexName;\n  }\n\n  get queryString() {\n    return this.localObject.queryString;\n  }\n\n  get isEstablished() {\n    return this.established;\n  }\n\n  update(event, isStrictlyOrdered) {\n    this.localObject._update(event, isStrictlyOrdered);\n  }\n\n  updatePending(action, correlationId) {\n    this.pendingAction = action;\n    this.pendingCorrelationId = correlationId;\n  }\n\n  reset() {\n    this.updatePending(null, null);\n    this.retryCount = 0;\n    this.established = false;\n    this.setSubscriptionState('none');\n  }\n\n  markAsFailed(message) {\n    this.rejectedWithError = message.error;\n    this.updatePending(null, null);\n    this.localObject.reportFailure(new syncerror_1.SyncError(\"Failed to subscribe on service events: \".concat(message.error.message), message.error.status, message.error.code));\n  }\n\n  complete(eventId) {\n    this.updatePending(null, null);\n    this.established = true;\n\n    this.localObject._advanceLastEventId(eventId);\n  }\n\n  setSubscriptionState(newState) {\n    this.localObject._setSubscriptionState(newState);\n  }\n\n}\n/**\n * @class Subscriptions\n * @classdesc A manager which, in batches of varying size, continuously persists the\n *      subscription intent of the caller to the Sync backend until it achieves a\n *      converged state.\n */\n\n\nclass Subscriptions {\n  /**\n   * @constructor\n   * Prepares a new Subscriptions manager object with zero subscribed or persisted subscriptions.\n   *\n   * @param {object} config may include a key 'backoffConfig', wherein any of the parameters\n   *      of Backoff.exponential (from npm 'backoff') are valid and will override the defaults.\n   *\n   * @param {Network} must be a viable running Sync Network object, useful for routing requests.\n   */\n  constructor(services) {\n    this.isConnected = false;\n    this.maxBatchSize = 100; // If the server includes a `ttl_in_s` attribute in the poke response, subscriptionTtlTimer is started for that duration\n    // such that when it fires, it repokes the entire sync set (i.e., emulates a reconnect). Every reconnect resets the timer.\n    // After the timer has fired, the first poke request includes a `reason: ttl` attribute in the body.\n\n    this.subscriptionTtlTimer = null;\n    this.pendingPokeReason = null;\n    this.services = services;\n    this.subscriptions = new Map();\n    this.persisted = new Map();\n    this.latestPokeResponseArrivalTimestampByCorrelationId = new Map();\n    const defaultBackoffConfig = {\n      randomisationFactor: 0.2,\n      initialDelay: 100,\n      maxDelay: 2 * 60 * 1000\n    };\n    this.backoff = operation_retrier_1.Backoff.exponential(Object.assign(defaultBackoffConfig, this.services.config.backoffConfig)); // This block is triggered by #_persist. Every request is executed in a series of (ideally 1)\n    // backoff 'ready' event, at which point a new subscription set is calculated.\n\n    this.backoff.on('ready', () => {\n      let _this$getSubscription = this.getSubscriptionUpdateBatch(),\n          action = _this$getSubscription.action,\n          subscriptionRequests = _this$getSubscription.subscriptions;\n\n      if (action) {\n        this.applyNewSubscriptionUpdateBatch(action, subscriptionRequests);\n      } else {\n        this.backoff.reset();\n        logger_1.default.debug('All subscriptions resolved.');\n      }\n    });\n  }\n\n  getSubscriptionUpdateBatch() {\n    function subtract(these, those, action, limit) {\n      let result = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = these[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          let _step$value = _slicedToArray(_step.value, 2),\n              thisKey = _step$value[0],\n              thisValue = _step$value[1];\n\n          const otherValue = those.get(thisKey);\n\n          if (!otherValue && action !== thisValue.pendingAction && !thisValue.rejectedWithError) {\n            result.push(thisValue);\n\n            if (limit && result.length >= limit) {\n              break;\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return result;\n    }\n\n    let listToAdd = subtract(this.subscriptions, this.persisted, 'establish', this.maxBatchSize);\n\n    if (listToAdd.length > 0) {\n      return {\n        action: 'establish',\n        subscriptions: listToAdd\n      };\n    }\n\n    let listToRemove = subtract(this.persisted, this.subscriptions, 'cancel', this.maxBatchSize);\n\n    if (listToRemove.length > 0) {\n      return {\n        action: 'cancel',\n        subscriptions: listToRemove\n      };\n    }\n\n    return {\n      action: null,\n      subscriptions: null\n    };\n  }\n\n  persist() {\n    this.backoff.backoff();\n  }\n\n  applyNewSubscriptionUpdateBatch(action, requests) {\n    var _this = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var correlationId, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, subscribed, reason, response, newMaxBatchSize, subscriptionTtlInS, isNumeric, isValidTtl, estimatedDeliveryInMs, isValidTimeout, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, attemptedSubscription;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            if (_this.isConnected) {\n              _context.next = 4;\n              break;\n            }\n\n            logger_1.default.debug(\"Twilsock connection (required for subscription) not ready; waiting\\u2026\");\n\n            _this.backoff.reset();\n\n            return _context.abrupt(\"return\");\n\n          case 4:\n            // Keeping in mind that events may begin flowing _before_ we receive the response\n            requests = _this.processLocalActions(action, requests);\n            correlationId = new Date().getTime();\n            _iteratorNormalCompletion2 = true;\n            _didIteratorError2 = false;\n            _iteratorError2 = undefined;\n            _context.prev = 9;\n\n            for (_iterator2 = requests[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              subscribed = _step2.value;\n\n              _this.recordActionAttemptOn(subscribed, action, correlationId);\n            }\n\n            _context.next = 17;\n            break;\n\n          case 13:\n            _context.prev = 13;\n            _context.t0 = _context[\"catch\"](9);\n            _didIteratorError2 = true;\n            _iteratorError2 = _context.t0;\n\n          case 17:\n            _context.prev = 17;\n            _context.prev = 18;\n\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n\n          case 20:\n            _context.prev = 20;\n\n            if (!_didIteratorError2) {\n              _context.next = 23;\n              break;\n            }\n\n            throw _iteratorError2;\n\n          case 23:\n            return _context.finish(20);\n\n          case 24:\n            return _context.finish(17);\n\n          case 25:\n            reason = _this.pendingPokeReason;\n            _this.pendingPokeReason = null; // Send this batch to the service\n\n            _context.prev = 27;\n            _context.next = 30;\n            return _this.request(action, correlationId, reason, requests);\n\n          case 30:\n            response = _context.sent;\n            newMaxBatchSize = response.body.max_batch_size;\n\n            if (!isNaN(parseInt(newMaxBatchSize)) && isFinite(newMaxBatchSize) && newMaxBatchSize > 0) {\n              _this.maxBatchSize = newMaxBatchSize;\n            }\n\n            if (!_this.subscriptionTtlTimer) {\n              subscriptionTtlInS = response.body.ttl_in_s;\n              isNumeric = !isNaN(parseFloat(subscriptionTtlInS)) && isFinite(subscriptionTtlInS);\n              isValidTtl = isNumeric && subscriptionTtlInS > 0;\n\n              if (isValidTtl) {\n                _this.subscriptionTtlTimer = setTimeout(() => _this.onSubscriptionTtlElapsed(), subscriptionTtlInS * 1000);\n              }\n            }\n\n            if (action === 'establish') {\n              estimatedDeliveryInMs = response.body.estimated_delivery_in_ms;\n              isNumeric = !isNaN(parseFloat(estimatedDeliveryInMs)) && isFinite(estimatedDeliveryInMs);\n              isValidTimeout = isNumeric && estimatedDeliveryInMs > 0;\n\n              if (isValidTimeout) {\n                setTimeout(() => _this.verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests), estimatedDeliveryInMs);\n              } else {\n                logger_1.default.error(\"Invalid timeout: \".concat(estimatedDeliveryInMs));\n              }\n\n              requests.filter(r => r.pendingCorrelationId === correlationId).forEach(r => r.setSubscriptionState('response_in_flight'));\n            }\n\n            _this.backoff.reset();\n\n            _context.next = 60;\n            break;\n\n          case 38:\n            _context.prev = 38;\n            _context.t1 = _context[\"catch\"](27);\n            _iteratorNormalCompletion3 = true;\n            _didIteratorError3 = false;\n            _iteratorError3 = undefined;\n            _context.prev = 43;\n\n            for (_iterator3 = requests[Symbol.iterator](); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n              attemptedSubscription = _step3.value;\n\n              _this.recordActionFailureOn(attemptedSubscription, action);\n            }\n\n            _context.next = 51;\n            break;\n\n          case 47:\n            _context.prev = 47;\n            _context.t2 = _context[\"catch\"](43);\n            _didIteratorError3 = true;\n            _iteratorError3 = _context.t2;\n\n          case 51:\n            _context.prev = 51;\n            _context.prev = 52;\n\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              _iterator3.return();\n            }\n\n          case 54:\n            _context.prev = 54;\n\n            if (!_didIteratorError3) {\n              _context.next = 57;\n              break;\n            }\n\n            throw _iteratorError3;\n\n          case 57:\n            return _context.finish(54);\n\n          case 58:\n            return _context.finish(51);\n\n          case 59:\n            if (_context.t1 instanceof twilsock_1.TransportUnavailableError) {\n              logger_1.default.debug(\"Twilsock connection (required for subscription) not ready (c:\".concat(correlationId, \"); waiting\\u2026\"));\n\n              _this.backoff.reset();\n            } else {\n              logger_1.default.debug(\"Failed an attempt to \".concat(action, \" subscriptions (c:\").concat(correlationId, \"); retrying\"), _context.t1);\n\n              _this.persist();\n            }\n\n          case 60:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, null, [[9, 13, 17, 25], [18,, 20, 24], [27, 38], [43, 47, 51, 59], [52,, 54, 58]]);\n    }))();\n  }\n\n  verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests) {\n    const lastReceived = this.latestPokeResponseArrivalTimestampByCorrelationId.get(correlationId);\n    const silencePeriod = lastReceived ? new Date().getTime() - lastReceived : estimatedDeliveryInMs;\n\n    if (silencePeriod >= estimatedDeliveryInMs) {\n      // If we haven't received _any_ responses from that poke request for the duration of estimated_delivery_in_ms, poke again\n      requests.filter(r => r.pendingCorrelationId === correlationId).forEach(r => {\n        r.updatePending(null, null);\n        r.retryCount++;\n        this.persisted.delete(r.sid);\n      });\n      this.persist();\n      this.latestPokeResponseArrivalTimestampByCorrelationId.delete(correlationId);\n    } else {\n      // Otherwise, the poke responses are probably in transit and we should wait for them\n      const timeoutExtension = estimatedDeliveryInMs - silencePeriod;\n      setTimeout(() => this.verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests), timeoutExtension);\n    }\n  }\n\n  processLocalActions(action, requests) {\n    if (action === 'cancel') {\n      return requests.filter(request => !request.rejectedWithError);\n    }\n\n    return requests;\n  }\n\n  recordActionAttemptOn(attemptedSubscription, action, correlationId) {\n    attemptedSubscription.setSubscriptionState('request_in_flight');\n\n    if (action === 'establish') {\n      this.persisted.set(attemptedSubscription.sid, attemptedSubscription);\n      attemptedSubscription.updatePending(action, correlationId);\n    } else {\n      // cancel\n      let persistedSubscription = this.persisted.get(attemptedSubscription.sid);\n\n      if (persistedSubscription) {\n        persistedSubscription.updatePending(action, correlationId);\n      }\n    }\n  }\n\n  recordActionFailureOn(attemptedSubscription, action) {\n    attemptedSubscription.setSubscriptionState('none');\n    attemptedSubscription.updatePending(null, null);\n\n    if (action === 'establish') {\n      this.persisted.delete(attemptedSubscription.sid);\n    }\n  }\n\n  request(action, correlationId, reason, objects) {\n    let requests = objects.map(object => ({\n      object_sid: object.sid,\n      object_type: object.type,\n      last_event_id: action === 'establish' ? object.lastEventId : undefined,\n      index_name: action === 'establish' ? object.indexName : undefined,\n      query_string: action === 'establish' ? object.queryString : undefined\n    }));\n    let retriedRequests = objects.filter(a => a.retryCount > 0).length;\n    logger_1.default.debug(\"Attempting '\".concat(action, \"' request (c:\").concat(correlationId, \"):\"), requests);\n    const requestBody = {\n      event_protocol_version: 3,\n      action,\n      correlation_id: correlationId,\n      retried_requests: retriedRequests,\n      ttl_in_s: -1,\n      requests\n    };\n\n    if (reason === 'ttl') {\n      requestBody.reason = reason;\n    }\n\n    return this.services.network.post(this.services.config.subscriptionsUri, requestBody);\n  }\n  /**\n   * Establishes intent to be subscribed to this entity. That subscription will be effected\n   * asynchronously.\n   * If subscription to the given sid already exists, it will be overwritten.\n   *\n   * @param {String} sid should be a well-formed SID, uniquely identifying a single instance of a Sync entity.\n   * @param {Object} entity should represent the (singular) local representation of this entity.\n   *      Incoming events and modifications to the entity will be directed at the _update() function\n   *      of this provided reference.\n   *\n   * @return undefined\n   */\n\n\n  add(sid, entity) {\n    logger_1.default.debug(\"Establishing intent to subscribe to \".concat(sid));\n    const existingSubscription = this.subscriptions.get(sid);\n\n    if (existingSubscription && entity && existingSubscription.lastEventId === entity.lastEventId) {\n      // If last event id is the same as before - we're fine\n      return;\n    }\n\n    this.persisted.delete(sid);\n    this.subscriptions.set(sid, new SubscribedEntity(entity));\n    this.persist();\n  }\n  /**\n   * Establishes the caller's intent to no longer be subscribed to this entity. Following this\n   * call, no further events shall be routed to the local representation of the entity, even\n   * though a server-side subscription may take more time to actually terminate.\n   *\n   * @param {string} sid should be any well-formed SID, uniquely identifying a Sync entity.\n   *      This call only has meaningful effect if that entity is subscribed at the\n   *      time of call. Otherwise does nothing.\n   *\n   * @return undefined\n   */\n\n\n  remove(sid) {\n    logger_1.default.debug(\"Establishing intent to unsubscribe from \".concat(sid));\n    const removed = this.subscriptions.delete(sid);\n\n    if (removed) {\n      this.persist();\n    }\n  }\n  /**\n   * The point of ingestion for remote incoming messages (e.g. new data was written to a map\n   * to which we are subscribed).\n   *\n   * @param {object} message is the full, unaltered body of the incoming notification.\n   *\n   * @return undefined\n   */\n\n\n  acceptMessage(message, isStrictlyOrdered) {\n    logger_1.default.trace('Subscriptions received', message);\n\n    if (message.correlation_id) {\n      this.latestPokeResponseArrivalTimestampByCorrelationId.set(message.correlation_id, new Date().getTime());\n    }\n\n    let event_type;\n\n    switch (message.event_type) {\n      case 'subscription_established':\n        this.applySubscriptionEstablishedMessage(message.event, message.correlation_id);\n        break;\n\n      case 'subscription_canceled':\n        this.applySubscriptionCancelledMessage(message.event, message.correlation_id);\n        break;\n\n      case 'subscription_failed':\n        this.applySubscriptionFailedMessage(message.event, message.correlation_id);\n        break;\n\n      case (event_type = message.event_type.match(/^(?:map|list|document|stream|live_query)_/) || {}).input:\n        {\n          let typedSid;\n\n          switch (event_type[0]) {\n            case 'map_':\n              typedSid = message.event.map_sid;\n              break;\n\n            case 'list_':\n              typedSid = message.event.list_sid;\n              break;\n\n            case 'document_':\n              typedSid = message.event.document_sid;\n              break;\n\n            case 'stream_':\n              typedSid = message.event.stream_sid;\n              break;\n\n            case 'live_query_':\n              typedSid = message.event.query_id; // hack to mark replay events for LiveQuery as strictly ordered, due to lack of special type of notification for them\n              // (normally only replay events would have `twilio.sync.event` type, but LiveQuery non-replay events were also assigned\n              // to this type in legacy clients, which we have to support now; hence a hack)\n\n              isStrictlyOrdered = false; // explicitly override it due to code in router.ts does not know about LiveQueries\n\n              if (message.strictly_ordered === true) {\n                isStrictlyOrdered = true;\n              }\n\n              break;\n\n            default:\n              typedSid = undefined;\n          }\n\n          this.applyEventToSubscribedEntity(typedSid, message, isStrictlyOrdered);\n        }\n        break;\n\n      default:\n        logger_1.default.debug(\"Dropping unknown message type \".concat(message.event_type));\n        break;\n    }\n  }\n\n  applySubscriptionEstablishedMessage(message, correlationId) {\n    const sid = message.object_sid;\n    let subscriptionIntent = this.persisted.get(message.object_sid);\n\n    if (subscriptionIntent && subscriptionIntent.pendingCorrelationId === correlationId) {\n      if (message.replay_status === 'interrupted') {\n        logger_1.default.debug(\"Event Replay for subscription to \".concat(sid, \" (c:\").concat(correlationId, \") interrupted; continuing eagerly.\"));\n        subscriptionIntent.updatePending(null, null);\n        this.persisted.delete(subscriptionIntent.sid);\n        this.backoff.reset();\n      } else if (message.replay_status === 'completed') {\n        logger_1.default.debug(\"Event Replay for subscription to \".concat(sid, \" (c:\").concat(correlationId, \") completed. Subscription is ready.\"));\n        subscriptionIntent.complete(message.last_event_id);\n        this.persisted.set(message.object_sid, subscriptionIntent);\n        subscriptionIntent.setSubscriptionState('established');\n        this.backoff.reset();\n      }\n    } else {\n      logger_1.default.debug(\"Late message for \".concat(message.object_sid, \" (c:\").concat(correlationId, \") dropped.\"));\n    }\n\n    this.persist();\n  }\n\n  applySubscriptionCancelledMessage(message, correlationId) {\n    let persistedSubscription = this.persisted.get(message.object_sid);\n\n    if (persistedSubscription && persistedSubscription.pendingCorrelationId === correlationId) {\n      persistedSubscription.updatePending(null, null);\n      persistedSubscription.setSubscriptionState('none');\n      this.persisted.delete(message.object_sid);\n    } else {\n      logger_1.default.debug(\"Late message for \".concat(message.object_sid, \" (c:\").concat(correlationId, \") dropped.\"));\n    }\n\n    this.persist();\n  }\n\n  applySubscriptionFailedMessage(message, correlationId) {\n    const sid = message.object_sid;\n    let subscriptionIntent = this.subscriptions.get(sid);\n    let subscription = this.persisted.get(sid);\n\n    if (subscriptionIntent && subscription) {\n      if (subscription.pendingCorrelationId === correlationId) {\n        logger_1.default.error(\"Failed to subscribe on \".concat(subscription.sid), message.error);\n        subscription.markAsFailed(message);\n        subscription.setSubscriptionState('none');\n      }\n    } else if (!subscriptionIntent && subscription) {\n      this.persisted.delete(sid);\n      subscription.setSubscriptionState('none');\n    }\n\n    this.persist();\n  }\n\n  applyEventToSubscribedEntity(sid, message, isStrictlyOrdered) {\n    if (!sid) {\n      return;\n    } // Looking for subscription descriptor to check if poke has been completed\n\n\n    isStrictlyOrdered = isStrictlyOrdered || (() => {\n      let subscription = this.persisted.get(sid);\n      return subscription && subscription.isEstablished;\n    })(); // Still searching for subscriptionIntents. User could remove subscription already\n\n\n    let subscriptionIntent = this.subscriptions.get(sid);\n\n    if (subscriptionIntent) {\n      message.event.type = message.event_type;\n      subscriptionIntent.update(message.event, isStrictlyOrdered);\n    } else {\n      logger_1.default.debug(\"Message dropped for SID '\".concat(sid, \"', for which there is no subscription.\"));\n    }\n  }\n\n  onConnectionStateChanged(isConnected) {\n    this.isConnected = isConnected;\n\n    if (isConnected) {\n      this.poke('reconnect');\n    }\n  }\n\n  onSubscriptionTtlElapsed() {\n    if (this.isConnected) {\n      this.poke('ttl');\n    }\n  }\n  /**\n   * Prompts a playback of any missed changes made to any subscribed object. This method\n   * should be invoked whenever the connectivity layer has experienced cross-cutting\n   * delivery failures that would affect the entire local sync set. Any tangible result\n   * of this operation will result in calls to the _update() function of subscribed\n   * Sync entities.\n   */\n\n\n  poke(reason) {\n    logger_1.default.debug(\"Triggering event replay for all subscriptions, reason=\".concat(reason));\n    this.pendingPokeReason = reason;\n\n    if (this.subscriptionTtlTimer) {\n      clearTimeout(this.subscriptionTtlTimer);\n      this.subscriptionTtlTimer = null;\n    }\n\n    let failedSubscriptions = [];\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = this.persisted.values()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        let it = _step4.value;\n        it.reset();\n\n        if (it.rejectedWithError) {\n          failedSubscriptions.push(it);\n        }\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n          _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n\n    this.persisted.clear();\n\n    for (var _i = 0, _failedSubscriptions = failedSubscriptions; _i < _failedSubscriptions.length; _i++) {\n      let it = _failedSubscriptions[_i];\n      this.persisted.set(it.sid, it);\n    }\n\n    this.persist();\n  }\n  /**\n   * Stops all communication, clears any subscription intent, and returns.\n   */\n\n\n  shutdown() {\n    this.backoff.reset();\n    this.subscriptions.clear();\n  }\n\n}\n\nexports.Subscriptions = Subscriptions;","map":{"version":3,"sources":["C:/Users/khouloud/Documents/PI/MERN_Stack_PI/node_modules/twilio-sync/lib/subscriptions.js"],"names":["Object","defineProperty","exports","value","operation_retrier_1","require","syncerror_1","logger_1","twilsock_1","SubscribedEntity","constructor","entity","localObject","pendingCorrelationId","pendingAction","established","retryCount","sid","type","lastEventId","indexName","queryString","isEstablished","update","event","isStrictlyOrdered","_update","updatePending","action","correlationId","reset","setSubscriptionState","markAsFailed","message","rejectedWithError","error","reportFailure","SyncError","status","code","complete","eventId","_advanceLastEventId","newState","_setSubscriptionState","Subscriptions","services","isConnected","maxBatchSize","subscriptionTtlTimer","pendingPokeReason","subscriptions","Map","persisted","latestPokeResponseArrivalTimestampByCorrelationId","defaultBackoffConfig","randomisationFactor","initialDelay","maxDelay","backoff","Backoff","exponential","assign","config","backoffConfig","on","getSubscriptionUpdateBatch","subscriptionRequests","applyNewSubscriptionUpdateBatch","default","debug","subtract","these","those","limit","result","thisKey","thisValue","otherValue","get","push","length","listToAdd","listToRemove","persist","requests","processLocalActions","Date","getTime","subscribed","recordActionAttemptOn","reason","request","response","newMaxBatchSize","body","max_batch_size","isNaN","parseInt","isFinite","subscriptionTtlInS","ttl_in_s","isNumeric","parseFloat","isValidTtl","setTimeout","onSubscriptionTtlElapsed","estimatedDeliveryInMs","estimated_delivery_in_ms","isValidTimeout","verifyPokeDelivery","filter","r","forEach","attemptedSubscription","recordActionFailureOn","TransportUnavailableError","lastReceived","silencePeriod","delete","timeoutExtension","set","persistedSubscription","objects","map","object","object_sid","object_type","last_event_id","undefined","index_name","query_string","retriedRequests","a","requestBody","event_protocol_version","correlation_id","retried_requests","network","post","subscriptionsUri","add","existingSubscription","remove","removed","acceptMessage","trace","event_type","applySubscriptionEstablishedMessage","applySubscriptionCancelledMessage","applySubscriptionFailedMessage","match","input","typedSid","map_sid","list_sid","document_sid","stream_sid","query_id","strictly_ordered","applyEventToSubscribedEntity","subscriptionIntent","replay_status","subscription","onConnectionStateChanged","poke","clearTimeout","failedSubscriptions","values","it","clear","shutdown"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst operation_retrier_1 = require(\"operation-retrier\");\nconst syncerror_1 = require(\"./utils/syncerror\");\nconst logger_1 = require(\"./utils/logger\");\nconst twilsock_1 = require(\"twilsock\");\n/**\n * A data container used by the Subscriptions class to track subscribed entities' local\n * representations and their state.\n */\nclass SubscribedEntity {\n    constructor(entity) {\n        this.localObject = entity;\n        this.pendingCorrelationId = null;\n        this.pendingAction = null;\n        this.established = false;\n        this.retryCount = 0;\n    }\n    get sid() {\n        return this.localObject.sid;\n    }\n    get type() {\n        return this.localObject.type;\n    }\n    get lastEventId() {\n        return this.localObject.lastEventId;\n    }\n    // below properties are specific to Insights only\n    get indexName() {\n        return this.localObject.indexName;\n    }\n    get queryString() {\n        return this.localObject.queryString;\n    }\n    get isEstablished() {\n        return this.established;\n    }\n    update(event, isStrictlyOrdered) {\n        this.localObject._update(event, isStrictlyOrdered);\n    }\n    updatePending(action, correlationId) {\n        this.pendingAction = action;\n        this.pendingCorrelationId = correlationId;\n    }\n    reset() {\n        this.updatePending(null, null);\n        this.retryCount = 0;\n        this.established = false;\n        this.setSubscriptionState('none');\n    }\n    markAsFailed(message) {\n        this.rejectedWithError = message.error;\n        this.updatePending(null, null);\n        this.localObject.reportFailure(new syncerror_1.SyncError(`Failed to subscribe on service events: ${message.error.message}`, message.error.status, message.error.code));\n    }\n    complete(eventId) {\n        this.updatePending(null, null);\n        this.established = true;\n        this.localObject._advanceLastEventId(eventId);\n    }\n    setSubscriptionState(newState) {\n        this.localObject._setSubscriptionState(newState);\n    }\n}\n/**\n * @class Subscriptions\n * @classdesc A manager which, in batches of varying size, continuously persists the\n *      subscription intent of the caller to the Sync backend until it achieves a\n *      converged state.\n */\nclass Subscriptions {\n    /**\n     * @constructor\n     * Prepares a new Subscriptions manager object with zero subscribed or persisted subscriptions.\n     *\n     * @param {object} config may include a key 'backoffConfig', wherein any of the parameters\n     *      of Backoff.exponential (from npm 'backoff') are valid and will override the defaults.\n     *\n     * @param {Network} must be a viable running Sync Network object, useful for routing requests.\n     */\n    constructor(services) {\n        this.isConnected = false;\n        this.maxBatchSize = 100;\n        // If the server includes a `ttl_in_s` attribute in the poke response, subscriptionTtlTimer is started for that duration\n        // such that when it fires, it repokes the entire sync set (i.e., emulates a reconnect). Every reconnect resets the timer.\n        // After the timer has fired, the first poke request includes a `reason: ttl` attribute in the body.\n        this.subscriptionTtlTimer = null;\n        this.pendingPokeReason = null;\n        this.services = services;\n        this.subscriptions = new Map();\n        this.persisted = new Map();\n        this.latestPokeResponseArrivalTimestampByCorrelationId = new Map();\n        const defaultBackoffConfig = {\n            randomisationFactor: 0.2,\n            initialDelay: 100,\n            maxDelay: 2 * 60 * 1000\n        };\n        this.backoff = operation_retrier_1.Backoff.exponential(Object.assign(defaultBackoffConfig, this.services.config.backoffConfig));\n        // This block is triggered by #_persist. Every request is executed in a series of (ideally 1)\n        // backoff 'ready' event, at which point a new subscription set is calculated.\n        this.backoff.on('ready', () => {\n            let { action: action, subscriptions: subscriptionRequests } = this.getSubscriptionUpdateBatch();\n            if (action) {\n                this.applyNewSubscriptionUpdateBatch(action, subscriptionRequests);\n            }\n            else {\n                this.backoff.reset();\n                logger_1.default.debug('All subscriptions resolved.');\n            }\n        });\n    }\n    getSubscriptionUpdateBatch() {\n        function subtract(these, those, action, limit) {\n            let result = [];\n            for (let [thisKey, thisValue] of these) {\n                const otherValue = those.get(thisKey);\n                if (!otherValue && action !== thisValue.pendingAction && !thisValue.rejectedWithError) {\n                    result.push(thisValue);\n                    if (limit && result.length >= limit) {\n                        break;\n                    }\n                }\n            }\n            return result;\n        }\n        let listToAdd = subtract(this.subscriptions, this.persisted, 'establish', this.maxBatchSize);\n        if (listToAdd.length > 0) {\n            return { action: 'establish', subscriptions: listToAdd };\n        }\n        let listToRemove = subtract(this.persisted, this.subscriptions, 'cancel', this.maxBatchSize);\n        if (listToRemove.length > 0) {\n            return { action: 'cancel', subscriptions: listToRemove };\n        }\n        return { action: null, subscriptions: null };\n    }\n    persist() {\n        this.backoff.backoff();\n    }\n    async applyNewSubscriptionUpdateBatch(action, requests) {\n        if (!this.isConnected) {\n            logger_1.default.debug(`Twilsock connection (required for subscription) not ready; waiting`);\n            this.backoff.reset();\n            return;\n        }\n        // Keeping in mind that events may begin flowing _before_ we receive the response\n        requests = this.processLocalActions(action, requests);\n        const correlationId = new Date().getTime();\n        for (const subscribed of requests) {\n            this.recordActionAttemptOn(subscribed, action, correlationId);\n        }\n        let reason = this.pendingPokeReason;\n        this.pendingPokeReason = null;\n        // Send this batch to the service\n        try {\n            let response = await this.request(action, correlationId, reason, requests);\n            let newMaxBatchSize = response.body.max_batch_size;\n            if (!isNaN(parseInt(newMaxBatchSize)) && isFinite(newMaxBatchSize) && newMaxBatchSize > 0) {\n                this.maxBatchSize = newMaxBatchSize;\n            }\n            if (!this.subscriptionTtlTimer) {\n                let subscriptionTtlInS = response.body.ttl_in_s;\n                let isNumeric = !isNaN(parseFloat(subscriptionTtlInS)) && isFinite(subscriptionTtlInS);\n                let isValidTtl = isNumeric && subscriptionTtlInS > 0;\n                if (isValidTtl) {\n                    this.subscriptionTtlTimer = setTimeout(() => this.onSubscriptionTtlElapsed(), subscriptionTtlInS * 1000);\n                }\n            }\n            if (action === 'establish') {\n                const estimatedDeliveryInMs = response.body.estimated_delivery_in_ms;\n                let isNumeric = !isNaN(parseFloat(estimatedDeliveryInMs)) && isFinite(estimatedDeliveryInMs);\n                let isValidTimeout = isNumeric && estimatedDeliveryInMs > 0;\n                if (isValidTimeout) {\n                    setTimeout(() => this.verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests), estimatedDeliveryInMs);\n                }\n                else {\n                    logger_1.default.error(`Invalid timeout: ${estimatedDeliveryInMs}`);\n                }\n                requests.filter(r => r.pendingCorrelationId === correlationId)\n                    .forEach(r => r.setSubscriptionState('response_in_flight'));\n            }\n            this.backoff.reset();\n        }\n        catch (e) {\n            for (const attemptedSubscription of requests) {\n                this.recordActionFailureOn(attemptedSubscription, action);\n            }\n            if (e instanceof twilsock_1.TransportUnavailableError) {\n                logger_1.default.debug(`Twilsock connection (required for subscription) not ready (c:${correlationId}); waiting`);\n                this.backoff.reset();\n            }\n            else {\n                logger_1.default.debug(`Failed an attempt to ${action} subscriptions (c:${correlationId}); retrying`, e);\n                this.persist();\n            }\n        }\n    }\n    verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests) {\n        const lastReceived = this.latestPokeResponseArrivalTimestampByCorrelationId.get(correlationId);\n        const silencePeriod = lastReceived ? (new Date().getTime() - lastReceived)\n            : estimatedDeliveryInMs;\n        if (silencePeriod >= estimatedDeliveryInMs) {\n            // If we haven't received _any_ responses from that poke request for the duration of estimated_delivery_in_ms, poke again\n            requests\n                .filter(r => r.pendingCorrelationId === correlationId)\n                .forEach(r => {\n                r.updatePending(null, null);\n                r.retryCount++;\n                this.persisted.delete(r.sid);\n            });\n            this.persist();\n            this.latestPokeResponseArrivalTimestampByCorrelationId.delete(correlationId);\n        }\n        else {\n            // Otherwise, the poke responses are probably in transit and we should wait for them\n            const timeoutExtension = estimatedDeliveryInMs - silencePeriod;\n            setTimeout(() => this.verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests), timeoutExtension);\n        }\n    }\n    processLocalActions(action, requests) {\n        if (action === 'cancel') {\n            return requests.filter(request => !request.rejectedWithError);\n        }\n        return requests;\n    }\n    recordActionAttemptOn(attemptedSubscription, action, correlationId) {\n        attemptedSubscription.setSubscriptionState('request_in_flight');\n        if (action === 'establish') {\n            this.persisted.set(attemptedSubscription.sid, attemptedSubscription);\n            attemptedSubscription.updatePending(action, correlationId);\n        }\n        else { // cancel\n            let persistedSubscription = this.persisted.get(attemptedSubscription.sid);\n            if (persistedSubscription) {\n                persistedSubscription.updatePending(action, correlationId);\n            }\n        }\n    }\n    recordActionFailureOn(attemptedSubscription, action) {\n        attemptedSubscription.setSubscriptionState('none');\n        attemptedSubscription.updatePending(null, null);\n        if (action === 'establish') {\n            this.persisted.delete(attemptedSubscription.sid);\n        }\n    }\n    request(action, correlationId, reason, objects) {\n        let requests = objects.map(object => ({\n            object_sid: object.sid,\n            object_type: object.type,\n            last_event_id: action === 'establish' ? object.lastEventId : undefined,\n            index_name: action === 'establish' ? object.indexName : undefined,\n            query_string: action === 'establish' ? object.queryString : undefined,\n        }));\n        let retriedRequests = objects.filter(a => a.retryCount > 0).length;\n        logger_1.default.debug(`Attempting '${action}' request (c:${correlationId}):`, requests);\n        const requestBody = {\n            event_protocol_version: 3,\n            action,\n            correlation_id: correlationId,\n            retried_requests: retriedRequests,\n            ttl_in_s: -1,\n            requests\n        };\n        if (reason === 'ttl') {\n            requestBody.reason = reason;\n        }\n        return this.services.network.post(this.services.config.subscriptionsUri, requestBody);\n    }\n    /**\n     * Establishes intent to be subscribed to this entity. That subscription will be effected\n     * asynchronously.\n     * If subscription to the given sid already exists, it will be overwritten.\n     *\n     * @param {String} sid should be a well-formed SID, uniquely identifying a single instance of a Sync entity.\n     * @param {Object} entity should represent the (singular) local representation of this entity.\n     *      Incoming events and modifications to the entity will be directed at the _update() function\n     *      of this provided reference.\n     *\n     * @return undefined\n     */\n    add(sid, entity) {\n        logger_1.default.debug(`Establishing intent to subscribe to ${sid}`);\n        const existingSubscription = this.subscriptions.get(sid);\n        if (existingSubscription && entity && existingSubscription.lastEventId === entity.lastEventId) {\n            // If last event id is the same as before - we're fine\n            return;\n        }\n        this.persisted.delete(sid);\n        this.subscriptions.set(sid, new SubscribedEntity(entity));\n        this.persist();\n    }\n    /**\n     * Establishes the caller's intent to no longer be subscribed to this entity. Following this\n     * call, no further events shall be routed to the local representation of the entity, even\n     * though a server-side subscription may take more time to actually terminate.\n     *\n     * @param {string} sid should be any well-formed SID, uniquely identifying a Sync entity.\n     *      This call only has meaningful effect if that entity is subscribed at the\n     *      time of call. Otherwise does nothing.\n     *\n     * @return undefined\n     */\n    remove(sid) {\n        logger_1.default.debug(`Establishing intent to unsubscribe from ${sid}`);\n        const removed = this.subscriptions.delete(sid);\n        if (removed) {\n            this.persist();\n        }\n    }\n    /**\n     * The point of ingestion for remote incoming messages (e.g. new data was written to a map\n     * to which we are subscribed).\n     *\n     * @param {object} message is the full, unaltered body of the incoming notification.\n     *\n     * @return undefined\n     */\n    acceptMessage(message, isStrictlyOrdered) {\n        logger_1.default.trace('Subscriptions received', message);\n        if (message.correlation_id) {\n            this.latestPokeResponseArrivalTimestampByCorrelationId.set(message.correlation_id, new Date().getTime());\n        }\n        let event_type;\n        switch (message.event_type) {\n            case 'subscription_established':\n                this.applySubscriptionEstablishedMessage(message.event, message.correlation_id);\n                break;\n            case 'subscription_canceled':\n                this.applySubscriptionCancelledMessage(message.event, message.correlation_id);\n                break;\n            case 'subscription_failed':\n                this.applySubscriptionFailedMessage(message.event, message.correlation_id);\n                break;\n            case (event_type = message.event_type.match(/^(?:map|list|document|stream|live_query)_/) || {}).input:\n                {\n                    let typedSid;\n                    switch (event_type[0]) {\n                        case 'map_':\n                            typedSid = message.event.map_sid;\n                            break;\n                        case 'list_':\n                            typedSid = message.event.list_sid;\n                            break;\n                        case 'document_':\n                            typedSid = message.event.document_sid;\n                            break;\n                        case 'stream_':\n                            typedSid = message.event.stream_sid;\n                            break;\n                        case 'live_query_':\n                            typedSid = message.event.query_id;\n                            // hack to mark replay events for LiveQuery as strictly ordered, due to lack of special type of notification for them\n                            // (normally only replay events would have `twilio.sync.event` type, but LiveQuery non-replay events were also assigned\n                            // to this type in legacy clients, which we have to support now; hence a hack)\n                            isStrictlyOrdered = false; // explicitly override it due to code in router.ts does not know about LiveQueries\n                            if (message.strictly_ordered === true) {\n                                isStrictlyOrdered = true;\n                            }\n                            break;\n                        default:\n                            typedSid = undefined;\n                    }\n                    this.applyEventToSubscribedEntity(typedSid, message, isStrictlyOrdered);\n                }\n                break;\n            default:\n                logger_1.default.debug(`Dropping unknown message type ${message.event_type}`);\n                break;\n        }\n    }\n    applySubscriptionEstablishedMessage(message, correlationId) {\n        const sid = message.object_sid;\n        let subscriptionIntent = this.persisted.get(message.object_sid);\n        if (subscriptionIntent && subscriptionIntent.pendingCorrelationId === correlationId) {\n            if (message.replay_status === 'interrupted') {\n                logger_1.default.debug(`Event Replay for subscription to ${sid} (c:${correlationId}) interrupted; continuing eagerly.`);\n                subscriptionIntent.updatePending(null, null);\n                this.persisted.delete(subscriptionIntent.sid);\n                this.backoff.reset();\n            }\n            else if (message.replay_status === 'completed') {\n                logger_1.default.debug(`Event Replay for subscription to ${sid} (c:${correlationId}) completed. Subscription is ready.`);\n                subscriptionIntent.complete(message.last_event_id);\n                this.persisted.set(message.object_sid, subscriptionIntent);\n                subscriptionIntent.setSubscriptionState('established');\n                this.backoff.reset();\n            }\n        }\n        else {\n            logger_1.default.debug(`Late message for ${message.object_sid} (c:${correlationId}) dropped.`);\n        }\n        this.persist();\n    }\n    applySubscriptionCancelledMessage(message, correlationId) {\n        let persistedSubscription = this.persisted.get(message.object_sid);\n        if (persistedSubscription && persistedSubscription.pendingCorrelationId === correlationId) {\n            persistedSubscription.updatePending(null, null);\n            persistedSubscription.setSubscriptionState('none');\n            this.persisted.delete(message.object_sid);\n        }\n        else {\n            logger_1.default.debug(`Late message for ${message.object_sid} (c:${correlationId}) dropped.`);\n        }\n        this.persist();\n    }\n    applySubscriptionFailedMessage(message, correlationId) {\n        const sid = message.object_sid;\n        let subscriptionIntent = this.subscriptions.get(sid);\n        let subscription = this.persisted.get(sid);\n        if (subscriptionIntent && subscription) {\n            if (subscription.pendingCorrelationId === correlationId) {\n                logger_1.default.error(`Failed to subscribe on ${subscription.sid}`, message.error);\n                subscription.markAsFailed(message);\n                subscription.setSubscriptionState('none');\n            }\n        }\n        else if (!subscriptionIntent && subscription) {\n            this.persisted.delete(sid);\n            subscription.setSubscriptionState('none');\n        }\n        this.persist();\n    }\n    applyEventToSubscribedEntity(sid, message, isStrictlyOrdered) {\n        if (!sid) {\n            return;\n        }\n        // Looking for subscription descriptor to check if poke has been completed\n        isStrictlyOrdered = isStrictlyOrdered || (() => {\n            let subscription = this.persisted.get(sid);\n            return subscription && subscription.isEstablished;\n        })();\n        // Still searching for subscriptionIntents. User could remove subscription already\n        let subscriptionIntent = this.subscriptions.get(sid);\n        if (subscriptionIntent) {\n            message.event.type = message.event_type;\n            subscriptionIntent.update(message.event, isStrictlyOrdered);\n        }\n        else {\n            logger_1.default.debug(`Message dropped for SID '${sid}', for which there is no subscription.`);\n        }\n    }\n    onConnectionStateChanged(isConnected) {\n        this.isConnected = isConnected;\n        if (isConnected) {\n            this.poke('reconnect');\n        }\n    }\n    onSubscriptionTtlElapsed() {\n        if (this.isConnected) {\n            this.poke('ttl');\n        }\n    }\n    /**\n     * Prompts a playback of any missed changes made to any subscribed object. This method\n     * should be invoked whenever the connectivity layer has experienced cross-cutting\n     * delivery failures that would affect the entire local sync set. Any tangible result\n     * of this operation will result in calls to the _update() function of subscribed\n     * Sync entities.\n     */\n    poke(reason) {\n        logger_1.default.debug(`Triggering event replay for all subscriptions, reason=${reason}`);\n        this.pendingPokeReason = reason;\n        if (this.subscriptionTtlTimer) {\n            clearTimeout(this.subscriptionTtlTimer);\n            this.subscriptionTtlTimer = null;\n        }\n        let failedSubscriptions = [];\n        for (let it of this.persisted.values()) {\n            it.reset();\n            if (it.rejectedWithError) {\n                failedSubscriptions.push(it);\n            }\n        }\n        this.persisted.clear();\n        for (let it of failedSubscriptions) {\n            this.persisted.set(it.sid, it);\n        }\n        this.persist();\n    }\n    /**\n     * Stops all communication, clears any subscription intent, and returns.\n     */\n    shutdown() {\n        this.backoff.reset();\n        this.subscriptions.clear();\n    }\n}\nexports.Subscriptions = Subscriptions;\n"]},"metadata":{},"sourceType":"script"}