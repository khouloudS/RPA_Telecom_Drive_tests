{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\khouloud\\\\Documents\\\\PI\\\\MERN_Stack_PI\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\khouloud\\\\Documents\\\\PI\\\\MERN_Stack_PI\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst logger_1 = require(\"../logger\");\n\nconst events_1 = require(\"events\");\n\nconst uuid_1 = require(\"uuid\");\n\nconst twilsockerror_1 = require(\"../error/twilsockerror\");\n/**\n * Registrations module handles all operations with registration contexts through twilsock\n * Main role: it automatically refreshes all registrations after reconnect.\n */\n\n\nclass Registrations extends events_1.EventEmitter {\n  constructor(transport) {\n    super();\n    this.transport = transport;\n    this.registrations = new Map();\n    this.registrationsInProgress = new Map();\n  }\n\n  putNotificationContext(contextId, context) {\n    var _this = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var header, reply;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            header = {\n              method: 'put_notification_ctx',\n              notification_ctx_id: contextId\n            };\n            _context.next = 3;\n            return _this.transport.sendWithReply(header, context);\n\n          case 3:\n            reply = _context.sent;\n\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }))();\n  }\n\n  deleteNotificationContext(contextId) {\n    var _this2 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      var message, reply;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            message = {\n              method: 'delete_notification_ctx',\n              notification_ctx_id: contextId\n            };\n            _context2.next = 3;\n            return _this2.transport.sendWithReply(message);\n\n          case 3:\n            reply = _context2.sent;\n\n          case 4:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }))();\n  }\n\n  updateRegistration(contextId, context) {\n    var _this3 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n      var registrationAttempts, attemptId;\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            logger_1.log.debug('update registration for context', contextId);\n            registrationAttempts = _this3.registrationsInProgress.get(contextId);\n\n            if (!registrationAttempts) {\n              registrationAttempts = new Set();\n\n              _this3.registrationsInProgress.set(contextId, registrationAttempts);\n            }\n\n            attemptId = uuid_1.v4();\n            registrationAttempts.add(attemptId);\n            _context3.prev = 5;\n            _context3.next = 8;\n            return _this3.putNotificationContext(contextId, context);\n\n          case 8:\n            logger_1.log.debug('registration attempt succeeded for context', context);\n            registrationAttempts.delete(attemptId);\n\n            if (registrationAttempts.size === 0) {\n              _this3.registrationsInProgress.delete(contextId);\n\n              _this3.emit('registered', contextId);\n            }\n\n            _context3.next = 19;\n            break;\n\n          case 13:\n            _context3.prev = 13;\n            _context3.t0 = _context3[\"catch\"](5);\n            logger_1.log.warn('registration attempt failed for context', context);\n            logger_1.log.debug(_context3.t0);\n            registrationAttempts.delete(attemptId);\n\n            if (registrationAttempts.size === 0) {\n              _this3.registrationsInProgress.delete(contextId);\n\n              _this3.emit('registrationFailed', contextId, _context3.t0);\n            }\n\n          case 19:\n          case \"end\":\n            return _context3.stop();\n        }\n      }, _callee3, null, [[5, 13]]);\n    }))();\n  }\n\n  updateRegistrations() {\n    logger_1.log.trace(\"refreshing \".concat(this.registrations.size, \" registrations\"));\n    this.registrations.forEach((context, id) => {\n      this.updateRegistration(id, context);\n    });\n  }\n\n  setNotificationsContext(contextId, context) {\n    if (!contextId || !context) {\n      throw new twilsockerror_1.TwilsockError('Invalid arguments provided');\n    }\n\n    this.registrations.set(contextId, context);\n\n    if (this.transport.isConnected) {\n      this.updateRegistration(contextId, context);\n    }\n  }\n\n  removeNotificationsContext(contextId) {\n    var _this4 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            if (_this4.registrations.has(contextId)) {\n              _context4.next = 2;\n              break;\n            }\n\n            return _context4.abrupt(\"return\");\n\n          case 2:\n            _context4.next = 4;\n            return _this4.deleteNotificationContext(contextId);\n\n          case 4:\n            if (_this4.transport.isConnected) {\n              _this4.registrations.delete(contextId);\n            }\n\n          case 5:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee4);\n    }))();\n  }\n\n}\n\nexports.Registrations = Registrations;","map":{"version":3,"sources":["C:/Users/khouloud/Documents/PI/MERN_Stack_PI/node_modules/twilsock/lib/services/registrations.js"],"names":["Object","defineProperty","exports","value","logger_1","require","events_1","uuid_1","twilsockerror_1","Registrations","EventEmitter","constructor","transport","registrations","Map","registrationsInProgress","putNotificationContext","contextId","context","header","method","notification_ctx_id","sendWithReply","reply","deleteNotificationContext","message","updateRegistration","log","debug","registrationAttempts","get","Set","set","attemptId","v4","add","delete","size","emit","warn","updateRegistrations","trace","forEach","id","setNotificationsContext","TwilsockError","isConnected","removeNotificationsContext","has"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst logger_1 = require(\"../logger\");\nconst events_1 = require(\"events\");\nconst uuid_1 = require(\"uuid\");\nconst twilsockerror_1 = require(\"../error/twilsockerror\");\n/**\n * Registrations module handles all operations with registration contexts through twilsock\n * Main role: it automatically refreshes all registrations after reconnect.\n */\nclass Registrations extends events_1.EventEmitter {\n    constructor(transport) {\n        super();\n        this.transport = transport;\n        this.registrations = new Map();\n        this.registrationsInProgress = new Map();\n    }\n    async putNotificationContext(contextId, context) {\n        const header = { method: 'put_notification_ctx', notification_ctx_id: contextId };\n        let reply = await this.transport.sendWithReply(header, context);\n    }\n    async deleteNotificationContext(contextId) {\n        let message = { method: 'delete_notification_ctx',\n            notification_ctx_id: contextId };\n        let reply = await this.transport.sendWithReply(message);\n    }\n    async updateRegistration(contextId, context) {\n        logger_1.log.debug('update registration for context', contextId);\n        let registrationAttempts = this.registrationsInProgress.get(contextId);\n        if (!registrationAttempts) {\n            registrationAttempts = new Set();\n            this.registrationsInProgress.set(contextId, registrationAttempts);\n        }\n        const attemptId = uuid_1.v4();\n        registrationAttempts.add(attemptId);\n        try {\n            await this.putNotificationContext(contextId, context);\n            logger_1.log.debug('registration attempt succeeded for context', context);\n            registrationAttempts.delete(attemptId);\n            if (registrationAttempts.size === 0) {\n                this.registrationsInProgress.delete(contextId);\n                this.emit('registered', contextId);\n            }\n        }\n        catch (err) {\n            logger_1.log.warn('registration attempt failed for context', context);\n            logger_1.log.debug(err);\n            registrationAttempts.delete(attemptId);\n            if (registrationAttempts.size === 0) {\n                this.registrationsInProgress.delete(contextId);\n                this.emit('registrationFailed', contextId, err);\n            }\n        }\n    }\n    updateRegistrations() {\n        logger_1.log.trace(`refreshing ${this.registrations.size} registrations`);\n        this.registrations.forEach((context, id) => {\n            this.updateRegistration(id, context);\n        });\n    }\n    setNotificationsContext(contextId, context) {\n        if (!contextId || !context) {\n            throw new twilsockerror_1.TwilsockError('Invalid arguments provided');\n        }\n        this.registrations.set(contextId, context);\n        if (this.transport.isConnected) {\n            this.updateRegistration(contextId, context);\n        }\n    }\n    async removeNotificationsContext(contextId) {\n        if (!this.registrations.has(contextId)) {\n            return;\n        }\n        await this.deleteNotificationContext(contextId);\n        if (this.transport.isConnected) {\n            this.registrations.delete(contextId);\n        }\n    }\n}\nexports.Registrations = Registrations;\n"]},"metadata":{},"sourceType":"script"}