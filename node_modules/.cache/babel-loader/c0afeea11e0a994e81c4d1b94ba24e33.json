{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\khouloud\\\\Documents\\\\PI\\\\MERN_Stack_PI\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\khouloud\\\\Documents\\\\PI\\\\MERN_Stack_PI\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"events\");\n\nconst StateMachine = require(\"javascript-state-machine\");\n\nconst logger_1 = require(\"./logger\");\n\nconst Messages = require(\"./protocol/messages\");\n\nconst parser_1 = require(\"./parser\");\n\nconst twilsockreplyerror_1 = require(\"./error/twilsockreplyerror\");\n\nconst backoffretrier_1 = require(\"./backoffretrier\");\n\nconst DISCONNECTING_TIMEOUT = 3000; // Wraps asynchronous rescheduling\n// Just makes it simpler to find these hacks over the code\n\nfunction trampoline(f) {\n  setTimeout(f, 0);\n}\n/**\n * Makes sure that body is properly stringified\n */\n\n\nfunction preparePayload(payload) {\n  switch (typeof payload) {\n    case 'undefined':\n      return '';\n\n    case 'object':\n      return JSON.stringify(payload);\n\n    default:\n      return payload;\n  }\n}\n\nclass Request {}\n\nclass Response {}\n\nexports.Response = Response;\n/**\n * Twilsock channel level protocol implementation\n */\n\nclass TwilsockChannel extends events_1.EventEmitter {\n  constructor(websocket, transport, config) {\n    super();\n    this.terminalStates = ['disconnected', 'rejected'];\n    this.lastEmittedState = undefined;\n    this.tokenExpiredSasCode = 20104;\n    this.websocket = websocket;\n    this.websocket.on('connected', () => this.fsm.socketConnected());\n    this.websocket.on('disconnected', e => this.fsm.socketClosed());\n    this.websocket.on('message', message => this.onIncomingMessage(message));\n    this.websocket.on('socketError', e => this.emit('connectionError', {\n      terminal: false,\n      message: e.message,\n      httpStatusCode: null,\n      errorCode: null\n    }));\n    this.transport = transport;\n    this.config = config;\n    this.retrier = new backoffretrier_1.BackoffRetrier(config.retryPolicy);\n    this.retrier.on('attempt', () => this.retry());\n    this.retrier.on('failed', err => {\n      logger_1.log.warn(\"Retrying failed: \".concat(err.message));\n      this.disconnect();\n    });\n\n    if (typeof window !== 'undefined' && typeof window.addEventListener !== 'undefined') {\n      window.addEventListener('online', () => {\n        logger_1.log.debug('Browser reported connectivity state: online');\n        this.fsm.systemOnline();\n      });\n      window.addEventListener('offline', () => {\n        logger_1.log.debug('Browser reported connectivity state: offline');\n        this.websocket.close();\n        this.fsm.socketClosed();\n      });\n    }\n\n    this.fsm = new StateMachine({\n      init: 'disconnected',\n      transitions: [{\n        name: 'userConnect',\n        from: ['disconnected', 'rejected'],\n        to: 'connecting'\n      }, {\n        name: 'userConnect',\n        from: ['connecting', 'connected']\n      }, {\n        name: 'userDisconnect',\n        from: ['connecting', 'initialising', 'connected', 'updating', 'retrying', 'rejected', 'waitSocketClosed', 'waitOffloadSocketClosed'],\n        to: 'disconnecting'\n      }, {\n        name: 'userRetry',\n        from: ['retrying'],\n        to: 'connecting'\n      }, {\n        name: 'socketConnected',\n        from: ['connecting'],\n        to: 'initialising'\n      }, {\n        name: 'socketClosed',\n        from: ['connecting', 'initialising', 'connected', 'updating', 'error', 'waitOffloadSocketClosed'],\n        to: 'retrying'\n      }, {\n        name: 'socketClosed',\n        from: ['disconnecting'],\n        to: 'disconnected'\n      }, {\n        name: 'socketClosed',\n        from: ['waitSocketClosed'],\n        to: 'disconnected'\n      }, {\n        name: 'socketClosed',\n        from: ['rejected'],\n        to: 'rejected'\n      }, {\n        name: 'initSuccess',\n        from: ['initialising'],\n        to: 'connected'\n      }, {\n        name: 'initError',\n        from: ['initialising'],\n        to: 'error'\n      }, {\n        name: 'tokenRejected',\n        from: ['initialising', 'updating'],\n        to: 'rejected'\n      }, {\n        name: 'protocolError',\n        from: ['initialising', 'connected', 'updating'],\n        to: 'error'\n      }, {\n        name: 'receiveClose',\n        from: ['initialising', 'connected', 'updating'],\n        to: 'waitSocketClosed'\n      }, {\n        name: 'receiveOffload',\n        from: ['initialising', 'connected', 'updating'],\n        to: 'waitOffloadSocketClosed'\n      }, {\n        name: 'unsupportedProtocol',\n        from: ['initialising', 'connected', 'updating'],\n        to: 'unsupported'\n      }, {\n        name: 'receiveFatalClose',\n        from: ['initialising', 'connected', 'updating'],\n        to: 'unsupported'\n      }, {\n        name: 'userUpdateToken',\n        from: ['disconnected', 'rejected', 'connecting', 'retrying'],\n        to: 'connecting'\n      }, {\n        name: 'userUpdateToken',\n        from: ['connected'],\n        to: 'updating'\n      }, {\n        name: 'updateSuccess',\n        from: ['updating'],\n        to: 'connected'\n      }, {\n        name: 'updateError',\n        from: ['updating'],\n        to: 'error'\n      }, {\n        name: 'userSend',\n        from: ['connected'],\n        to: 'connected'\n      }, {\n        name: 'systemOnline',\n        from: ['retrying'],\n        to: 'connecting'\n      }],\n      methods: {\n        onConnecting: () => {\n          this.setupSocket();\n          this.emit('connecting');\n        },\n        onEnterInitialising: () => {\n          this.sendInit();\n        },\n        onLeaveInitialising: () => {\n          this.cancelInit();\n        },\n        onEnterUpdating: () => {\n          this.sendUpdate();\n        },\n        onLeaveUpdating: () => {\n          this.cancelUpdate();\n        },\n        onEnterRetrying: () => {\n          this.initRetry();\n          this.emit('connecting');\n        },\n        onEnterConnected: () => {\n          this.resetBackoff();\n          this.onConnected();\n        },\n        onUserUpdateToken: () => {\n          this.resetBackoff();\n        },\n        onTokenRejected: () => {\n          this.resetBackoff();\n          this.closeSocket(true);\n          this.finalizeSocket();\n        },\n        onUserDisconnect: () => {\n          this.closeSocket(true);\n        },\n        onEnterDisconnecting: () => {\n          this.startDisconnectTimer();\n        },\n        onLeaveDisconnecting: () => {\n          this.cancelDisconnectTimer();\n        },\n        onEnterWaitSocketClosed: () => {\n          this.startDisconnectTimer();\n        },\n        onLeaveWaitSocketClosed: () => {\n          this.cancelDisconnectTimer();\n        },\n        onEnterWaitOffloadSocketClosed: () => {\n          this.startDisconnectTimer();\n        },\n        onLeaveWaitOffloadSocketClosed: () => {\n          this.cancelDisconnectTimer();\n        },\n        onDisconnected: () => {\n          this.resetBackoff();\n          this.finalizeSocket();\n        },\n        onReceiveClose: (event, args) => {\n          this.onCloseReceived(args);\n        },\n        onReceiveOffload: (event, args) => {\n          logger_1.log.debug('onreceiveoffload: ', args);\n          this.modifyBackoff(args.body);\n          this.onCloseReceived(args.status);\n        },\n        onUnsupported: () => {\n          this.closeSocket(true);\n          this.finalizeSocket();\n        },\n        onError: (lifecycle, graceful) => {\n          this.closeSocket(graceful);\n          this.finalizeSocket();\n        },\n        onEnterState: event => {\n          if (event.from !== 'none') {\n            this.changeState(event);\n          }\n        },\n        onInvalidTransition: (transition, from, to) => {\n          logger_1.log.warn('FSM: unexpected transition', from, to);\n        }\n      }\n    });\n  }\n\n  changeState(event) {\n    logger_1.log.debug(\"FSM: \".concat(event.transition, \": \").concat(event.from, \" --> \").concat(event.to));\n\n    if (this.lastEmittedState !== this.state) {\n      this.lastEmittedState = this.state;\n      this.emit('stateChanged', this.state);\n    }\n  }\n\n  resetBackoff() {\n    logger_1.log.trace('resetBackoff');\n    this.retrier.stop();\n  }\n\n  modifyBackoff(body) {\n    logger_1.log.trace('modifyBackoff', body);\n    let backoffPolicy = body ? body.backoff_policy : null;\n\n    if (backoffPolicy && typeof backoffPolicy.reconnect_min_ms === 'number') {\n      this.retrier.modifyBackoff(backoffPolicy.reconnect_min_ms);\n    }\n  }\n\n  startDisconnectTimer() {\n    logger_1.log.trace('startDisconnectTimer');\n\n    if (this.disconnectingTimer) {\n      clearTimeout(this.disconnectingTimer);\n      this.disconnectingTimer = null;\n    }\n\n    this.disconnectingTimer = setTimeout(() => {\n      logger_1.log.debug('disconnecting is timed out');\n      this.closeSocket(true);\n    }, DISCONNECTING_TIMEOUT);\n  }\n\n  cancelDisconnectTimer() {\n    logger_1.log.trace('cancelDisconnectTimer');\n\n    if (this.disconnectingTimer) {\n      clearTimeout(this.disconnectingTimer);\n      this.disconnectingTimer = null;\n    }\n  }\n\n  get isConnected() {\n    return this.state === 'connected' && this.websocket.isConnected;\n  }\n\n  get state() {\n    switch (this.fsm.state) {\n      case 'connecting':\n      case 'initialising':\n      case 'retrying':\n      case 'error':\n        return 'connecting';\n\n      case 'updating':\n      case 'connected':\n        return 'connected';\n\n      case 'rejected':\n        return 'rejected';\n\n      case 'disconnecting':\n      case 'waitSocketClosed':\n      case 'waitOffloadSocketClosed':\n        return 'disconnecting';\n\n      case 'disconnected':\n      default:\n        return 'disconnected';\n    }\n  }\n\n  initRetry() {\n    logger_1.log.debug('initRetry');\n\n    if (this.retrier.inProgress) {\n      this.retrier.attemptFailed();\n    } else {\n      this.retrier.start();\n    }\n  }\n\n  retry() {\n    if (this.fsm.state != 'connecting') {\n      logger_1.log.trace('retry');\n      this.websocket.close();\n      this.fsm.userRetry();\n    } else {\n      logger_1.log.trace('can\\t retry as already connecting');\n    }\n  }\n\n  onConnected() {\n    this.emit('connected');\n  }\n\n  finalizeSocket() {\n    logger_1.log.trace('finalizeSocket');\n    this.websocket.close();\n    this.emit('disconnected');\n\n    if (this.disconnectedPromiseResolve) {\n      this.disconnectedPromiseResolve();\n      this.disconnectedPromiseResolve = null;\n    }\n  }\n\n  setupSocket() {\n    logger_1.log.trace('setupSocket:', this.config.token);\n    this.websocket.connect();\n  }\n\n  onIncomingMessage(message) {\n    let _parser_1$Parser$pars = parser_1.Parser.parse(message),\n        method = _parser_1$Parser$pars.method,\n        header = _parser_1$Parser$pars.header,\n        payload = _parser_1$Parser$pars.payload;\n\n    if (method !== 'reply') {\n      this.confirmReceiving(header);\n    }\n\n    if (method === 'notification') {\n      this.emit('message', header.message_type, payload);\n    } else if (header.method === 'reply') {\n      this.transport.processReply({\n        id: header.id,\n        status: header.status,\n        header: header,\n        body: payload\n      });\n    } else if (header.method === 'client_update') {\n      if (header.client_update_type === 'token_about_to_expire') {\n        this.emit('tokenAboutToExpire');\n      }\n    } else if (header.method === 'close') {\n      if (header.status.code === 308) {\n        logger_1.log.debug('Connection has been offloaded');\n        this.fsm.receiveOffload({\n          status: header.status.status,\n          body: payload\n        });\n      } else if (header.status.code === 406) {\n        // Not acceptable message\n        const message = \"Server closed connection because can't parse protocol: \".concat(JSON.stringify(header.status));\n        this.emitReplyConnectionError(message, header, true);\n        logger_1.log.error(message);\n        this.fsm.receiveFatalClose();\n      } else if (header.status.code === 417) {\n        // Protocol error\n        logger_1.log.error(\"Server closed connection because can't parse client reply: \".concat(JSON.stringify(header.status)));\n        this.fsm.receiveFatalClose(header.status.status);\n      } else if (header.status.code === 410) {\n        // Expired token\n        logger_1.log.warn(\"Server closed connection: \".concat(JSON.stringify(header.status)));\n        this.fsm.receiveClose(header.status.status);\n        this.emit('tokenExpired');\n      } else if (header.status.code === 401) {\n        // Authentication fail\n        logger_1.log.error(\"Server closed connection: \".concat(JSON.stringify(header.status)));\n        this.fsm.receiveClose(header.status.status);\n      } else {\n        logger_1.log.warn('unexpected message: ', header.status); // Try to reconnect\n\n        this.fsm.receiveOffload({\n          status: header.status.status,\n          body: null\n        });\n      }\n    }\n  }\n\n  sendInit() {\n    var _this = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var reply, isTerminalError;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            logger_1.log.trace('sendInit');\n            _context.prev = 1;\n            _context.next = 4;\n            return _this.transport.sendInit();\n\n          case 4:\n            reply = _context.sent;\n\n            _this.config.updateContinuationToken(reply.continuationToken);\n\n            _this.fsm.initSuccess(reply);\n\n            _this.emit('initialized', reply);\n\n            _this.emit('tokenUpdated');\n\n            _context.next = 15;\n            break;\n\n          case 11:\n            _context.prev = 11;\n            _context.t0 = _context[\"catch\"](1);\n\n            if (_context.t0 instanceof twilsockreplyerror_1.TwilsockReplyError) {\n              isTerminalError = false;\n              logger_1.log.warn(\"Init rejected by server: \".concat(JSON.stringify(_context.t0.reply.status)));\n\n              if (_context.t0.reply.status.code === 401 || _context.t0.reply.status.code === 403) {\n                isTerminalError = true;\n\n                _this.fsm.tokenRejected(_context.t0.reply.status);\n\n                if (_context.t0.reply.status.errorCode === _this.tokenExpiredSasCode) {\n                  _this.emit('tokenExpired');\n                }\n              } else if (_context.t0.reply.status.code === 429) {\n                _this.modifyBackoff(_context.t0.reply.body);\n\n                _this.fsm.initError(true);\n              } else if (_context.t0.reply.status.code === 500) {\n                _this.fsm.initError(false);\n              } else {\n                _this.fsm.initError(true);\n              }\n\n              _this.emitReplyConnectionError(_context.t0.message, _context.t0.reply, isTerminalError);\n            } else {\n              _this.emit('connectionError', {\n                terminal: true,\n                message: _context.t0.message,\n                httpStatusCode: null,\n                errorCode: null\n              });\n\n              _this.fsm.initError(true);\n            }\n\n            _this.emit('tokenUpdated', _context.t0);\n\n          case 15:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, null, [[1, 11]]);\n    }))();\n  }\n\n  sendUpdate() {\n    var _this2 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      var message, reply, isTerminalError;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            logger_1.log.trace('sendUpdate');\n            message = new Messages.Update(_this2.config.token);\n            _context2.prev = 2;\n            _context2.next = 5;\n            return _this2.transport.sendWithReply(message);\n\n          case 5:\n            reply = _context2.sent;\n\n            _this2.fsm.updateSuccess(reply.body);\n\n            _this2.emit('tokenUpdated');\n\n            _context2.next = 14;\n            break;\n\n          case 10:\n            _context2.prev = 10;\n            _context2.t0 = _context2[\"catch\"](2);\n\n            if (_context2.t0 instanceof twilsockreplyerror_1.TwilsockReplyError) {\n              isTerminalError = false;\n              logger_1.log.warn(\"Token update rejected by server: \".concat(JSON.stringify(_context2.t0.reply.status)));\n\n              if (_context2.t0.reply.status.code === 401 || _context2.t0.reply.status.code === 403) {\n                isTerminalError = true;\n\n                _this2.fsm.tokenRejected(_context2.t0.reply.status);\n\n                if (_context2.t0.reply.status.errorCode === _this2.tokenExpiredSasCode) {\n                  _this2.emit('tokenExpired');\n                }\n              } else if (_context2.t0.reply.status.code === 429) {\n                _this2.modifyBackoff(_context2.t0.reply.body);\n\n                _this2.fsm.updateError(_context2.t0.reply.status);\n              } else {\n                _this2.fsm.updateError(_context2.t0.reply.status);\n              }\n\n              _this2.emitReplyConnectionError(_context2.t0.message, _context2.t0.reply, isTerminalError);\n            } else {\n              _this2.emit('error', false, _context2.t0.message, null, null);\n\n              _this2.fsm.updateError(_context2.t0);\n            }\n\n            _this2.emit('tokenUpdated', _context2.t0);\n\n          case 14:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2, null, [[2, 10]]);\n    }))();\n  }\n\n  emitReplyConnectionError(message, header, terminal) {\n    const description = header.status && header.status.description ? header.status.description : message;\n    const httpStatusCode = header.status.code;\n    const errorCode = header.status && header.status.errorCode ? header.status.errorCode : null;\n    this.emit('connectionError', {\n      terminal: terminal,\n      message: description,\n      httpStatusCode: httpStatusCode,\n      errorCode: errorCode\n    });\n  }\n\n  cancelInit() {\n    logger_1.log.trace('cancelInit'); // TODO: implement\n  }\n\n  cancelUpdate() {\n    logger_1.log.trace('cancelUpdate'); // TODO: implement\n  }\n  /**\n   * Should be called for each message to confirm it received\n   */\n\n\n  confirmReceiving(messageHeader) {\n    logger_1.log.trace('confirmReceiving');\n\n    try {\n      this.transport.send(new Messages.Reply(messageHeader.id));\n    } catch (e) {\n      logger_1.log.debug('failed to confirm packet receiving', e);\n    }\n  }\n  /**\n   * Shutdown connection\n   */\n\n\n  closeSocket(graceful) {\n    logger_1.log.trace(\"closeSocket (graceful: \".concat(graceful, \")\"));\n\n    if (graceful && this.transport.isConnected) {\n      this.transport.sendClose();\n    }\n\n    this.websocket.close();\n    trampoline(() => this.fsm.socketClosed());\n  }\n  /**\n   * Initiate the twilsock connection\n   * If already connected, it does nothing\n   */\n\n\n  connect() {\n    logger_1.log.trace('connect');\n    this.fsm.userConnect();\n  }\n  /**\n   * Close twilsock connection\n   * If already disconnected, it does nothing\n   */\n\n\n  disconnect() {\n    logger_1.log.trace('disconnect');\n\n    if (this.fsm.is('disconnected')) {\n      return Promise.resolve();\n    }\n\n    return new Promise(resolve => {\n      this.disconnectedPromiseResolve = resolve;\n      this.fsm.userDisconnect();\n    });\n  }\n  /**\n   * Update fpa token for twilsock connection\n   */\n\n\n  updateToken(token) {\n    logger_1.log.trace('updateToken:', token);\n    return new Promise((resolve, reject) => {\n      this.once('tokenUpdated', e => {\n        if (e) {\n          reject(e);\n        } else {\n          resolve();\n        }\n      });\n      this.fsm.userUpdateToken();\n    });\n  }\n\n  get isTerminalState() {\n    return this.terminalStates.indexOf(this.fsm.state) !== -1;\n  }\n\n  onCloseReceived(reason) {\n    this.websocket.close();\n  }\n\n}\n\nexports.TwilsockChannel = TwilsockChannel;\nexports.TwilsockImpl = TwilsockChannel;","map":{"version":3,"sources":["C:/Users/khouloud/Documents/PI/MERN_Stack_PI/node_modules/twilsock/lib/twilsock.js"],"names":["Object","defineProperty","exports","value","events_1","require","StateMachine","logger_1","Messages","parser_1","twilsockreplyerror_1","backoffretrier_1","DISCONNECTING_TIMEOUT","trampoline","f","setTimeout","preparePayload","payload","JSON","stringify","Request","Response","TwilsockChannel","EventEmitter","constructor","websocket","transport","config","terminalStates","lastEmittedState","undefined","tokenExpiredSasCode","on","fsm","socketConnected","e","socketClosed","message","onIncomingMessage","emit","terminal","httpStatusCode","errorCode","retrier","BackoffRetrier","retryPolicy","retry","err","log","warn","disconnect","window","addEventListener","debug","systemOnline","close","init","transitions","name","from","to","methods","onConnecting","setupSocket","onEnterInitialising","sendInit","onLeaveInitialising","cancelInit","onEnterUpdating","sendUpdate","onLeaveUpdating","cancelUpdate","onEnterRetrying","initRetry","onEnterConnected","resetBackoff","onConnected","onUserUpdateToken","onTokenRejected","closeSocket","finalizeSocket","onUserDisconnect","onEnterDisconnecting","startDisconnectTimer","onLeaveDisconnecting","cancelDisconnectTimer","onEnterWaitSocketClosed","onLeaveWaitSocketClosed","onEnterWaitOffloadSocketClosed","onLeaveWaitOffloadSocketClosed","onDisconnected","onReceiveClose","event","args","onCloseReceived","onReceiveOffload","modifyBackoff","body","status","onUnsupported","onError","lifecycle","graceful","onEnterState","changeState","onInvalidTransition","transition","state","trace","stop","backoffPolicy","backoff_policy","reconnect_min_ms","disconnectingTimer","clearTimeout","isConnected","inProgress","attemptFailed","start","userRetry","disconnectedPromiseResolve","token","connect","Parser","parse","method","header","confirmReceiving","message_type","processReply","id","client_update_type","code","receiveOffload","emitReplyConnectionError","error","receiveFatalClose","receiveClose","reply","updateContinuationToken","continuationToken","initSuccess","TwilsockReplyError","isTerminalError","tokenRejected","initError","Update","sendWithReply","updateSuccess","updateError","description","messageHeader","send","Reply","sendClose","userConnect","is","Promise","resolve","userDisconnect","updateToken","reject","once","userUpdateToken","isTerminalState","indexOf","reason","TwilsockImpl"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nconst StateMachine = require(\"javascript-state-machine\");\nconst logger_1 = require(\"./logger\");\nconst Messages = require(\"./protocol/messages\");\nconst parser_1 = require(\"./parser\");\nconst twilsockreplyerror_1 = require(\"./error/twilsockreplyerror\");\nconst backoffretrier_1 = require(\"./backoffretrier\");\nconst DISCONNECTING_TIMEOUT = 3000;\n// Wraps asynchronous rescheduling\n// Just makes it simpler to find these hacks over the code\nfunction trampoline(f) {\n    setTimeout(f, 0);\n}\n/**\n * Makes sure that body is properly stringified\n */\nfunction preparePayload(payload) {\n    switch (typeof payload) {\n        case 'undefined':\n            return '';\n        case 'object':\n            return JSON.stringify(payload);\n        default:\n            return payload;\n    }\n}\nclass Request {\n}\nclass Response {\n}\nexports.Response = Response;\n/**\n * Twilsock channel level protocol implementation\n */\nclass TwilsockChannel extends events_1.EventEmitter {\n    constructor(websocket, transport, config) {\n        super();\n        this.terminalStates = ['disconnected', 'rejected'];\n        this.lastEmittedState = undefined;\n        this.tokenExpiredSasCode = 20104;\n        this.websocket = websocket;\n        this.websocket.on('connected', () => this.fsm.socketConnected());\n        this.websocket.on('disconnected', (e) => this.fsm.socketClosed());\n        this.websocket.on('message', (message) => this.onIncomingMessage(message));\n        this.websocket.on('socketError', e => this.emit('connectionError', { terminal: false, message: e.message, httpStatusCode: null, errorCode: null }));\n        this.transport = transport;\n        this.config = config;\n        this.retrier = new backoffretrier_1.BackoffRetrier(config.retryPolicy);\n        this.retrier.on('attempt', () => this.retry());\n        this.retrier.on('failed', err => {\n            logger_1.log.warn(`Retrying failed: ${err.message}`);\n            this.disconnect();\n        });\n        if (typeof window !== 'undefined' && typeof window.addEventListener !== 'undefined') {\n            window.addEventListener('online', () => {\n                logger_1.log.debug('Browser reported connectivity state: online');\n                this.fsm.systemOnline();\n            });\n            window.addEventListener('offline', () => {\n                logger_1.log.debug('Browser reported connectivity state: offline');\n                this.websocket.close();\n                this.fsm.socketClosed();\n            });\n        }\n        this.fsm = new StateMachine({\n            init: 'disconnected',\n            transitions: [\n                { name: 'userConnect', from: ['disconnected', 'rejected'], to: 'connecting' },\n                { name: 'userConnect', from: ['connecting', 'connected'] },\n                { name: 'userDisconnect', from: ['connecting', 'initialising', 'connected', 'updating', 'retrying', 'rejected',\n                        'waitSocketClosed', 'waitOffloadSocketClosed'], to: 'disconnecting' },\n                { name: 'userRetry', from: ['retrying'], to: 'connecting' },\n                { name: 'socketConnected', from: ['connecting'], to: 'initialising' },\n                { name: 'socketClosed', from: ['connecting', 'initialising', 'connected', 'updating', 'error',\n                        'waitOffloadSocketClosed'], to: 'retrying' },\n                { name: 'socketClosed', from: ['disconnecting'], to: 'disconnected' },\n                { name: 'socketClosed', from: ['waitSocketClosed'], to: 'disconnected' },\n                { name: 'socketClosed', from: ['rejected'], to: 'rejected' },\n                { name: 'initSuccess', from: ['initialising'], to: 'connected' },\n                { name: 'initError', from: ['initialising'], to: 'error' },\n                { name: 'tokenRejected', from: ['initialising', 'updating'], to: 'rejected' },\n                { name: 'protocolError', from: ['initialising', 'connected', 'updating'], to: 'error' },\n                { name: 'receiveClose', from: ['initialising', 'connected', 'updating'], to: 'waitSocketClosed' },\n                { name: 'receiveOffload', from: ['initialising', 'connected', 'updating'], to: 'waitOffloadSocketClosed' },\n                { name: 'unsupportedProtocol', from: ['initialising', 'connected', 'updating'], to: 'unsupported' },\n                { name: 'receiveFatalClose', from: ['initialising', 'connected', 'updating'], to: 'unsupported' },\n                { name: 'userUpdateToken', from: ['disconnected', 'rejected', 'connecting', 'retrying'], to: 'connecting' },\n                { name: 'userUpdateToken', from: ['connected'], to: 'updating' },\n                { name: 'updateSuccess', from: ['updating'], to: 'connected' },\n                { name: 'updateError', from: ['updating'], to: 'error' },\n                { name: 'userSend', from: ['connected'], to: 'connected' },\n                { name: 'systemOnline', from: ['retrying'], to: 'connecting' }\n            ],\n            methods: {\n                onConnecting: () => {\n                    this.setupSocket();\n                    this.emit('connecting');\n                },\n                onEnterInitialising: () => {\n                    this.sendInit();\n                },\n                onLeaveInitialising: () => {\n                    this.cancelInit();\n                },\n                onEnterUpdating: () => {\n                    this.sendUpdate();\n                },\n                onLeaveUpdating: () => {\n                    this.cancelUpdate();\n                },\n                onEnterRetrying: () => {\n                    this.initRetry();\n                    this.emit('connecting');\n                },\n                onEnterConnected: () => {\n                    this.resetBackoff();\n                    this.onConnected();\n                },\n                onUserUpdateToken: () => {\n                    this.resetBackoff();\n                },\n                onTokenRejected: () => {\n                    this.resetBackoff();\n                    this.closeSocket(true);\n                    this.finalizeSocket();\n                },\n                onUserDisconnect: () => {\n                    this.closeSocket(true);\n                },\n                onEnterDisconnecting: () => {\n                    this.startDisconnectTimer();\n                },\n                onLeaveDisconnecting: () => {\n                    this.cancelDisconnectTimer();\n                },\n                onEnterWaitSocketClosed: () => {\n                    this.startDisconnectTimer();\n                },\n                onLeaveWaitSocketClosed: () => {\n                    this.cancelDisconnectTimer();\n                },\n                onEnterWaitOffloadSocketClosed: () => {\n                    this.startDisconnectTimer();\n                },\n                onLeaveWaitOffloadSocketClosed: () => {\n                    this.cancelDisconnectTimer();\n                },\n                onDisconnected: () => {\n                    this.resetBackoff();\n                    this.finalizeSocket();\n                },\n                onReceiveClose: (event, args) => {\n                    this.onCloseReceived(args);\n                },\n                onReceiveOffload: (event, args) => {\n                    logger_1.log.debug('onreceiveoffload: ', args);\n                    this.modifyBackoff(args.body);\n                    this.onCloseReceived(args.status);\n                },\n                onUnsupported: () => {\n                    this.closeSocket(true);\n                    this.finalizeSocket();\n                },\n                onError: (lifecycle, graceful) => {\n                    this.closeSocket(graceful);\n                    this.finalizeSocket();\n                },\n                onEnterState: event => {\n                    if (event.from !== 'none') {\n                        this.changeState(event);\n                    }\n                },\n                onInvalidTransition: (transition, from, to) => {\n                    logger_1.log.warn('FSM: unexpected transition', from, to);\n                }\n            }\n        });\n    }\n    changeState(event) {\n        logger_1.log.debug(`FSM: ${event.transition}: ${event.from} --> ${event.to}`);\n        if (this.lastEmittedState !== this.state) {\n            this.lastEmittedState = this.state;\n            this.emit('stateChanged', this.state);\n        }\n    }\n    resetBackoff() {\n        logger_1.log.trace('resetBackoff');\n        this.retrier.stop();\n    }\n    modifyBackoff(body) {\n        logger_1.log.trace('modifyBackoff', body);\n        let backoffPolicy = body ? body.backoff_policy : null;\n        if (backoffPolicy && typeof backoffPolicy.reconnect_min_ms === 'number') {\n            this.retrier.modifyBackoff(backoffPolicy.reconnect_min_ms);\n        }\n    }\n    startDisconnectTimer() {\n        logger_1.log.trace('startDisconnectTimer');\n        if (this.disconnectingTimer) {\n            clearTimeout(this.disconnectingTimer);\n            this.disconnectingTimer = null;\n        }\n        this.disconnectingTimer = setTimeout(() => {\n            logger_1.log.debug('disconnecting is timed out');\n            this.closeSocket(true);\n        }, DISCONNECTING_TIMEOUT);\n    }\n    cancelDisconnectTimer() {\n        logger_1.log.trace('cancelDisconnectTimer');\n        if (this.disconnectingTimer) {\n            clearTimeout(this.disconnectingTimer);\n            this.disconnectingTimer = null;\n        }\n    }\n    get isConnected() {\n        return this.state === 'connected' && this.websocket.isConnected;\n    }\n    get state() {\n        switch (this.fsm.state) {\n            case 'connecting':\n            case 'initialising':\n            case 'retrying':\n            case 'error':\n                return 'connecting';\n            case 'updating':\n            case 'connected':\n                return 'connected';\n            case 'rejected':\n                return 'rejected';\n            case 'disconnecting':\n            case 'waitSocketClosed':\n            case 'waitOffloadSocketClosed':\n                return 'disconnecting';\n            case 'disconnected':\n            default:\n                return 'disconnected';\n        }\n    }\n    initRetry() {\n        logger_1.log.debug('initRetry');\n        if (this.retrier.inProgress) {\n            this.retrier.attemptFailed();\n        }\n        else {\n            this.retrier.start();\n        }\n    }\n    retry() {\n        if (this.fsm.state != 'connecting') {\n            logger_1.log.trace('retry');\n            this.websocket.close();\n            this.fsm.userRetry();\n        }\n        else {\n            logger_1.log.trace('can\\t retry as already connecting');\n        }\n    }\n    onConnected() {\n        this.emit('connected');\n    }\n    finalizeSocket() {\n        logger_1.log.trace('finalizeSocket');\n        this.websocket.close();\n        this.emit('disconnected');\n        if (this.disconnectedPromiseResolve) {\n            this.disconnectedPromiseResolve();\n            this.disconnectedPromiseResolve = null;\n        }\n    }\n    setupSocket() {\n        logger_1.log.trace('setupSocket:', this.config.token);\n        this.websocket.connect();\n    }\n    onIncomingMessage(message) {\n        let { method, header, payload } = parser_1.Parser.parse(message);\n        if (method !== 'reply') {\n            this.confirmReceiving(header);\n        }\n        if (method === 'notification') {\n            this.emit('message', header.message_type, payload);\n        }\n        else if (header.method === 'reply') {\n            this.transport.processReply({\n                id: header.id,\n                status: header.status,\n                header: header,\n                body: payload\n            });\n        }\n        else if (header.method === 'client_update') {\n            if (header.client_update_type === 'token_about_to_expire') {\n                this.emit('tokenAboutToExpire');\n            }\n        }\n        else if (header.method === 'close') {\n            if (header.status.code === 308) {\n                logger_1.log.debug('Connection has been offloaded');\n                this.fsm.receiveOffload({ status: header.status.status, body: payload });\n            }\n            else if (header.status.code === 406) { // Not acceptable message\n                const message = `Server closed connection because can't parse protocol: ${JSON.stringify(header.status)}`;\n                this.emitReplyConnectionError(message, header, true);\n                logger_1.log.error(message);\n                this.fsm.receiveFatalClose();\n            }\n            else if (header.status.code === 417) { // Protocol error\n                logger_1.log.error(`Server closed connection because can't parse client reply: ${JSON.stringify(header.status)}`);\n                this.fsm.receiveFatalClose(header.status.status);\n            }\n            else if (header.status.code === 410) { // Expired token\n                logger_1.log.warn(`Server closed connection: ${JSON.stringify(header.status)}`);\n                this.fsm.receiveClose(header.status.status);\n                this.emit('tokenExpired');\n            }\n            else if (header.status.code === 401) { // Authentication fail\n                logger_1.log.error(`Server closed connection: ${JSON.stringify(header.status)}`);\n                this.fsm.receiveClose(header.status.status);\n            }\n            else {\n                logger_1.log.warn('unexpected message: ', header.status);\n                // Try to reconnect\n                this.fsm.receiveOffload({ status: header.status.status, body: null });\n            }\n        }\n    }\n    async sendInit() {\n        logger_1.log.trace('sendInit');\n        try {\n            let reply = await this.transport.sendInit();\n            this.config.updateContinuationToken(reply.continuationToken);\n            this.fsm.initSuccess(reply);\n            this.emit('initialized', reply);\n            this.emit('tokenUpdated');\n        }\n        catch (ex) {\n            if (ex instanceof twilsockreplyerror_1.TwilsockReplyError) {\n                let isTerminalError = false;\n                logger_1.log.warn(`Init rejected by server: ${JSON.stringify(ex.reply.status)}`);\n                if (ex.reply.status.code === 401 || ex.reply.status.code === 403) {\n                    isTerminalError = true;\n                    this.fsm.tokenRejected(ex.reply.status);\n                    if (ex.reply.status.errorCode === this.tokenExpiredSasCode) {\n                        this.emit('tokenExpired');\n                    }\n                }\n                else if (ex.reply.status.code === 429) {\n                    this.modifyBackoff(ex.reply.body);\n                    this.fsm.initError(true);\n                }\n                else if (ex.reply.status.code === 500) {\n                    this.fsm.initError(false);\n                }\n                else {\n                    this.fsm.initError(true);\n                }\n                this.emitReplyConnectionError(ex.message, ex.reply, isTerminalError);\n            }\n            else {\n                this.emit('connectionError', { terminal: true, message: ex.message, httpStatusCode: null, errorCode: null });\n                this.fsm.initError(true);\n            }\n            this.emit('tokenUpdated', ex);\n        }\n    }\n    async sendUpdate() {\n        logger_1.log.trace('sendUpdate');\n        let message = new Messages.Update(this.config.token);\n        try {\n            let reply = await this.transport.sendWithReply(message);\n            this.fsm.updateSuccess(reply.body);\n            this.emit('tokenUpdated');\n        }\n        catch (ex) {\n            if (ex instanceof twilsockreplyerror_1.TwilsockReplyError) {\n                let isTerminalError = false;\n                logger_1.log.warn(`Token update rejected by server: ${JSON.stringify(ex.reply.status)}`);\n                if (ex.reply.status.code === 401 || ex.reply.status.code === 403) {\n                    isTerminalError = true;\n                    this.fsm.tokenRejected(ex.reply.status);\n                    if (ex.reply.status.errorCode === this.tokenExpiredSasCode) {\n                        this.emit('tokenExpired');\n                    }\n                }\n                else if (ex.reply.status.code === 429) {\n                    this.modifyBackoff(ex.reply.body);\n                    this.fsm.updateError(ex.reply.status);\n                }\n                else {\n                    this.fsm.updateError(ex.reply.status);\n                }\n                this.emitReplyConnectionError(ex.message, ex.reply, isTerminalError);\n            }\n            else {\n                this.emit('error', false, ex.message, null, null);\n                this.fsm.updateError(ex);\n            }\n            this.emit('tokenUpdated', ex);\n        }\n    }\n    emitReplyConnectionError(message, header, terminal) {\n        const description = header.status && header.status.description\n            ? header.status.description\n            : message;\n        const httpStatusCode = header.status.code;\n        const errorCode = header.status && header.status.errorCode\n            ? header.status.errorCode\n            : null;\n        this.emit('connectionError', { terminal: terminal, message: description, httpStatusCode: httpStatusCode, errorCode: errorCode });\n    }\n    cancelInit() {\n        logger_1.log.trace('cancelInit');\n        // TODO: implement\n    }\n    cancelUpdate() {\n        logger_1.log.trace('cancelUpdate');\n        // TODO: implement\n    }\n    /**\n     * Should be called for each message to confirm it received\n     */\n    confirmReceiving(messageHeader) {\n        logger_1.log.trace('confirmReceiving');\n        try {\n            this.transport.send(new Messages.Reply(messageHeader.id));\n        }\n        catch (e) {\n            logger_1.log.debug('failed to confirm packet receiving', e);\n        }\n    }\n    /**\n     * Shutdown connection\n     */\n    closeSocket(graceful) {\n        logger_1.log.trace(`closeSocket (graceful: ${graceful})`);\n        if (graceful && this.transport.isConnected) {\n            this.transport.sendClose();\n        }\n        this.websocket.close();\n        trampoline(() => this.fsm.socketClosed());\n    }\n    /**\n     * Initiate the twilsock connection\n     * If already connected, it does nothing\n     */\n    connect() {\n        logger_1.log.trace('connect');\n        this.fsm.userConnect();\n    }\n    /**\n     * Close twilsock connection\n     * If already disconnected, it does nothing\n     */\n    disconnect() {\n        logger_1.log.trace('disconnect');\n        if (this.fsm.is('disconnected')) {\n            return Promise.resolve();\n        }\n        return new Promise((resolve) => {\n            this.disconnectedPromiseResolve = resolve;\n            this.fsm.userDisconnect();\n        });\n    }\n    /**\n     * Update fpa token for twilsock connection\n     */\n    updateToken(token) {\n        logger_1.log.trace('updateToken:', token);\n        return new Promise((resolve, reject) => {\n            this.once('tokenUpdated', e => {\n                if (e) {\n                    reject(e);\n                }\n                else {\n                    resolve();\n                }\n            });\n            this.fsm.userUpdateToken();\n        });\n    }\n    get isTerminalState() {\n        return this.terminalStates.indexOf(this.fsm.state) !== -1;\n    }\n    onCloseReceived(reason) {\n        this.websocket.close();\n    }\n}\nexports.TwilsockChannel = TwilsockChannel;\nexports.TwilsockImpl = TwilsockChannel;\n"]},"metadata":{},"sourceType":"script"}